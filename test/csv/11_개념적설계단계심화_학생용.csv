데이터베이스 데이터베이스 - Story Board - 11 회차 : 개념적 설계 단계 심화 김 은 경 ,1
개념적 설계 단계 심화 2 학습목표 동기유발 & 학습목표 학습내용 1. ER 모델 세분화 방법 학습목표 2. ER 모델 정제 방법 1. 개체의 심화 요소를 나열할 수 있다.  2. 관계의 심화 요소를 나열할 수 있다.  3. 속성의 심화 요소를 나열할 수 있다.  1. 슈퍼-서브 타입의 3가지 정제 방법을 설명할 수 있다.  2. 속성을 개체로 전환하는 경우를 설명할 수 있다.  ,1
개념적 설계 단계 심화 3 Lesson. ER 모델 세분화 방법 1. 개체의 심화 요소 2. 관계의 심화 요소 3. 속성의 심화 요소 4. 관계 행렬 활용 개념적 모델링 방법 ,1
개념적 설계 단계 심화 4 개체의 심화 요소 1) 부모 개체 – 다른 개체가 파생 되는 근원이 되는 개체로서  다 른 개체와는 무관하게 독립적으 로 존재하는 개체 2) 자식 개체 – 부모 개체로부터 파생된 개체로서  반드시 부모 개체가 존재해야 생성되는 개체 1. 개체의 심화 요소 - 보다 세분화된 개념적 모델링을 위해서 개체를 다음과 같이 6가지로 세분할 수 있다.  (1) 키 개체(Key Entity) - 해당 업무에서 원래부터 존재하는 개체로서  다른 개체와의 관계에 의해 생성된 개체가 아닌  원래 독립적으로 존재하는 개체이다. - 다른 개체의 부모 개체가 되므로 가장 우선해서 추출한다. - 예: 사원  부서  고객  상품 등 (2) 메인 개체(Main Entity) - 키 개체들 간의 업무적인 관련성 때문에 생성되는 것으로  해당 업무에서 핵심적으로 관리되는 데이터로부터 추출된다. - 부모 개체를 갖는 파생 개체이지만  업무의 중심이 되며  다른 개체들을 파생시킨다. - 메인 개체는 기초적인 ER 모델에서는 대개 ‘관계’에 해당한다. - 예: 주문(고객과 상품 개체가 부모 개체)  사고청구(고객과 사고 개체가 부모 개체)   보험계약(고객과 보험상품이 부모 개체)   출하지시(부서와 제품이 부모 개체) 등 ,1
개념적 설계 단계 심화 5 개체의 심화 요소 (3) 액션 개체(Action Entity) - 메인 개체로부터 파생되고 내용이 자주 바뀌는 개체 - 초기 분석 단계에서는 잘 드러나지 않지만 모델링을 세분화하는 단계에서 도출된다. (4) 약한 개체(Weak Entity) - 독립적으로 존재하지 못하고 소유 개체(Owner Entity)가 있어야 존재할 수 있으며  고유한 식별자가 없기 때문에 자신의 구분자(부분 키)를 소유 개체의 식별자와 결합해서 복합 식별자를 지정해야 한다. - 예: 부양가족 ß 소유 개체는 사원 개체 접속기록 개체 ß 소유 개체는 고객 개체 키 개체 메인 개체 액션 개체 교수  학생 지도 지도내역 학생  교과목 수강 수강내역 사원  부서 근무 근무평가 고객  상품 주문 배송상태이력 ,1
개념적 설계 단계 심화 6 개체의 심화 요소 (5) 코드 개체(Code Entity) - 정보를 간단히 표현하기 위한 기호를 나타내는 개체로서  실제 업무에서 사용하는 코드도 있지 만 데이터를 효율적으로 표현하기 위해서 생성하는 경우도 있다. 예) 전공 코드 개체 – 1: 컴퓨터  2: 전자  3: 전기  4: 기계  … - 너무 많은 코드 개체를 식별하면 개념적 모델링이 너무 복잡해지므로 반드시 개념적 설계 단계에서 식별할 필요는 없다. 전공코드 전공이름 1 컴퓨터 2 전자 3 전기 4 기계 . . .  . . .  ,1
개념적 설계 단계 심화 7 개체의 심화 요소 (6) 관계 개체(Association Entity) - 두 개체 간의 M : N 관계로 인해 생성되는 개체로서  교차 개체라고도 칭한다. - ER 모델을 피터 첸 표기법으로 표현할 때는 M : N 관계도 마름모로 표현할 수 있지만  IE 표기법으로 표현할 때 M : N 관계를 정확히 표현하기 위해서 관계 개체를 생성해서 표현해야 한다. - 관계 개체의 식별자는 양쪽 개체의 식별자를 합친 복합 식별자로 지정한다. - 메인 개체가 관계 개체인 경우가 많다. 예) ‘주문하다’ 관계 개체 표현 a) 피터 첸 표기법 고객 상품 주문하다 고객번호 이름 연락처 주소 상품번호 상품명 가격 세부사양 M N 일자 수량 결재여부 ,1
개념적 설계 단계 심화 8 개체의 세부 분류 b) IE 표기법 ① 기본 표현 - M : N 관계 유형을 까마귀 발로 표현하고  관계 이름만 표현한다. ② 관계 개체 추가 표현 - 관계 개체를 추가해서 관계의 모든 속성을 표현하고  기존 기체와는 1 : N 관계로 표현할 수 있다. 상품번호 상품명 가격 세부사양 상품 고객번호 이름 연락처 주소 고객 주문하다 상품번호 상품명 가격 세부사양 상품 고객번호 이름 연락처 주소 고객 고객번호 (FK) 상품번호 (FK) 일자 수량 결재여부 주문하다 ,1
개념적 설계 단계 심화 9 관계의 심화 요소 2. 관계의 심화 요소 - 보다 세분화된 개념적 모델링을 위해서 관계를 다음과 같이 3가지로 세분할 수 있다.  (1)  병렬 관계(Parallel Relationship)  - 두 개체 사이에 두 개 이상의 관계가 존재하는 것으로  다중 관계라고도 칭한다. [예제 1] 사원과 부서 개체 사이의 ‘근무하다’라는 관계와 ‘관리하다’라는 2개 관계 존재 - ‘근무하다’라는 관계에는 모든 사원 개체가 참여하는 전체 참여이지만   ‘관리하다’라는 관계에는 일부 사원  즉 부서장에 해당하는 사원만 참여하는 부분 참여이다.  사원 부서 근무하다 사원번호 이름 업무 급여 부서번호 부서명 사무실 전화번호 1 N 관리하다 1 1 ,1
개념적 설계 단계 심화 10 관계의 심화 요소 [예제 2] 부서 개체와 공사 개체 사이의 관계를 분석하면  어떤 부서는 공사를 발주하고  어떤 부서는 감독하고  어떤 부서는 정산을 담당하므로  이를 각각 표현하는 대신 3개의 병렬 관계로 표현 할 수 있다.  à 하나의 공사는 하나의 발주부서에서 발주하고  한 관리부서에서 감독하고  또 한 정산부서 에서 정산하며  각 부서는 하나 이상의 공사를 발주  감독  정산하므로  부서와 공사 간의 관계 유형은 모두 1 : N이다.  ü 각각 표현하는 경우:  발주부서 공사 부서번호 부서명 연락처 사무실 공사번호 공사명 시작일 종료일 1 N 발주하다 감독부서 공사 부서번호 부서명 연락처 사무실 공사번호 공사명 시작일 종료일 1 N 감독하다 ,1
개념적 설계 단계 심화 11 관계의 심화 요소 è 병렬 관계로 표현하는 경우:  부서 공사 정산하다 부서번호 부서명 연락처 사무실 공사번호 공사명 시작일 종료일 1 N 감독하다 발주하다 1 1 N N 정산부서 공사 부서번호 부서명 연락처 사무실 공사번호 공사명 시작일 종료일 1 N 정산하다 심화 학습 ,1
개념적 설계 단계 심화 12 관계의 심화 요소 è 릴레이션 스키마로 변환 : 심화 학습 부서(부서번호  부서명   연락처  사무실) 공사(공사번호  공사명   시작일  종료일) 발주하다(공사번호  발주부서번호)  감독하다(공사번호  감독부서번호)  정산하다(공사번호  정산부서번호)  외래 키 단순화 :  공사(공사번호  공사명   시작일  종료일  발주부서번호  감독부서번호  정산부서번호)  외래 키 ,1
개념적 설계 단계 심화 13 관계의 심화 요소 (2) 직렬 관계(Serial Relationship)  - 병렬 관계로 나열한 여러 관계를 하나의 상위 개념으로 통합해서 M : N 관계로 바꾸어서 표현한 것 을 의미한다. 예) 앞의 예제에서 발주하다  감독하다  정산하다 라는 3개의 병렬 관계를 상위 개념인 ‘관리하다’ 라는 관계로 통합해서 표현한다.  à 한 공사에 대해 여러 부서가 발주  감독  정산을 나누어서 하므로  관계 유형은 M : N이 된다.  부서 공사 부서번호 부서명 연락처 사무실 공사번호 공사명 시작일 종료일 M N 관리하다 심화 학습 심화 학습 è 릴레이션 스키마로 변환 : 부서(부서번호  부서명   연락처  사무실) 공사(공사번호  공사명   시작일  종료일) 관리하다(공사번호  부서번호)  혹은 관리하다(공사번호  부서번호  관리유형)  발주  감독  정산 등 ,1
개념적 설계 단계 심화 14 관계의 심화 요소 (3)  병렬 관계와 직렬 관계의 특징 비교 - 모델링 할 때 병렬 관계와 직렬 관계의 특징을 잘 비교해서 선택해야 한다.  병렬 관계의 특징 직렬 관계의 특징 관계를 표현하기 위해 별도의 테이블(릴레이 션)이 불필요하다.  관계를 표현하기 위해 별도의 테이블(릴레이션)이 필요하다.  하나의 관계가 하나의 속성으로 표현된다.  하나의 관계가 하나의 개체로 표현된다.  새로운 관계가 추가되거나 변경될 때 유연하 게 대처하기 어렵다. 새로운 관계가 추가되거나 변경될 때 유연하게 대처할 수 있다. 관계 내용별로 상세 정보를 관리할 수 없다.  관계 내용별로 상세 정보를 관리할 수 있다.  상세 정보를 관 리할 자식 개체 를 할 수 없으 므로 새로운 관계(예: 감리 하다)가 추가되면  새 로운 데이터를 추가해 서 대응할 수 있으므 로 새로운 관계(예: 감리 하다)가 추가되면  새 로운 열(속성)을 추가 해야 하므로 자식 개체를 생 성해서 상세 정 보를 관리할 수 있으므로 ,1
개념적 설계 단계 심화 15 관계의 심화 요소 (4)  순환 관계(Self Relationship)  1) 순환 관계란?  - 하나의 개체가 다른 개체가 아닌 자기 자신과 관계를 맺는 것을 의미한다.  2) 1 : N 순환 관계 - 기관의 조직도  관리자 정보 등과 같이 계층 구조를 표현할 때 발생한다.  예) 사원의 관리자 관계 표현 김장수 이영희 박문숙 민경호 장경수 김만호 최영민 박영미 오지민 이숙자 김은주 나민아 1 N 사원 사원번호 이름 업무 급여 관리하다 ,1
개념적 설계 단계 심화 16 관계의 심화 요소 3) M : N 순환 관계 - 선수 과목이나  구성부품 정보 등과 같이 네트워크 구조를 표현할 때 발생한다.  예) 선수과목 관계 표현 C 언어 C++ 언어 자료구조 파일구조 전산개론 알고리즘 M N 교과목 교과목번호 교과명 학점 필수여부 선수하다 ,1
개념적 설계 단계 심화 17 관계의 심화 요소 예) 구성 부품 관계 표현 M N 부품 부품번호 부품명 제조사 가격 구성하다 D E G K B K C A F H I L ,1
개념적 설계 단계 심화 18 속성의 심화 요소 * 저장 속성(Stored Attribute) – 유도 속성을 결정하기 위해 사용된 속성 3. 속성의 심화 요소 - 보다 세분화된 개념적 모델링을 위해서 속성의 유형을 다음과 같이 3가지로 세분할 수 있다.  (1)  기초 속성(Basic Attribute)  - 업무로부터 추출된 일반적인 속성이다.  - 데이터 요구 분석 명세서에 포함되어 있으며  현업에서 제공해야 속성이 유지될 수 있다.    - 예: 상품명  가격  주문수량 등 (2)  설계 속성(Designed Attribute)  - 원래 존재하지는 않지만 필요에 따라 설계자가 추가한 속성이다.  - 데이터 요구 분석 명세서에 포함되어 있지는 않지만  설계를 진행하면서 새로 생성된 것이다. - 대부분의 코드 속성이나 일련번호처럼 식별자 역할을 하도록 추가된 속성이 해당한다.  - 예: 주문번호  예약번호  고객번호  상품코드 등 (3)  유도 속성(Derived Attribute)  - 추출 속성이라고도 칭하며  기본 속성으로부터 계산 등의 가공 처리를 통해서 생성된 속성이다. - 저장 속성의 영향을 받으므로  저장 속성의 값이 변경되면 함께 변경된다.  - 중복의 의미가 있으므로 대개 개념적 모델링 단계에서 식별하지 않는다.  (반드시 필요한 경우라면 별도로 정리해서 구현 단계에서 참조한다.)  - 예: 나이(생년월일 속성에서 유도됨)  근무기간(입사일 속성에서 유도됨) 등 ,1
개념적 설계 단계 심화 19 관계 행렬 활용 4. 관계 행렬 활용 (1)  관계 행렬(Relationship Matrix)이란?  - 개체들 간의 관계를 정의하기 위해서 사용하는 보조 도구이다.  (2)  관계 행렬 작성 방법 ① 개체를 가장 상위 행과 가장 좌측 열에 모두 표시한다. ② 개체들 간의 관계 유무를 셀(Cell)에 표시한다. ③ 1차적으로 조금이라도 관련성이 있으면 모두 표시한다. ④ 식별된 관계의 구체적인 이름을 부여한다. ⑤ 상관 관계가 없으면 셀에 ‘-’을 표시한다. ⑥ 1열의 개체가 주어에 해당한다.  ⑦ 순환 관계는 대각선 셀에 표시한다.  ⑧ 관계 행렬의 내용을 참조해서 최종 관계를 판단한다.  ,1
개념적 설계 단계 심화 20 관계의 여러 유형 (3)  관계 행렬 작성 예제 고객 부품 주문 창고 고객 - 주문하다 - - 부품 - 구성하다 포함되다 - 주문 - 발주하다 - - 창고 - 보관하다 - - ,1
개념적 설계 단계 심화 21 Lesson. ER 모델 정제 방법 1. 슈퍼-서브 타입 정제 2. 카테고리 정제 3. 속성을 개체로 전환하기 4. 개체·관계·속성 검증 ER 모델 정제 방법 ,1
개념적 설계 단계 심화 22 슈퍼-서브 타입 정제 (1) 슈퍼-서브 타입 정제 기준 ① 서브타입 개체에 독자적으로 고유한 속성이 없거나 독자적인 관계가 없는 경우 속성으로 표현한다.  ② 서브타입으로 분할했을 때 개념적 모델링이 너무 복잡해지면 분할하지 않는다.  ③ 서브 타입으로 분할된 수가 너무 많은 경우  각각을 독립된 개체로 분리할 것을 고려한다.    (2) 슈퍼-서브 타입 정제 방법 ① 슈퍼타입 개체를 기준으로 통합하는 방법 ② 서브타입 개체를 기준으로 통합하는 방법 ③ 슈퍼타입과 서브타입 개체를 각각 분리하는 방법 1. 슈퍼-서브 타입 정제 ,1
개념적 설계 단계 심화 23 슈퍼-서브 타입 정제 (3) 슈퍼타입 개체 기준 통합 방법 ① 서브타입 개체에 있던 속성을 모두 슈퍼타입 개체에 포함시킨다.   ② 서브타입 개체와 연결된 관계를 모두 슈퍼타입 개체와 연결시킨다.  ③ 서브타입 개체를 모두 삭제한다.  ü 슈퍼타입 개체를 기준으로 통합하는 경우 ① 응용 프로그램에서 서브타입을 구분해서 처리하지 않는 경우 ② 서브타입 개체에 속하는 데이터를 명확하게 구분하기 어려운 경우 ③ 서브타입 개체에 사용되는 속성 수가 매우 적은(1-2개) 경우 ,1
개념적 설계 단계 심화 24 슈퍼-서브 타입 정제 직원 정규직 계약직 직원번호 이름 급여 입사일 직급 호봉 슈퍼타입 개체 서브타입 개체 통합 직원 직원번호 이름 급여 입사일 직급 호봉 계약기간 ü 예제 : 정규직과 계약직이라는 2개의 서브타입 개체를 직원이라는 슈퍼타입 개체에 통합하기 (대부분의 응용 프로그램에서 정규직과 계약직을 구분해서 처리하지 않는 경우)  계약기간 계약유형 계약유형 ,1
개념적 설계 단계 심화 25 슈퍼-서브 타입 정제 (4) 서브타입 개체 기준 통합 방법 ① 슈퍼타입 개체에 있던 모든 속성을 각각의 서브타입 개체로 이동시킨다.   ② 슈퍼타입 개체에 연결된 관계를 각각의 서브타입 개체에 연결시킨다.  ③ 슈퍼타입 개체를 삭제한다.  ü 서브타입 개체를 기준으로 통합하는 경우 ① 슈퍼타입 개체에 속하는 속성의 수가 많지 않은 경우 ② 슈퍼타입 개체의 관계가 적은 경우 ③ 슈퍼타입 개체에 접근하는 응용 프로그램의 수가 적은 경우 ,1
개념적 설계 단계 심화 26 슈퍼-서브 타입 정제 직원 정규직 계약직 직원번호 이름 급여 입사일 직급 호봉 슈퍼타입 개체 서브타입 개체 통합 정규직 직원번호 이름 급여 입사일 직급 호봉 ü 예제 : 직원이라는 슈퍼타입 개체를 정규직과 계약직이라는 2개의 서브타입 개체와 통합하기 (대부분의 응용 프로그램에서 정규직과 계약직을 확실히 구분해서 처리하는 경우)  계약직 직원번호 이름 급여 입사일 계약기간 계약기간 계약유형 계약유형 ,1
개념적 설계 단계 심화 27 슈퍼-서브 타입 정제 (5)  슈퍼타입과 서브타입 개체를 각각 분리하는 방법 ① 슈퍼타입  서브타입 개체를 각각 개별 개체로 분리한다.    ② 분리된 슈퍼타입 개체와 서브타입 개체를 1 : 1 관계로 연결한다.  (즉  슈퍼타입 개체의 기본 키를 서브타입 개체의 기본 키로 추가함) ü 슈퍼타입  서브타입 개체를 각각 분리하는 경우 - 데이터 모델의 유연성을 보장해야 하는 경우 ,1
개념적 설계 단계 심화 28 슈퍼-서브 타입 정제 ü 예제 : 슈퍼 타입인 직원 개체와 서브 타입인 정규직 및 계약직 개체를 각각 분리시키기 (정규직과 계약직을 확실히 구분해서 처리하는 응용 프로그램과 구분 없이 처리하는 응용 프로그램의 수가 비슷하고  추후 다양한 응용 프로그램이 추가될 예정인 경우)  계약직 계약기간 직원 직원번호 이름 급여 입사일 정규직 직급 호봉 근무하다 계약하다 1 1 1 1 직원 정규직 계약직 직원번호 이름 급여 입사일 직급 호봉 계약기간 슈퍼타입 개체 서브타입 개체 계약유형 계약유형 ,1
개념적 설계 단계 심화 29 슈퍼-서브 타입 정제 직원 직원번호 이름 급여 입사일 정규직 직급 호봉 직원번호 계약직 계약 기간 계약 유형 직원번호 ,1
개념적 설계 단계 심화 30 카테고리 정제 2. 카테고리 정제 (1) 카테고리 정제 기준 ① 카테고리(서브 타입 개체)를 독립된 개체로 만들고  기본 키를 포함시킨다.  ② 카테고리에 속하는 모든 개체 타입(슈퍼 타입 개체)을 카테고리 개체와 각각 1: N 관계로 연결한다.  (2) 예제 차량 소유주 개인 회사 U 등록일 주민등 록번호 이름 주소 회사명 주소 맴버(슈퍼타입 개체) 카테고리(서브타입 개체) 실제로 DB에 등록되는 차량 소유주는 개인과 회사의 합 집합의 부분집합에 해당함 ,1
개념적 설계 단계 심화 31 카테고리 정제 차량 소유주 개인 회사 등록일 주민등 록번호 이름 주소 회사명 주소 등록번호 등록되다 지정되다 1 1 n n ,1
개념적 설계 단계 심화 32 속성을 개체로 전환하는 경우 3. 속성을 개체로 전환하는 경우 1)  속성 값이 없는 경우 - 많은 개체가 널(NULL) 값을 갖는 속성은 별도의 개체로 분리하고  원래 개체와 1 : 1 관계로 연결한다.  - 예: 병력 관련 속성을 포함하는 대학생 개체 à 군 미필이거나 여학생인 경우  해당 속성들은 모두 널 값을 갖게 됨 à 병력 관련 속성들을 모아서 별도의 군필자 개체를 생성하고  해당 대학생과 1 : 1 관계를 표시함 대학생 학번 이름 성별 연락처 군번 최종계급 최종근무지 병과 주소 군필자 군번 최종계급 최종근무지 병과 대학생 학번 이름 성별 연락처 주소 제대하다 1 1 ,1
개념적 설계 단계 심화 33 속성을 개체로 전환하는 경우 2) 속성 값이 여러 부분으로 구성된 경우 - 속성의 수가 많으면서 특징을 구분할 수 있는 여러 부분으로 구성된 경우   특징 별로 별도의 개체로 분리한다.   - 예:  개인신상정보  급여정보  학력정보 등으로 구분되면서 수십 개의 속성을 갖는 사원 개체 à 개인신상정보  급여정보  학력정보 등을 각각 별도의 개체로 분리함 사원 사번 주민등 록번호 이름 연락처 호봉 상여금 최종학력 급여 주소 . . .  사원 사번 주민등 록번호 이름 연락처 주소 급여정보 사번 호봉 급여 상여금 학력정보 사번 최종학력 출신고교 출신대학 전공 ,1
개념적 설계 단계 심화 34 개체·관계·속성 검증 4. 개체·관계·속성 검증 (1) 개체 검증 방법 - 다음과 같은 질문을 통해서 개념적 모델링 단계에서 식별한 개체가 적절한지 검증한다.  ① 유용한 정보를 제공하는가?  - 업무에 활용되지 않고 값이 변하지 없는 개체는 삭제한다.  ② 유일한 식별자(후보 키)를 포함하고 있는가?  - 식별자가 없으면 데이터의 일관성과 무결성을 보장하지 못하므로   필요하다면 설계 속성을 추가한다.   ③ 속성의 수가 2개 이상인가?  - 속성이 하나 밖에 없는 경우  다른 개체의 속성으로 표현하는 것이 바람직하다.   - 식별자가 2개의 속성으로 결합된 경우라도 2개 속성으로 인정한다.  ④ 다른 개체와 관계(Relationship)가 있는가? - 일부 코드 개체나 통계용 개체를 제외하면 모두 다른 개체와 관계가 있어야 한다.  ⑤ 실제 데이터가 2개 이상 존재하는가?  - 데이터가 하나 밖에 없다면 업무적으로 관리할 필요가 없는 개체일 가능성이 크기 때문에 삭제한다.  ,1
개념적 설계 단계 심화 35 개체·관계·속성 검증 (2) 관계 검증 방법 - 다음과 같은 질문을 통해서 개념적 모델링 단계에서 식별한 관계가 적절한지 검증한다.  ① 관계가 현재 업무 규칙에 적절한 것인가?  ② 관계명이 두 개체 사이의 업무적 연관성을 표현하는 구체적인 이름인가?  ③ 관계의 유형이 적절한가?  ④ 관계의 카디널리티가 적절한가?  ⑤ 필수/선택 여부  즉 전체 참여와 부분 참여가 적절한가?  ,1
개념적 설계 단계 심화 36 개체·관계·속성 검증 (3) 속성 검증 방법 - 다음과 같은 질문을 통해서 개념적 모델링 단계에서 식별한 속성이 적절한지 검증한다.  ① 각기 다른 의미를 갖는 여러 개의 속성을 묶어서 하나의 속성으로 정의한 것은 아닌가? - 그렇다면 각각을 별개의 속성으로 구분해야 한다.   ② 속성이 단 하나의 값만 갖는 것이 아닌가? - 모든 개체가 동일한 하나의 값만을 갖는 속성이 있다면 제거해야 한다.  예) 한국인 개체의 국적 속성 ③ 코드 값을 갖는 속성이 현업에서 통상적으로 사용되는 코드 값을 갖는가? - 그렇지 않다면 코드 사용을 억제해야 한다.  ④ 전산 처리에 필요한 플래그(Flag) 형태의 속성이 아닌가? - 플래그 형태의 속성은 제외시켜야 한다.   ,1
