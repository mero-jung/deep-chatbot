0000	헬로우		0
0000	헬로		0
0000	안부 인사드립니다.		0
0000	먼저 인사하려고 했는데 짝남이 먼저 인사해줬어. 더 떨렸겠어요.		0
0000	먼저 인사할까 했는데 짝녀가 먼저 인사해줬어. 기분 좋았겠네요.		0
0000	각자 집에 인사드리러 가 제가 더 떨리네요.		0
0000	이별의 마무리 가벼운 안부 인사일 거예요.		0
0000	용기내서 새해인사 했네 이제 연락하지 마세요.		0
0000	오늘 마지막 인사를 하러가네 미련없길 바랄게요.		0
0000	오늘 마지막 인사하러 갑니다. 미련없이 정리했긴 바랍니다.		0
0000	내 마음에 마지막 인사 마음이랑 잘 인사해요.		0
0000	먼저 잘게 잘자 안녕히 주무세요.		0
0000	진짜 이제 안녕 맘고생 많았어요.		0
0000	잘가 안녕.		0
0000	이제 진짜 안녕!! 안녕!		0
0000	이젠 진짜 진짜 안녕 맘 고생 많았어요.		0
0000	안녕을 고하며 잘 보내주었나요.		0
0000	안녕하세 안녕하세요.		0
0000	안녕하세요		0
0000	반가워요		0
0000	반가반가		0
0000	방가방가		0
0000	하이		0
0000	안녕		0
0000	좋은 아침이야		0
0000	진짜 반갑다		0
0000	요즘 어떻게 지냈어요?		0
0000	잘 지냈습니까?		0
0000	잘지내지?		0
0000	만나서 반가워요		0
0000	만나서 반갑습니다		0
0000	하이루		0
0000	반갑		0
0000	잘지냈어요?		0
0000	잘지냈어?		0
0000	나 먼저 잘게 안녕히 주무세요.		0
0000	안녕히 주무세요.		0
0000	안녕 안녕하세요.		0
0000	안녕안녕 안녕하세요.		0
0000	안녕하세요 안녕하세요.		0
0000	안뇽 안녕하세요.		0
0000	자야겠다. 안녕히 주무세요.		0
0000	이제 그만 잘래 안녕히 주무세요.		0
0000	속시원해~~안녕 잘가~~~ 이제 정말 안녕		0
0000	연락 처음에 어떻게 시작함 안녕 이라고 인사부터 해보세요.		0
0000	연락 어떻게 시작함 안녕 이라고 인사부터 해보세요.		0
0000	이제 거리 어디를 나서나 봄기운을 확연히 느낄 수 있는 계절입니다.		0
0000	밝고 생동감 넘치는 사람들의 표정에서도 어느덧 봄 기운을 느낄 수 있습니다.		0
0000	창문 틈으로 새어들어오는 따스한 햇볕이 온 몸을 훈훈하게 해 주는 따스한 계절 봄입니다.		0
0000	따스한 봄 기운이 겨우내 잔뜩 움츠렸던 어깨를 활짝 펴주는 계절의 여왕 봄입니다.		0
0000	일상의 단조로움을 환하게 밝혀주는 희망의 봄이 찾아왔습니다.		0
0000	거리마다 개나리 등 봄꽃들이 마중나와 환한 웃음을 짓게하는 사랑스런 계절 봄이 왔습니다.		0
0000	버들강아지 곱게 물이 오른 새봄의 기운 느끼시나요?		0
0000	얼어있던 들판을 녹이며 솟아오르는 아리랑이가 잠시 잊고 지냈던 그리움을 느끼게 해 줍니다.		0
0000	골목골목마다 봄 내음 물씬 풍겨오는 향기 가득한 계절 봄입니다.		0
0000	무엇이든 할 수 있을 것 같은 활기차고 희망찬 계절 봄이 왔습니다.		0
0000	반가운 손님처럼 어느새 찾아온 봄이 우리 주변을 향긋한 향기로 물들이고 있습니다.		0
0000	좋은 일만 생길 것 같은 가슴 벅찬 설렘 바로 봄이 우리에게 주는 선물이 아닐까 합니다.		0
0000	파릇파릇 새싹이 고개를 내밀며 인사하는 반가운 봄입니다.		0
0000	계절의 여왕 그야말로 생동하는 희망의 계절 봄이 왔습니다.		0
0000	거리를 노랗게 물들인 개나리와 불그스레 어린 신부의 부끄러움을 닮은 진달래꽃들의 향연이 즐거운 봄입니다.		0
0000	맑은 하늘 아래 파릇파릇 봄기운이 흐르고 들녘마다 아지랑이가 피어나는 생동의 계절 봄입니다.		0
0000	새로운 시작과 도전 꿈과 희망 열정이 떠오르는 계절 봄입니다.		0
0000	겨우내 움츠렸던 꽃망울들이 서로 경쟁하듯 톡톡 터지며 저마다의 향기를 뽐내는 봄입니다.		0
0000	어머니께서 가족들을 위해 쑥국과 냉이국을 끓여내던 따뜻한 추억이 문득 떠오르는 계절입니다.		0
0000	겨우내 앙상했던 산들도 어느덧 피어오른 봄꽃들의 향연으로 눈이 즐거운 계절 봄입니다.		0
0000	만물이 생동하는 봄이 왔습니다만 아직 겨울 끝자락의 매서움이 봄바람에 묻어나는 3월입니다.		0
0000	왠지 좋은 인연을 만날 수 잇을 것 같은 사랑하고 싶은 계절 봄입니다.		0
0000	신록의 푸르름에서 생동감을 느낄 수 있는 완연한 봄이 왔습니다.		0
0000	벚꽃 만발한 거리를 걷다보면 꼭 저에게도 꽃내음이 묻어날 것 같네요.		0
0000	우윳빛 목련꽃이 눈부시게 아름다운 봄입니다.		0
0000	언제 겨울이었냐는 듯이 하루가 다르게 초록으로 변하는 산과 들의 향연에 눈이 즐거운 계절 봄입니다.		0
0000	오늘 문득 올려다 본 하늘이 파란 물감을 풀어놓은 듯 너무 아름다웠습니다. 여러분들도 오늘 하루만이라도 머리를 들어 꼭 하늘을 바라보세요. 깊어진 봄 기운을 한껏 느끼실 수 있을 겁니다.		0
0000	흩날리는 벚꽃이 가슴 설레게 하는 4월입니다.		0
0000	모든 걸 훌훌 털어버리고 사랑하는 사람과 함께 봄 향기 가득한 곳으로 훌쩍 떠나고픈 4월입니다.		0
0000	무르익어 가는 봄 코 끝을 스치는 라일락 향기가 마음까지 설레게 하는 계절입니다.		0
0000	사랑하는 사람들이 생각나는 계절의 여왕 봄의 중심 5월입니다.		0
0000	늘 곁에서 힘이 되어주고 용기를 심어주는 가족의 소중함을 새삼 깨닫게 해 주는 가정의 달 5월입니다.		0
0000	산천에 피어있는 아카시아 꽃향기가 저물어가는 봄을 시위라도 하듯 진동하고 있는 황홀한 계절의 여왕 5월입니다.		0
0000	시간이 참 빠른 것 같습니다. 해맞이 행사로 00년 새해를 맞이한 게 정말 엊그제 같은데 벌써 봄을 지나 여름을 향해 가고 있습니다.		0
0000	산천 초목들의 녹음이 짙어가는 싱그러운 계절이 왔습니다.		0
0000	시원한 바다 거센 파도 눈부신 햇살이 문득 그리운 계절 여름이 다가왔습니다.		0
0000	젊은 열기가 느껴지는 젊음의 계절 여름입니다.		0
0000	아카시아 꽃향기가 코끝을 간지럽히는 향기로운 6월입니다.		0
0000	뜨거운 태양아래 무르익어가는 여름들녁에서 힘찬 생명력을 느낄 수 있습니다.		0
0000	봄기운을 미처 만끽하기도 전에 벌써 본격적인 더위가 찾아왔습니다.		0
0000	갑자기 무더워진 날씨로 혹여나 000님들 몸과 마음이 지치고 힘드시지 않을까 걱정입니다.		0
0000	생명력 넘치는 나뭇잎들과 함께 어느새 높아진 기온이 여름이 성큼 다가온 것 같습니다.		0
0000	무더위를 식히려는 듯 시원한 빗줄기가 마른 대지를 적셔주는 초여름입니다.		0
0000	푸른 초록의 싱그러움에 삶이 더욱 활기차게 느껴지는 초여름날 오후에 ~~~~ 시간을 갖게 되어		0
0000	뜨거운 태양이 작열하는 열정의 계절 여름입니다.		0
0000	조금만 걸어도 땀이 비오듯 내리는 무더위네요. 시원한 물 한 잔이 더없이 고맙게 느껴지는 요즘입니다.		0
0000	학창시절 친구들과 계곡에서 맘껏 뛰어놀던 추억이 떠오르는 7월입니다.		0
0000	지치기 쉬운 폭염을 이겨내기 위해서는 잠시라도 하던 일을 멈추고 사랑하는 가족 지인들과 함께하는 즐겁고 유쾌한 시간이 꼭 필요합니다. 여름휴가들은 다녀오셨나요?		0
0000	아직 여름휴가를 다녀오지 않으셨다면 남은 기간 알찬 휴가계획 세우셔서 가까운 산과 바다에서 지친 피로를 말끔히 씻어내시길 바랍니다.		0
0000	따갑게 내리쬐는 여름햇살 때문에 좀처럼 열기가 식지 않는 후덥지근한 저녁날씨에도 불구하고 ~~ 많이 참석해 주신 ~~~~ 께 진심으로 감사의 말씀을 전합니다.		0
0000	더운 날씨로 인해 지친 몸과 마음을 푸르른 산과 시원한 바다로 달려가 그동안 지친 피로를 말끔히 씻어 버리고		0
0000	땡볕이 물고 늘어져 힘든 날씨지만 긴 폭염 속에 들려오는 귀뚜라미 노랫소리가 가을을 알리는 것 같습니다.		0
0000	꽃들이 시간을 다투며 아름답고 우아하게 형형색색 자신들의 매력을 뽐내고 있는 아름다운 계절 여름입니다.		0
0000	풍성한 수확의 계절 여유로움과 넉넉한을 주는 10월 가을향기 가득한 이곳 000에서		0
0000	아침저녁으로 불어오는 신선한 바람이 가을이 멀지 않았음을 알려주는 것 같습니다.		0
0000	노오란 은행잎과 진홍색의 단풍잎들이 아름다운 한 폭의 풍경화를 그려내고		0
0000	천혜의 자연 풍광을 품고 있는 산 언저리에는 감탄스러운 만추의 모습이 연출되고 있습니다.		0
0000	여러분들의 가슴에도 가을햇살 같은 즐거움과 풍성한 행복이 가득하길 바래봅니다.		0
0000	지난달까지만 해도 한낮에는 다소 덥던 날씨가 언제 그랬냐는 듯 청명한 가을날씨를 보이고 있습니다.		0
0000	짧은 가을이 깊어가는 시월이 찾아왔습니다.		0
0000	긴 폭염을 밀어내는 선선한 가을바람이 상쾌함을 전해줍니다.		0
0000	귀뚜라미 울음소리와 귓가에 맴도는 매미소리가 떠나가는 여름을 못내 아쉬워하는 것만 같습니다.		0
0000	황금들녁 먹거리 풍성한 가을입니다. 좋은 사람들과 넉넉한 행복을 나누기 좋은 계절입니다.		0
0000	제각기 풍성하고 아름다운 색채를 뽐내던 가로수들이 어느새 앙상한 가지를 드러내고 있는 것을 보면 겨울이 오긴 온 것 같습니다.		0
0000	한 해를 시작하기 위해 분주히 발걸음을 옮긴 지가 엊그제 같은데 벌써 일년을 정리하는 끝자락에 와있습니다.		0
0000	어느새 헐벗은 나뭇가지를 보니 겨울의 중심에 와 있음을 느낄 수 있습니다.		0
0000	모락모락 길거리 따뜻한 호빵의 유혹을 지나치기 힘든 계절이 찾아왔습니다.		0
0000	아침저녁으로 매서운 바람에 옷깃을 여미게 되는 겨울입니다.		0
0000	가족 연인 친구와 함께 올해 마지막 추억을 만들어 가는 12월입니다.		0
0000	어느새 매서운 바람이 가을을 몰아내고 겨울을 가지고 들어 왔네요.		0
0000	한 해를 보내는 아쉬운 마음과 새해를 맞는 설레임이 교차하는 12월입니다.		0
0000	연초에 다짐했던 계획들 잘 정리하고 계신가요? 남은 날들 계획한 모든 일들이 잘 이루어지기를 바랍니다.		0
0000	찬바람 때문에 몸은 잔뜩 움츠려들지만 12월은 연말연시를 맞아 따뜻한 정을 나눌 수 있는 훈훈한 계절임은 확실한 것 같습니다.		0
0000	올해도 한장의 달력만을 남겨두고 있습니다. 열심히 달려온 우리 자신에게 격려와 박수를 보낼 수 있는 12월이 되었으면 합니다.		0
0000	가로를 뒤덮던 낙엽도 어느새 흔적도 없이 사라지고 이제는 그 자리를 소복히 채워 줄 함박눈이 기다려지는 12월입니다.		0
0000	데이터베이스 데이터베이스 1 회차 : 데이터베이스(DB) 개요 김 은 경 	1
0000	DB 개요 2 학습에 앞서 학습내용 학습내용과 학습목표 동기유발 & 학습목표 1. 데이터베이스의 기본 개념 학습목표 2.  데이터베이스의 필요성 1. 데이터베이스를 정의할 수 있다. 2. 데이터베이스의 정의에 함축된 4가지 개념을 설명할 수 있다.     1. 데이터베이스 구축의 필요성을 설명할 수 있다. 2. 데이터베이스의 2가지 개념적 구성 요소를 설명할 수 있다.  학습목표 	1
0000	DB 개요 3 Lesson. DB의 기본 개념 1. 데이터와 정보의 차이점 2. 데이터베이스의 정의 3. 데이터베이스의 특징 4. 데이터베이스의 출현 배경 이번 레슨에서는 데이터와 정보의 차이점을 이해하고  데이터베이스란 무엇이며  또 데이터베이스의 특징과 출현 배경에 대해 알아보도록 하겠습 니다. DB의 기본 개념 	1
0000	DB 개요 4 1. 데이터와 정보의 차이점 (1) 데이터(Data)란? - 데이터란 현실 세계에서 단순한 관찰이나 측정을 통해서 수집된 사실(Fact) 또는 값(Value)이 어떤 기준에 의해 정리되어 있는 것을 의미한다.  (2) 정보(Information)란?  - 정보란 어떤 상황에서 적절한 의사 결정을 할 수 있도록 지원하는 지식으로  컴퓨터 시스템과 같은 처리기를 통한 데이터의 유효한 해석이나 데이터 상호간의 관계를 의미한다. - 즉  정보는 데이터가 어떤 목적에 의해 해석되거나 가공된 형태를 의미한다. 데이터와 정보의 차이점 해석 or 가공 (컴퓨터 시스템) 정보 데이터 [제목] 데이터와 정보의 차이점 	1
0000	DB 개요 5 DB란?  2. 데이터베이스란?  (1) 데이터베이스(Database:  DB)의 정의 - 데이터베이스는 어느 한 조직의 다양한 응용 프로그램들이 공동으로 사용하는 데이터들을 통합하여 저장한 운영 데이터의 집합이다.  - 보다 쉽게 정의하면  사람들이 필요로 하는 데이터를 모아둔 것이다.   (2) DB 정의에 함축된 개념 ① DB는 공용 데이터(Shared Data)이다. - 한 조직의 여러 응용 프로그램이 공동으로 사용하는 것이다. - 즉  여러 사용자가 서로 다른 목적으로 공유한다. ② DB는 통합된 데이터(Integrated Data)이다. - 여러 부서에서 사용하는 데이터를 한 곳에 모아서 공동 관리하는 것이다. (기억장소 절약) - 원칙적으로 동일한 데이터의 중복을 허용하지 않지만  검색의 효율성을 위해서 최소한의 중복(Minimal Redundancy)을 허용하여 통합한다. ③ DB는 저장된 데이터(Stored Data)이다. - 컴퓨터가 접근할 수 있는 디스크와 같은 저장 매체에 저장된 것이다. ④ DB의 데이터는 운영 데이터(Operational Data)이다. - 조직의 운영에 기본적으로 반드시 필요한 데이터를 저장하는 것이다. - 즉  조직의 고유한 기능을 수행하는데 필수적인 데이터를 저장하는 것이다. - 일시적으로 필요한 임시 데이터나 단순한 입출력 데이터는 운영 데이터에 해당하지 않는다. 참고 심화학습 	1
0000	DB 개요 6 참고 [참고]  ‘데이터베이스’ 및 ‘데이터베이스 시스템’이란 용어의 기원 (1) 1963년 6월 미국 SDC(System Development Corporation)사가 개최한 제1차 심포지엄의 제목인 “컴퓨터 중심의 데이터베이스 개발과 관리(Development and Management of  a Computer- centered Data Base)”에서 데이터베이스란 용어가 공식적으로 처음 사용된 것으로 알려져 있다. - 이때의 데이터베이스는 저장장치에 저장된 파일을 의미하며  현재의 데이터베이스와는 차이가 있음 - 이때 데이터베이스의 영문 표기가 ‘Data Base’라는 두 단어로 표기되었다가  점차 한 단어인 ‘Database’로 통일되었음 (2) 1965년 9월 제2차 SDC 심포지엄의 제목인 “컴퓨터 중심의 데이터베이스 시스템(Computer- centered Data Base Systems)”에서 데이터베이스 시스템이란 용어가 공식적으로 처음 사용된 것으로 알려져 있다.  	1
0000	DB 개요 7 [심화 학습] 최소한의 중복(Minimal Redundancy)이란?  - DB는 원칙적으로 데이터의 중복된 저장을 허용하지 않지만  보다 효율적인 처리를 위해서 최소한 의 중복이 부득이한 경우가 있다.    예를 들면  학생 데이터에 ‘학과’가 포함되어 있고  학과 정보 데이터에도 ‘학과’가 포함되어 있으면 ‘학과’라는 데이터가 중복되었다고 생각할 수 있다. 하지만  이런 중복은 추후 어떤 학생이 속한 학과의 학과장이나 재학생 수를 검색하기 위한 부득이한 중복이므로  이런 중복을 최소한의 중복이라고 한다.    (최소한의 중복은 뒤에서 학습하게 될 “외래 키”와 밀접한 관련성이 있음)   [심화 학습] 터 - 최소한의 중복은 미리 파악해서 관리할 수 있으므로  통제된 중복(Controlled Redundancy이라고도 한다.    	1
0000	DB 개요 8 3. DB의 특징 ① 동시 공용(Concurrent Sharing) - 여러 응용 프로그램이나 사용자들이 서로 다른 목적으로 데이터를 동시에 사용할 수 있다. ② 지속적인 변화(Continuous Evolution) - DB에 저장된 데이터는 고정된 것이 아니며  삽입  삭제  갱신 등을 통해서 지속적으로 변화함으로써 현재의 정확한 데이터를 유지해야 한다.  ③ 실시간 접근성(Real-Time Accessibility) - 컴퓨터가 접근할 수 있는 기록 매체에 저장되어 관리되므로  언제든지 필요한 시점에 바로 접근 가능해야 한다. 즉  어떤 질의에 대해 실시간에 바로 응답해야 한다.  ④ 내용에 의한 참조(Content Reference) - 데이터가 저장된 주소나 위치가 아닌  데이터의 내용 즉  값(Value)에 의해서 참조된다. - 즉  사용자가 원하는 데이터의 조건을 명시하면  조건을 만족하는 레코드가 어디에 위치하든 접근 가능하다. ⑤ 데이터베이스 관리 시스템(Database Management System: DBMS)에 의한 관리 - DB의 구축 및 관리를 위해서 전용 소프트웨어인 DBMS가 필요하다. DB의 특징 	1
0000	DB 개요 9 4. DB의 출현 배경 (1)  데이터 저장 및 관리를 위한 2가지 방법 ① 파일 처리 시스템을 이용한다. ② 데이터베이스 관리시스템(DBMS)를 이용한다.  (2)  파일 처리 시스템의 특징 ① 데이터 종속성(Data Dependency) - 응용 프로그램과 데이터 간의 밀접한 연관성으로 인해   데이터를 저장한 파일 구조가 변경되면 응용 프로그램도 변경해야 한다.  ② 데이터 중복성(Data Redundancy) - 응용 프로그램의 독립적인 파일 관리로 인해  응용 프로그램 별로 독립된 파일을 가지므로 데이터의 중복 저장이 불가피하여 데이터 값의 불일치가 발생할 가능성이 매우 높다.                 DB의 출현 배경 데이터베이스는 왜 출현하게 되었을까요? DB(디비)의 출현 배경을 이해하기 위해서는  데이터를 저장하고 관리하는 또 다른 방법인 파일 관리 시 스템의 특징과 문제점을 이해할 필요가 있습니다. 파일 처리 시스템에는 어떤 문제점이 있는지 확인해 보세요.  * 파일 처리 시스템 - 각각의 응용 프로그램이 자신의 데이터 를 파일 형태로 별도로 관리하는   파일 중심의 데이터 처리 시스템 을 의미한다.  	1
0000	DB 개요 10 (3)  파일 처리 시스템의 문제점 ① 데이터의 중복 저장으로 인한 비효율성 - 여러 파일에 동일한 데이터가 중복될 가능성이 높으므로  저장공간의 낭비  유지·보수의 어려움  데이터 보안의 어려움 등이 유발된다.  예) ‘회원정보 관리 프로그램’의 데이터 파일과 ‘회원등급 관리 프로그램’의 데이터 파일에 회원번호와 이름  휴대폰 번호가 중복되어 있으므로  회원 수가 많을수록 기억공간의 낭비가 심화된다.  DB의 출현 배경 회원등급 관리 프로그램 회원등급 데이터파일 회원번호 회원이름 휴대폰 번호 누적포인터 등급 회원정보 관리 프로그램 회원정보 데이터파일 회원번호 회원이름 휴대폰 번호 취미 주소 직업 예 	1
0000	DB 개요 11 ② 데이터 일관성(Consistency) 유지의 어려움 - 동일한 데이터가 여러 파일에 흩어져 있으므로  시간이 지남에 따라 동일한 데이터가 서로 다른 값을 가질 가능성이 커진다.  예) 어떤 회원의 ‘휴대폰번호’가 두 개의 다른 데이터 파일에 저장되어 있는데  회원정보 관리 프로그램을 통해서만 휴대폰번호를 변경한 경우  양쪽 파일의 데이터 값이 서로 다르므로 데이터의 일관성이 유지되지 않는다. 그 결과  회원 등급이 변경되어 회원정보 관리 프로그램에서 휴대폰으로 문자를 보내면  변경 전의 휴대폰 번호로 문자를 보내게 되므로 문자가 제대로 전달되지 않는다.  DB의 출현 배경 데이터 일관성(Consistency) - 중복된 데이터의 일치성에 관한 문제 회원등급 관리 프로그램 회원등급 데이터파일 회원번호 회원이름 휴대폰 번호 . . .  등급 회원정보 관리 프로그램 회원정보 데이터파일 회원번호 회원이름 휴대폰 번호 . . .  주소 118382 박문수 010-2233-4456 . . .  서울시 118385 이나영 010-3213-3344 . . .  천안시 …  … … . . .  … 118382 박문수 019-3355-4456 . . .  3 118385 이나영 010-3213-3344 . . .  2 …  … … . . .  … 예 	1
0000	DB 개요 12 ③ 데이터 무결성(Integrity) 유지의 어려움 - 어떤 데이터가 반드시 만족해야 하는 무결성 제약조건을 일일이 프로그램에서 처리해야 하므로   프로그램에서 빠뜨린 경우 무결성을 유지하기 어렵다.  예) 어떤 회사에서 서류 전형을 통해서 면접 대상자를 선정했는데   이때 토익 성적이 700점 이상인 지원자만 선정했다. 그런데 면접 대상자 데이터를 입력하면서 실수로 한 지원자의 토익 점수를 75점(원래는 750점)으로 잘못 입력했다. 그 결과 토익 성적 700점 이상인 수험생 정보만 저장되어야 한다는 무결성 제약조건을 위반하게 된다.  DB의 출현 배경 * 데이터 무결성(Integrity) - 데이터 값이 미리 정의된 제약 조건을 만족하는지를 의미하는 정확성에 관한 문제 합격자 선발 프로그램 면접대상자 데이터파일 수험생번호 토익 성적 학점 … 10022 770 4.0 … 10032 75 3.7 … 10046 800 3.6 … 10078 780 3.8 … …  …  … … 원래 면접대상자 데이터 파일에 저장될 수 없는 데이터가 저장됨 심화 학습 예 	1
0000	DB 개요 13 - 파일 시스템에서 무결성 제약조건을 유지하려면 각각의 무결성 제약조건을 일일이 응용 프로그램에서 처리해야 한다. 예를 들면  면접 대상자 데이터 파일에 데이터를 저장하기 전에 응용 프로그램에서 IF문 등을 사용해서 토익 성적이 700점 이상인지를 먼저 확인한 다음  700점 이상인 경우에만 데이터 파일에 저장되도록 처리해야 한다.  [심화 학습]  심화 학습 [파일 시스템에서 무결성 유지 방법] - 데이터베이스를 정의할 때 무결성 제약조건(토익성적 >= 700)을 함께 정의하면  DB가 갱신될 때마다 DBMS가 자동으로 제약조건의 만족 여부를 검사하므로 응용 프로그램에서 별도로 처리할 필요가 없다.  [데이터베이스에서 무결성 유지 방법] 	1
0000	DB 개요 14 ④ 데이터 공유의 어려움 - 데이터의 구조가 응용 프로그램마다 다르므로 데이터 파일이 동일한 데이터를 포함하고 있어도 데이터 공유가 어렵다.  예) 회원정보 관리 프로그램과 회원정보 분석 프로그램은 동일한 데이터를 사용하지만  회원이름과 직업의 필드 크기를 다르게 정의했기 때문에 데이터를 공유하기 어렵다.  DB의 출현 배경 1) 레코드(Record) – 하나 이상 의 필드(Field)로 구성된 정 보의 최소 단위로서  파일은 하나 이상의 레코드로 구성 된다. 2) 필드(Field) – 한 바이트 (Byte) 이상으로 구성된 논 리적인 데이터 단위로서  하 나 이상의 필드가 모여서 하 나의 레코드가 된다.   회원정보 관리 프로그램 회원정보관리 데이터파일 필드 구조 회원번호 숫자(8 Bytes) 회원이름 문자(8 Bytes) 휴대폰번호 문자(13 Bytes) 주소 문자(30 Bytes) 직업 문자(15 Bytes) 취미 문자(20 Bytes) 회원정보 분석 프로그램 회원정보분석 데이터파일 [회원정보관리 데이터파일의 레코드 구조] 필드 구조 회원번호 숫자(8 Bytes) 회원이름 문자(10 Bytes) 휴대폰번호 문자(13 Bytes) 주소 문자(30 Bytes) 직업 문자(20 Bytes) 취미 문자(20 Bytes) [회원정보분석 데이터파일의 레코드 구조] 예 	1
0000	DB 개요 15 (4)  DB 출현 배경과 파일 처리 시스템의 연관성 - 파일 처리 시스템의 여러 가지 문제점들을 해결하기 위해 DB가 출현했다고 볼 수 있다.  - 즉  DB는 데이터 종속성과 데이터 중복성을 해결하여  파일 처리 시스템의 여러 가지 문제점을 해결하고 구조적인 한계점을 극복하기 위해 고안된 것이다.  DB의 출현 배경 ü 주의 : DB를 구축하는 것이 모든 환경에서 적합한 것은 아니므로  DBMS와 파일 처리 시스템의 장단점을 잘 분석해서 선택해야 한다.  	1
0000	DB 개요 16 Lesson. 데이터베이스의 필요성 1. DB 구축의 필요성 2. DB의 장단점 3. DB의 개념적 구성 요소 4. DB의 저장 구조 DB의 필요성 	1
0000	DB 개요 17 1. DB 구축의 필요성 DB 구축의 필요성 (1) 기술적 측면에서의 필요성 ① 데이터의 중복으로 인한 데이터의 일관성 유지가 어렵다.  ② 데이터 접근에 대한 관리 및 통제가 필요하다. - 사용자 별로 접근 가능한 데이터를 제한할 필요가 있다. 예) 회사에서 일반 사원은 자신의 데이터만  관리자는 자기 부서의 모든 사원의 데이터에 접근할 수 있도록 통제한다. ③ 데이터 파일과 프로그램간의 종속성으로 인해 비효율성적이다. - 데이터 파일의 구조가 바뀔 때마다 프로그램을 수정해서 다시 컴파일 해야 하는 불편함이 있다. ④ 데이터가 여기 저기 흩어져 있으므로 보안 유지가 어렵다. - 데이터를 여러 곳에서 관리하다 보면  주요 데이터의 유출 위험이 커진다. (2) 조직적 측면에서의 필요성 ① 조직의 자산으로서 데이터를 관리할 필요가 있다.  ② 데이터의 공유가 필요하다. ③ 데이터의 일관성 및 무결성 유지가 필요하다. ④ 데이터의 최신성과 및 유용성을 유지할 필요가 있다. 	1
0000	DB 개요 18 2. DB의 장단점 DB의 장단점 앞에서 언급했듯이 모든 환경에서 DB(디비)를 구축하는 것이 최선인 것은 아니므로  DB(디비)의 장단점을 잘 분석한 다음  DB(디비) 구축 여부를 판단해야 합니다.  (1) DB의 장점 ① 데이터의 공유가 가능하다. ② 데이터에 대한 접근을 통제할 수 있다. ③ 중복 데이터가 적어진다. ④ 효율적인 유지 보수가 가능하다. ⑤ 데이터의 일관성 유지가 가능하다. ⑥ 생산성이 향상된다. (2) DB의 단점 ① 초기 개발 비용이 많이 든다. ② DB 관리를 전담할 전문 인력(DB 관리자)이 필요하다.  ③ 적시에  또한 지속적인 유지보수가 수반되지 않으면 무용지물이 될 수 있다. 	1
0000	DB 개요 19 3. DB의 개념적 구성 요소 (1) DB의 개념적 구성 요소란? - 사용자 관점에서 본 DB의 구성 요소를 의미하며  개체(Entity)와 관계(Relationship)로 구분한다.  ü 시스템 관점에서 본 물리적 구성 요소는 비트(Bit)  바이트(Byte)  블록(Block) 등으로 구분할 수 있다.  (2) 개체(Entity)  1) 개체란? - DB가 저장하는 유형  무형의 정보 대상으로  존재하면서 서로 구별될 수 있는 요소이다. 2) 개체의 특징 - 파일 시스템에서 레코드(Record)에 대응한다. - 단독으로 존재 가능하고  정보로서의 역할이 가능하다. - 하나 이상의 속성(Attribute)으로 구성된다. 예) 개체 - 학생 속성 - 학번  이름  학과 등 DB의 개념적 구성 요소 DB(디비)는 개념적으로 개체와 관계하는 두 개의 구성요소로 구성되며  개체는 하나 이상의 속성으로 구성됩니다. 개체와 관계에 대해서는 뒤에서 보다 자세히 학습하도록 하겠습니다.  	1
0000	DB 개요 20 DB의 개념적 구성 요소 3) 개체의 종류 ① 유형의 개체 : 사람  집 등 물리적으로 존재하는 개체를 의미한다. ② 무형의 개체 : 인사  급여  교과목 등 개념적으로 존재하는 개체를 의미한다. 4) 속성(Attribute)이란? - 개체의 특성을 나타내는 요소로  이름을 가진 정보의 가장 작은 논리적인 단위이다. 5) 속성의 특징 - 파일 시스템에서 데이터 항목(Data Item) 혹은 필드(Field)에 대응한다. - 단독으로 존재할 때는 대개 무의미하다. 	1
0000	DB 개요 21 (3) 관계(Relationship) 1) 관계란? - 일반적으로 개체들 간의 의미 있는 연결 또는 연관성을 의미하는 요소이다. 2) 관계의 특징 - 관계도 하나의 개체로 간주될 수 있다. - 속성 관계와 개체 관계로 세분할 수 있으며  그냥 ‘관계’라고 하면 ‘개체 관계’를 의미한다. 3) 관계의 유형 ① 일 대 일(1 : 1) : 한 개 개체가 한 개 개체와 연관되어 있는 유형이다. ② 일 대 다(1 : n) : 한 개 개체가 여러 개체와 연관성이 있는 유형이다. ③ 다 대 다(m : n) : 여러 개체가 여러 개체와 연관성이 있는 유형이다. DB의 개념적 구성 요소 	1
0000	DB 개요 22 4. DB의 저장 구조 DB의 구조 (1)  DB의 저장 구조 구분 - 물리적 저장 장치 위에 저장된 DB의 저장 구조를 사용자 관점에서 본 논리적 구조와 시스템(저장 장치) 관점에서 본 물리적 구조로 구분할 수 있다.  (2)  DB의 논리적 구조 - 물리적 저장 장치 위에 저장된 DB의 저장 구조를 사용자 관점에서 본 것으로  사용자가 생각하는 데이터의 구조를 표현한 것이다.  (3)  DB의 물리적 구조 - 물리적 저장 장치 위에 저장된 DB의 저장 구조를 시스템(저장 장치) 관점에서 본 것으로   디스크와 같은 저장 장치에 저장되는 데이터의 실제 구조를 표현한 것이다.   	1
0000	DB 개요 23 DB의 구조 [DB의 논리적 구조와 물리적 구조]  (사용자 관점)  (저장 장치 관점)  	1
0000	DB 개요 1. 데이터베이스(DB)의 정의와 함축된 개념 DB는 어느 한 조직의 다양한 응용 프로그램들이 공동으로 사용하는 데이터들을 통합하여 저장한 운영 데이터의 집합으로 정의할 수 있으며  다음과 같은 개념을 함축하고 있다.  ① DB는 한 조직의 여러 응용 프로그램에서 공동으로 사용하는 공용 데이터(Shared Data)이다. ② DB는 여러 부서에서 사용하는 데이터를 한 곳에 모아서 공동으로 관리하는 통합된 데이터 (Integrated Data)이다. (최소한의 중복만 허용) ③ DB는 컴퓨터가 접근할 수 있는 저장 매체(디스크 같은)에 저장된 데이터(Stored Data)이다. ④ DB는 조직의 운영에 꼭 필요한 데이터를 저장한 운영 데이터(Operational Data)이다. 24 학습 요약 및 정리 학습 요약 및 정리 2. 데이터베이스의 특징 ① 동시 공유(Concurrent Sharing) ② 지속적인 변화(Continuous Evolution) ③ 실시간 접근성(Real-Time Accessibility) ④ 내용에 의한 참조(Content Reference) ⑤ 데이터베이스 관리 시스템(Database Management System: DBMS)에 의한 관리 프린트 하기 다운로드 	1
0000	DB 개요 3. 데이터베이스의 개념적 구성 요소 1) 개체(Entity) - DB가 표현하려고 하는 유형  무형의 정보 대상으로  존재하면서 서로 구별될 수 있는 요소이며   파일 시스템에서 레코드에 대응하는 것으로  단독으로도 정보로서의 역할이 가능하며  하나 이상의 속성(Attribute)으로 구성된다.   속성은 개체의 특성을 나타내는 요소로  이름을 가진 정보의 가장 작은 논리적인 단위 이다. 2) 관계 (Relationship) - 일반적으로 개체들 간의 의미 있는 연결 또는 연관성을 의미하는 요소로서   관계도 하나의 개체로 간주될 수 있으며  일 대 일(1 : 1)  일 대 다(1 : n)   다 대 다(m : n)의 유형으로 구분된다.  25 학습 요약 및 정리 학습 요약 및 정리 	1
0000	2016-09-02 1 데이터베이스 데이터베이스 2 회차 : DBMS 개요 김 은 경 DBMS 개요 2 학습목표 학습에 앞서 학습목표 동기유발 & 학습목표 학습내용 1. DBMS 이해하기 학습목표 2. ANSI/SPARC  구조와 데이터 독립성 1. DBMS가 무엇이며  궁극적인 목적이 무엇인지 설명할 수 있다. 2. DBMS의 필수 기능을 나열할 수 있다.     1. ANSI/SPARC의 3 단계 DB 구조를 설명할 수 있다.  2. ANSI/SPARC 구조와 스키마의 관련성을 설명할 수 있다.  3. 데이터 독립성에 대해 설명할 수 있다.  	1
0000	2016-09-02 2 DBMS 개요 3 Lesson. DBMS 이해하기 1. DBMS란?  2. DBMS의 발전 배경 3. DBMS의 필수 기능과 장단점 4. DBMS의 역사 DBMS의 이해하기 DBMS 개요 4 DBMS란?  * 데이터 독립성 : 응용 프로그램 에 영향을 주지 않고 DB의 구조 를 변경할 수 있는 것 1. DBMS란?  (1) DBMS(Database Management System   데이터베이스 관리시스템)의 정의 - DBMS는 DB 관리자  DB 사용자  그리고 응용 프로그램과 DB 사이의 중재자로서  데이터베이스에 대한 모든 접근을 처리해주는 소프트웨어 시스템이다. - DBMS는 DB의 정의와 조작  제어 기능을 제공하며  여러 사용자와 응용 프로그램이 DB를 공용할 수 있도록 관리해 주는 소프트웨어 시스템이다. (2) DBMS의 궁극적인 목적 - 응용 프로그램이 데이터에 종속되지 않는 데이터 독립성(Data Independency)을 제공하는 것이 DBMS의 궁극적인 목적이다. - 즉  DB의 구조를 변경해도 응용 프로그램에 영향을 주지 않고  반대로 응용 프로그램을 변경해도 DB에 영향을 주지 않도록 하는 것이 목적이다. DBMS DB DB 관리자 DB 사용자 응용 프로그램 	1
0000	2016-09-02 3 DBMS 개요 5 2. DBMS의 발전 배경 (1)  사회적 요구 - 정보처리 시스템의 활용 분야가 점차 다양해지면서  대량의 공용 데이터를 기초로 효율적인 “데이터 검색”을 위주로 하는 데이터베이스 시스템에 대한 요구가 등장하였으며   이러한 요구는 사칙연산 등을 기본으로 하는 “데이터 처리” 위주의 파일 처리 시스템으로는 만족시킬 수 없으며  따라서 DB 구축 및 관리를 지원하는 다양한 DBMS가 등장하게 되었다. (2)  기술적 발전 ① 저렴한 고속 자기디스크(Magnetic Disk)의 실용화로  대량 정보 저장 및 빠른 검색 지원이 가능하다. ② 데이터 통신 기술의 발전으로 빠른 정보 전송이 가능하여  데이터의 동시 공유가 가능하다. DBMS의 발전 배경 DBMS가 발전하게 된 배경은 사회적인 요구와 이를 수용할 수 있는 기술적인 발전이 조화를 이루었기 때문이라고 할 수 있습니다.  DBMS 개요 6 [보충 학습]  파일 처리 시스템 (1)  파일 처리 시스템이란?  - 각각의 응용 프로그램이 자신의 데이터를 별도로 파일 형태로 관리하는  파일 중심의 데이터 처리 시스템을 의미한다.  (2)  파일 처리 시스템의 특징 - 응용 프로그램과 데이터 간에 상호 의존성이 있다. 즉  대부분의 경우 응용 프로그램과 데이터 파일이 1 : 1로 대응한다.   à 따라서  데이터 종속성(Data Dependency) 및 데이터 중복성(Redundancy)이 유발된다. [보충 학습] (1) 데이터 종속성 – 데이터 파일 의 구성 방법이나 접근 방법을 변경하면  관련 된 응용 프로그램도 변 경해야 하는 것 (2) 데이터 중복성 - 내용이 같 은 데이터가 한 시스템 내에 중복해서 저장  관 리되는 것 응용 프로그램 1 데이터 파일 1 응용 프로그램 2 데이터 파일 2 응용 프로그램 n 데이터 파일 n . . .  . . .  [파일 처리 시스템의 응용 프로그램과 데이터 파일의 일대일 관련성] 	1
0000	2016-09-02 4 DBMS 개요 7 (3) 파일 처리 시스템의 단점 ① 일관성(Consistency) 유지의 어려움 - 데이터의 중복으로 인해 데이터의 동일성 유지가 어렵다. - 중복된 데이터의 변경 시점에 따라 동일한 데이터의 값이 일치하지 않을 수 있다. ② 보안(Security) 유지의 어려움 - 데이터의 중복 관리로 인해 동일한 수준의 보안 유지가 어렵다. ③ 경제성 저하 - 중복된 저장 및 갱신 작업으로 인해 저장 공간 및 갱신 비용이 높아진다. ④ 데이터 무결성(Integrity) 유지의 어려움 - 중복 저장에 따른 관리 분산으로 데이터의 정확성 유지가 어렵다. ⑤ 동시 공용(Concurrent Sharing)의 어려움 - 드물게 하나의 데이터 파일을 여러 응용 프로그램이 공용한다 해도  한 프로그램이 데이터 파일을 사용하는 동안에는 다른 응용 프로그램이 그 데이터 파일에 접근할 수 없다. [보충 학습]  DBMS 개요 8 DBMS의 필수 기능과 장단점 3. DBMS의 필수 기능과 장단점 (1) DBMS의 필수 기능 ① 데이터 정의(Definition) 기능 - 다양한 응용 프로그램과 DB가 서로 인터페이스 할 수 있는 수단을 제공한다. - 하나의 저장된 DB를 기초로 여러 사용자와 응용 프로그램의 다양한 데이터 요구를 지원할 수 있도록 DB 구조를 정의하는 기능을 제공한다. ② 데이터 조작(Manipulation) 기능 - 사용자와 DB 간의 인터페이스를 위한 수단을 제공한다. - DB에 저장된 데이터의 검색  삽입  삭제  갱신 등과 같은 DB 연산을 처리하는 기능을 제공한다. ③ 데이터 제어(Control) 기능 - 공용으로 관리되는 DB의 내용을 정확하고 안전하게 유지할 수 있도록  다음과 같은 3가지 제어 기능을 제공한다. a) 데이터의 삽입  삭제 등 DB 변경 시에 데이터의 무결성 및 일관성 유지 기능 b) 권한이 부여된 사용자만이 허용된 데이터에 접근할 수 있도록 접근 권한 검사 기능 c) 여러 사용자가 DB에 동시에 접근할 수 있도록 동시성(Concurrency) 제어 기능 	1
0000	2016-09-02 5 DBMS 개요 9 DBMS의 필수 기능과 장단점 (2)  DBMS의 장점 ① 데이터의 동시 공유가 가능하다. - DBMS의 동시성 제어 (Concurrency  Control) 기능 때문에 동일한 데이터를 여러 응용 프로그램이 동시에 사용할 수 있다. 동일한 데이터를 여러 프로그램이 동시에 검색할 수는 있지만   삭제 또는 갱신은 한 프로그램만 하도록 제어하는 것 ② 데이터 중복이 최소화된다.  - 검색의 효율성을 위해서 불가피한 최소한의 중복(Minimal Redundancy)을 허용하므로   파일 처리 시스템과 비교하면 중복이 최소화된다.  ③ 데이터의 무결성 유지가 용이하다.  - DBMS의 유효성 검사 기능 때문에 DB에 허용되지 않는 값이나 부정확한 값이 삽입되지 않게 되므로 데이터의 정확성을 유지할 수 있다.  ④ 데이터의 일관성 유지가 용이하다. - DBMS가 데이터의 중복을 제어하기 때문에 데이터들 간의 불일치성이 발생하지 않는다. [관련 학습] 최소한의 중복이란? - 1회차. 2. 데이터베이스란? -> DBMS 개요 10 DBMS의 필수 기능과 장단점 ⑤ 프로그램과 데이터 간의 독립성을 유지할 수 있다. - 데이터와 응용 프로그램이 분리됨으로써  데이터의 구조 변경으로 인해 응용 프로그램을 수정해야 하는 경우가 많지 않다.  ⑥ 데이터의 보안이 보장된다. - DB가 중앙집중식으로 관리되고  DBMS의 DB 접근 권한 통제 기능으로 인해  데이터에 대한 접근이 효율적으로 통제될 수 있다.  ⑦ 데이터의 표준화 달성이 가능하다. - 범 기관적으로 데이터의 형식이나 내용  문서화 양식 등과 관련해서 표준화 시행이 용이하다.  사용자에게 DB 접근 권한 또는 테이블 접근 권한 등을 부여할 수 있음 	1
0000	2016-09-02 6 DBMS 개요 11 DBMS의 필수 기능과 장단점 (3) DBMS의 단점 ① 운영비가 증가한다.  - DBMS 및 추가적인 하드웨어 구입 비용과 별도의 신규 채용 또는 기존 직원 교육비 등 많은 운영비가 요구된다.  ② 데이터 처리가 복잡하다.  - DB는 한 조직의 다양한 응용 프로그램을 고려해서 구축  관리되므로 단일 응용 프로그램만을 위한 데이터 파일보다는 데이터 처리가 복잡할 수 있다.  ③ 백업(Backup)과 복구(Recovery)가 복잡하다.   - 여러 사용자가 공용하므로 장애 발생 시 정확한 원인을 파악하기 어려우므로   미리 백업 및 복구 계획을 아주 정교하게 수립해야 한다.  ④ 시스템이 장애에 취약하다.      - 데이터가 한 곳에 통합되어 있으므로 일부의 장애가 시스템 전체에 영향을 미칠 수 있으며  데이터가 중앙집중적으로 관리되므로 해킹을 당하는 경우 피해가 더 심각할 수 있다. DBMS 개요 12 DBMS의 필수 기능과 장단점 4. DBMS의 역사 (1)  제 1 세대 DBMS - 60년대 초반부터 70년대 중반까지 네트워크 데이터 모델과 계층 데이터 모델을 기반으로 한 DBMS가 해당된다.  ① IDS(Integrated Data Store) - 최초의 범용 DBMS  - 1960년대 초 GE(General Electric)사의 찰스 바흐만(Charles Bachman)이 설계함 - 네트워크 데이터 모델(Network Data Model)의 시초 ② IMS(Information Management System) DBMS - 1960년대 후반 IBM이 개발한 것으로  현재도 사용되고 있음 - 계층 데이터 모델(Hierarchical Data Model)의 시초 ③ 1970년대 초에는 많은 대형 컴퓨터 회사들이 네트워크 데이터 모델과 계층 데이터 모델을 기반으로 DBMS를 자체 제작하여 판매하기 시작함 	1
0000	2016-09-02 7 DBMS 개요 13 DBMS의 필수 기능과 장단점 (2)  제 2 세대 DBMS - 70년대 후반에 등장해서 80년대 주류가 된  관계 데이터 모델(Relational Data Model)을 기반으로 한 DBMS가 해당된다.  ① 관계 데이터 모델(Relational Data Model) - IBM 산호세 연구소의 코드(E. F. Codd) 박사가 제안한 모델 - 관계 DB(Relational Database) 이론의 기초가 됨 - 1980년대 DBMS의 주류가 되어 계속 확장됨 ② SQL(Structure Query Language) - IBM이 관계 DBMS의 일부로 개발한 DB 언어 - 세계 표준 데이터베이스 언어가 됨 ③ PC 기반의 DBMS 등장 - Access  FoxPro  dBase  Paradox  SQL Server 등 ④ 주요 상용 DBMS 등장 - DB2  Oracle  Ingres  Sybase  Informix 등 DBMS 개요 14 DBMS의 필수 기능과 장단점 (3)  제 3 세대 DBMS - 80년대 후반부터 새롭게 출현한 객체 DBMS나 객체-관계 DBMS 가 해당된다. ① 사용자의 DB 응용에 대한 복잡성(complexity)이 증대됨 - 이미지 및 동영상 처리 및 관리  공간 및 시간 계열(Spatial & Time Series) 데이터 처리   데이터 마이닝(Data Mining) 등 ② 사용자의 요구에 대처하기 위해 새로운 데이터 모델을 기반으로 하는 DBMS 출현 - 객체 DBMS(ODBMS: Object DBMS) : O2  ObjectStore  GemStone 등 - 객체-관계 DBMS(ORDBMS: Object-Relational DBMS) : 오라클(Oracle) 8.X(1997년) 이후 버전  UniSQL  Illustra 등 ü 현재는 제 2 세대 DBMS와 제 3 세대 DBMS가 공존하고 있으며  4세대 기술이 개발 중임 	1
0000	2016-09-02 8 DBMS 개요 15 Lesson. ANSI/SPARC 구조와 데이터 독립성 1. ANSI/SPARC 구조 이해 2. ANSI/SPARC 3 단계 구조의 구성 3. ANSI/SPARC 구조와 스키마 4. 데이터 독립성 ANSI/SPARC 구조와 데이터 독립성 DBMS 개요 16 1. ANSI/SPARC 구조 이해 ANSI/SPARC 구조 이해 (1) ANSI/SPARC란? - ANSI/SPARC(American National Standards Institute  Standards Planning And Requirements Committee)는 미국의 컴퓨터 및 정보처리에 관한 표준화 위원회이다.  (2) ANSI/SPARC 구조(Architecture)란? - DBMS의 구현을 위한 추상적인 설계 표준으로서  DB에 대한 여러 사용자의 관점과 DB가 실제로 표현되는 방식(즉  물리적 관점)을 분리시킬 수 있도록  DB 구조를 크게 외부 단계  개념 단계   내부 단계라는 3개 단계로 구분한 구조이다.  - 1978년 ANSI/SPARC에서 처음 제안했기 때문에 ANSI/SPARC 구조라 칭하며   그냥 “3 단계(또는 3 계층) DB 구조(3-level DB Architecture)“ 라고도 칭한다.  - 현재 대부분의 상용 DBMS는 1978년에 제안된 ANSI/SPARC 구조를 기반으로 하고 있다.  	1
0000	2016-09-02 9 DBMS 개요 17 ANSI/SPARC 구조 이해 ANSI(엔씨)/SPARC(스파크)의 3(삼) 단계 DB(디비) 구조에 대해서는 뒤에서 차근차근 설명하도록 하겠습니다.  사용자 관점 1 사용자 관점 2 사용자 관점 3 사용자 관점 n . . .  외부 단계 개념 단계 사용자 공동체의 관점 저장 장치 관점 저장 DB 내부 단계 [ ANSI/SPARC 3 단계 구조(Three-level Architecture) ] 물리 단계 외부/개념 사상 (응용 인터페이스) 개념/내부 사상 (저장 인터페이스) 외부 스키마 개념 스키마 내부 스키마 물리 단계(Physical level)는 DBMS의 지시에 따라 운영체제가 관리하 므로 DB 구조에는 포함시키지 않았음. 물리적 단계는 디스크와 같은 저장장치에 데이터를 실제로 저장하는 기법을 다루게 됨 DBMS 개요 18 ANSI/SPARC 구조 이해 (3) ANSI/SPARC 구조의 주요 목적 - DB 구조를 3 단계로 구분한 주요 목적은 DB에 대한 다양한 사용자의 관점과 DB가 실제로 표현되는 방식(즉  물리적 관점)을 분리시키는 것이다.  à 이런 구분을 통해서 응용 프로그램과 데이터 간의 독립성을 제공할 수 있다.  à 즉  사용자는 DB의 내부 구조에 대해 알지 못해도 DB를 사용할 수 있고   DB 관리자는 응용 프로그램에 영향을 주지 않고 DB 구조를 변경할 수 있다.   	1
0000	2016-09-02 10 DBMS 개요 19 2. ANSI/SPARC 3 단계 구조의 구성 (1) 외부 단계(External level) - DB에 관한 개별 사용자의 관점(View)으로서  각 사용자나 응용 프로그래머가 생각하는 개인적 DB 구조를 의미한다. - 예: 은행 DB에 접근하는 개인 고객이나 창구의 직원  신용카드 회사 직원은 각자 전체 DB의 일부분에만 관심이 있으며  각자 생각하는 DB 구조가 다를 수 있다. - 외부 단계에서 다양한 개별 사용자나 응용 프로그램이 필요로 하는 데이터 구조를 정의한 것을 외부 스키마(External Schema)라고 하며  외부 스키마는 여러 개 존재할 수 있다. (2) 개념 단계(Conceptual level) - DB에 관한 사용자 공동체의 관점  즉 한 조직 전체를 위한 DB의 논리적 구조를 의미한다. - 개념 단계에서 범 기관적 입장에서 전체 DB를 정의한 것을 개념 스키마(Conceptual Schema)라고 하며  개념 스키마는 단 하나만 존재한다. ANSI/SPARC 3 단계 구조의 구성 * 스키마(Schema) – DB 구조 (Structure)와 제약조건 (Constraints)을 기술한 것 - 확인 버튼 클릭하면  다음 페이지의 그림 표시 확인 DBMS 개요 20 ANSI/SPARC 3 단계 구조의 구성 은행고객  은행창구 직원  신용 카드 회사직원의 모습을 각기 다르게 표현해 주세요! 자신의 개인 정보  은행 잔고  입출금 내역  … 은행 고객 모든 고객의 잔고 및 입출금 내역  예금 상품 정보  …  은행창구 직원 모든 고객의 신용 정보 및 카드 사용 내용  카드 발급 기준  …   신용카드 회사직원 은행 DB [ 외부 단계에서 각 사용자가 생각하는 DB의 구조 ] [외부 단계 예제 확인]  	1
0000	2016-09-02 11 DBMS 개요 21 (3) 내부 단계(Internal level) - DB에 관한 물리적 저장 장치 관점  즉 DB에 어떤 데이터가 어떻게 저장되는지를 표현하는 저장 구조를 의미한다. - 실제로 저장된 내부 레코드의 형식  인덱스(Index) 유무  저장 데이터 항목의 표현 방법 등을 포함한다. - 내부 단계에서 DB의 물리적 데이터 구조를 정의한 것을 내부 스키마(Internal Schema)라고 하며  내부 스키마도 단 하나만 존재한다.  ü 내부 단계에서 특정 물리적 저장 장치를 직접 다루지는 않으며  실제로 물리 단계 보다 한 단계 위에 있다.   ü 물리 단계(Physical level)는 DBMS의 지시에 따라 운영체제가 관리한다.  ANSI/SPARC 3 단계 구조의 구성 DBMS 개요 22 (4) 외부/개념 사상(External/Conceptual Mapping) - 외부 스키마와 개념 스키마 간의 대응 관계를 정의한 것으로    응용 인터페이스(Application Interface)라고도 칭한다.  - 개념 스키마가 변경되어도 응용 인터페이스만 수정해 주면  외부 스키마에 아무런 영향을 미치지 않게 된다. 즉  응용 프로그램을 변경할 필요가 없다.  (5) 개념/내부 사상 (Conceptual/Internal Mapping) - 개념 스키마와 내부 스키마 간의 대응 관계를 정의한 것으로   저장 인터페이스(Storage Interface)라고도 칭한다. - 부득이 내부 스키마가 변경되어도 저장 인터페이스만 수정해 주면  개념 스키마에 아무런 영향을 미치지 않게 된다.  ANSI/SPARC 3 단계 구조의 구성 	1
0000	2016-09-02 12 DBMS 개요 23 3. ANSI/SPARC 구조와 스키마 (1) 스키마(Schema)란? - DB의 구조(Structure) 즉  개체와 속성  관계를 포함하는 논리적 정의와 제약조건(Constraints)을 기술한 것을 의미한다.  (2) ANSI/SPARC 3단계 구조와 스키마 구분 ANSI/SPARC 구조와 스키마 단계 스키마 구분 스키마 특징 외부 단계 외부 스키마 (External Schema)  - 사용자 개개인의 관점에서 정의한 DB 스키마 - 여러 개 존재함 - 서브스키마(Subschema)라고도 칭함 개념 단계 개념 스키마 (Conceptual Schema)  - 범 기관적인 관점에서 정의한 DB 스키마 - 모든 외부 스키마가 요구하는 전체적인 DB  구조와 제약조건을 포함함 - 단 하나만 존재함 - 그냥 스키마(Schema)라고도 칭함 내부 단계 내부 스키마 (Internal Schema) - 저장 장치 관점에서 정의한 DB 스키마 - 개념 스키마에 대한 저장구조를 정의한 것 - 단 하나만 존재함 DBMS 개요 24 (3)  스키마 작성 사례 ANSI/SPARC 구조와 스키마 STD 학번 integer(8) 이름 char(10) 학과 char(12)    지도교수 integer(8) 학생 학번 NUMBER(8)  이름 VARCHAR(20) 학과 VARCHAR(12)    학년 VARCHAR(1)   지도교수 NUMBER(8)  주소 VARCHAR(30) 성적 NUMBER(5)  STUDENT 학번 INT 성명 CHAR(10)  소속 CHAR(12) 학점 FLOAT      교무처에서 본 학생 개체의 외부 스키마 2 STORED_STUDENT             LENGTH = 88  prefix              BYTE(4)         OFFSET = 0 ID                   BYTE(8)         OFFSET = 4         INDEX = STDINDX Name              BYTE(20)       OFFSET = 12 Dept BYTE(12)       OFFSET = 32  Year                BYTE(1)         OFFSET = 44  Advisor            BYTE(8)         OFFSET = 45 Address           BYTE(30)         OFFSET = 53  Grade             BYTE(5)       OFFSET = 83 학생 개체의 개념 스키마 학생 개체의 내부 스키마 학생처에서 본 학생 개체의 외부 스키마 1 	1
0000	2016-09-02 13 DBMS 개요 25 4. 데이터 독립성 데이터 독립성 (1) 데이터 독립성(Data Independency)이란?  - 응용 프로그램과 데이터가 서로 종속되지 않는 것  즉 서로 영향을 미치지 않도록 하는 것을 의미한다.  - 즉  DB의 논리적 구조나 물리적 구조가 변경되어도 응용 프로그램에 영향을 주지 않는 것을 의미하며   논리적 데이터 독립성과 물리적 데이터 독립성으로 구분할 수 있다.   (2) 논리적 데이터 독립성(Logical Data Independency)  - 응용 프로그램에 영향을 주지 않고 DB의 논리적 구조(개념 스키마)를 변경할 수 있는 것을 의미한다.  - 즉  DB에 새로운 데이터 항목이나 레코드를 추가해도  현재 정의된 사용자 관점이나 사용되고 있는 응용 프로그램 가운데 직접 관련되지 않는 사용자 관점과 응용 프로그램은 영향을 전혀 받지 않는 것을 의미한다.  ü 어떻게 논리적 데이터 독립성이 보장되나? - 외부/개념 사상에 의해서 논리적 데이터 독립성이 보장된다.  - 즉  DBMS가 DB에 대한 하나의 논리적 데이터 구조를 기초로 여러 응용 프로그램이 요구하는 다양한 형태의 데이터 구조로 대응시킬 수 있기 때문이다.  DBMS 개요 26 데이터 독립성 (3)  물리적 데이터 독립성(Physical Data Independency)  - 응용 프로그램이나 DB의 논리적 구조에 영향을 주지 않고 DB의 물리적 구조(파일 편성  데이터 접근 방법 등)를 변경할 수 있는 것을 의미한다.  - 즉  새로운 저장 장치나 접근 방법의 개발로 인해 성능을 개선하기 위해 DB의 물리적 구조를 변경하게 되더라도  DB의 논리적 구조나 DB를 사용하는 응용 프로그램이 영향을 받지 않는 것을 의미한다.  ü 어떻게 물리적 데이터 독립성이 보장되나? - 개념/내부 사상에 의해서 물리적 데이터 독립성이 보장된다.  - 즉  DBMS가 DB에 대한 하나의 논리적 데이터 구조를 상이한 여러 가지 물리적 구조와 대응시킬 수 있기 때문이다.  	1
0000	2016-09-02 14 DBMS 개요 27 데이터 독립성 이 그림에서 내부 단계에 저장 DB(디비)가 두 개로 표시된 것은 변경 전후의 DB(디비)를 표현한 것으로  내부 단계에서 DB(디비)의 물리적인 데이터 구조를 정의한 내부 스키마는 단 하나만 존재할 수 있습니다.   응용 프로그램 1 응용 프로그램 2 응용 프로그램 n A B C D D E F A F D 논리적 구조 사상 물리적 구조 사상 A B C D E F G H A B C D E F G H ... 응용 프로그램의 데이터 구조 DB의 논리적 구조 DB의 물리적 구조 ...... ...... ... 외부 단계 개념 단계 내부 단계 A D G B E H C F ... [ANSI/SPARC 각 단계 간의 사상(Mapping) ] 외부/개념 사상 (응용 인터페이스) 개념/내부 사상 (저장 인터페이스) [변경전 저장 DB] [변경후 저장 DB] 논리적 데이터 독립성 보장 물리적 데이터 독립성 보장 DBMS 개요 1. DBMS의 정의와 궁극적인 목적 1) DBMS의 정의 - DB 관리자와 DB 사용자 및 응용 프로그램과 DB 사이의 중재자로서  데이터베이스에 대한 모든 접근을 처리해주는 소프트웨어 시스템이다. - DB의 정의와 조작  제어 기능을 제공하며  여러 사용자와 응용 프로그램이 DB를 공용할 수 있도록 관리해 주는 소프트웨어 시스템이다. 2) DBMS의 궁극적인 목적 - 응용 프로그램이 데이터에 종속되지 않는 데이터 독립성(Data Independency)을 제공하는 것이다. - 즉  DB의 구조를 변경해도 응용 프로그램에 영향을 주지 않고  반대로 응용 프로그램을 변경해도 DB에 영향을 주지 않도록 하는 것이 목적이다. 28 학습 요약 및 정리 학습 요약 및 정리 	1
0000	2016-09-02 15 DBMS 개요 29 학습 요약 및 정리 학습 요약 및 정리 2. DBMS의 필수 기능 ① 데이터 정의(Definition) 기능 - 다양한 응용 프로그램과 DB가 서로 인터페이스 할 수 있는 수단을 제공한다. - 하나의 저장된 DB를 기초로 여러 사용자와 응용 프로그램의 다양한 데이터 요구를 지원할 수 있도록 DB 구조를 정의하는 기능을 제공한다. ② 데이터 조작(Manipulation) 기능 - 사용자와 DB 간의 인터페이스를 위한 수단을 제공한다. - DB에 저장된 데이터의 검색  삽입  삭제  갱신 등과 같은 DB 연산을 처리하는 기능을 제공한 다. ③ 데이터 제어(Control) 기능 - 공용으로 관리되는 DB의 내용을 정확하고 안전하게 유지할 수 있도록  다음 3가지 제어 기능 을 제공한다. a) 데이터의 삽입  삭제 등 DB 변경 시에 데이터의 무결성 및 일관성 유지 기능 b) 권한이 부여된 사용자만 허용된 데이터에 접근할 수 있도록 접근 권한 검사 기능 c) 여러 사용자가 DB에 동시에 접근할 수 있도록 동시성(Concurrency) 제어 기능 DBMS 개요 3. ANSI/SPARC의 3단계 Three-level Architecture) DB 구조 - DBMS의 구현을 위한 추상적인 설계 표준으로서  DB에 대한 여러 사용자의 관점과 DB가 실제로 표현되는 방식(즉  물리적 관점)을 분리시킬 수 있도록  DB 구조를 크게 외부 단계  개념 단계   내부 단계라는 3개 단계로 구분한 구조이다.  30 학습 요약 및 정리 학습 요약 및 정리 사용자 관점 1 사용자 관점 2 사용자 관점 3 사용자 관점 n . . .  외부 단계 개념 단계 사용자 공동체의 관점 저장 장치 관점 저장 DB 내부 단계 [ ANSI/SPARC 3 단계 구조] 외부/개념 사상 (응용 인터페이스) 개념/내부 사상 (저장 인터페이스) 외부 스키마 개념 스키마 내부 스키마 	1
0000	2016-09-02 16 DBMS 개요 4. ANSI/SPARC의 3단계 DB 구조와 스키마의 관련성 31 학습 요약 및 정리 학습 요약 및 정리 단계 스키마 구분 스키마 특징 외부 단계 외부 스키마 (External Schema)  - 사용자 개개인의 관점에서 정의한 DB 스키마 - 여러 개 존재함 - 서브스키마(Subschema)라고도 칭함 개념 단계 개념 스키마 (Conceptual Schema)  - 범 기관적인 관점에서 정의한 DB 스키마 - 모든 외부 스키마가 요구하는 전체적인 DB  구조와 제약조건을 포함함 - 단 하나만 존재함 - 그냥 스키마(Schema)라고도 칭함 내부 단계 내부 스키마 (Internal Schema) - 저장 장치 관점에서 정의한 DB 스키마 - 개념 스키마에 대한 저장구조를 정의한 것 - 단 하나만 존재함 DBMS 개요 5. 데이터 독립성 1) 데이터 독립성(Data Independency)이란?  - 응용 프로그램이 데이터에 종속되지 않는 것을 의미한다.  - 즉  DB의 논리적 구조나 물리적 구조가 변경되어도 응용 프로그램에 영향을 주지 않는 것을 의미하며   논리적 데이터 독립성과 물리적 데이터 독립성으로 구분할 수 있다.  2) 논리적 데이터 독립성(Logical Data Independency)  - 응용 프로그램에 영향을 주지 않고 DB의 논리적 구조(개념 스키마)를 변경할 수 있는 것을 의미한다.  - 외부/개념 단계 간의 사상에 의해 보장된다.  3) 물리적 데이터 독립성(Physical Data Independency)  - 응용 프로그램이나 DB의 논리적 구조에 영향을 주지 않고 DB의 물리적 구조(파일 편성  데이터 접근 방법 등)를 변경할 수 있는 것을 의미한다.  - 개념/내부 단계 간의 사상에 의해 보장된다.  32 학습 요약 및 정리 학습 요약 및 정리 	1
0000	2016-09-02 17 DBMS 개요 33 쉼터 쉼터 나를 나타내주는 것은 나의 말이 아니라 나의 행동이다. 나를 나타내주는 것은 나의 말이 아니라 나의 행동이다. 	1
0000	데이터베이스 데이터베이스 3 회차 : DB 시스템 개요 김 은 경 	1
0000	DB 시스템 개요 2 학습목표 학습에 앞서 학습목표 동기유발 & 학습목표 학습내용 1. DB 시스템의 구성과 데이터 언어 학습목표 2. DBMS의 구성 1. DB 시스템의 구성 요소를 나열할 수 있다. 2. 데이터 언어의 종류를 나열할 수 있다.     3. DB 관리자의 주요 역할을 나열할 수 있다.  1. DBMS의 기능적 구성 요소를 나열할 수 있다.  2. DBMS의 구성 요소 각각의 역할을 설명할 수 있다.  	1
0000	DB 시스템 개요 3 Lesson.  DB 시스템의 구성과 데이터 언어 1. DB 시스템이란?  2. 데이터 언어 3. DB 관리자와 사용자 4. DB 컴퓨터 DB 시스템과 데이터 언어 	1
0000	DB 시스템 개요 4 DB 시스템이란?  1. DB 시스템이란?  (1) DB 시스템(DataBase System: DBS)의 정의 - “DB 시스템은 데이터를 DB에 저장하고  DBMS를 사용해서 필요한 정보를 생성하는 컴퓨터 중심의 시스템이다.” (2) DB 시스템의 구성 요소 No. 구성 요소 역할 1 데이터베이스(DB)  데이터를 저장한다.  2 데이터베이스 관리시스템 (DBMS) DB를 생성  관리  조작함으로써 사용자와 DB를 연결해 주는 소프트웨어이다. 3 데이터 언어 (Data Language)  DB 정의와 조작  제어를 위한 DB 전용 언어이다.  4 DB 사용자 데이터 언어를 사용해서 DB에 접근하는 사람으로  일 반 사용자와 응용 프로그래머  DB 관리자로 구분할 수 있다.  5 DB 컴퓨터 효율적인 DB 관리를 위해서 DB에 대한 연산을 전담하 는 DB 관리 전용 컴퓨터이다.  	1
0000	DB 시스템 개요 5 2. 데이터 언어 (1)  데이터 언어(Data Language)란?  - DB를 정의하고  조작  제어하기 위해서 사용하는 언어이다.      - 즉  사용자가 데이터에 접근하는 수단으로서  사용자와 DBMS 간의 통신 수단을 제공하는 것이다.  (2)  데이터 언어의 종류 ① 데이터 정의어(DDL: Data Definition Language) ② 데이터 조작어(DML: Data Manipulation Language) ③ 데이터 제어어(DCL: Data Control Language) (3)  데이터 언어의 완전성(Completeness of data language)이란?  - 데이터 언어가 반드시 갖추어야 할 필수 요건으로서  사용자가 원하는 어떤 데이터도 검색하고 처리할 수 있으며  어떤 연산도 표현할 수 있는 능력을 의미한다.  데이터 언어 	1
0000	DB 시스템 개요 6 (3)  데이터 정의어 1) 데이터 정의어(DDL: Data Definition Language)란? - DB 구조를 정의하거나 변경하기 위해서 사용하는 언어로서   DB 설계자 또는 DB 관리자가 DB 스키마를 정의하기 위해 사용한다. 2) 데이터 정의에 포함되는 내용 ① 논리적 데이터 구조의 정의 - 개념 스키마(스키마)와 외부 스키마(서브스키마) 명세 ② 물리적 데이터 구조의 정의 - 내부 스키마 명세 - 별도의 데이터 저장 정의어(Data Storage Definition Language: DSDL)를 사용해서 명세하는 경우도 있음 ③ 논리적 데이터 구조와 물리적 데이터 구조 간의 사상(Mapping) 정의 3) 데이터 정의의 저장 - DDL로 정의된 DB 스키마는 DBMS의 구성 요소 가운데 하나인 DDL 컴파일러가 컴파일해서 시스템 카탈로그(System Catalog) 또는 데이터 디렉토리(Data Dictionary)에 저장에 두고 필요할 때 참조한다.  데이터 언어 * 시스템 카탈로그(System Catalog) – DB에 포함된 모든 객체들에 대한 정의(Definition) 나 명세(Specification)에 대한 정보가 수록되어 있는 시스템 테이블로  데이터 사전 (Data Dictionary) 이라고도 칭한다. * 데이터 디렉토리(Data Directory) - DB에 저장된 데 이터를 참조하는데 필요한 정보 가 수록된 시스템 테이블이다. 심화 학습 #1 심화 학습 #2 	1
0000	DB 시스템 개요 7 [심화 학습 #1] 시스템 카탈로그와 데이터 디렉토리 (1) 시스템 카탈로그(System Catalog) - DB에 포함된 모든 객체들에 대한 정의(Definition)나 명세(Specification)에 대한 정보를 수록하는 시스템 테이블이다.  - 시스템 DB 또는 메타 데이터(Metadata)라고도 칭한다.  - DB 관리자가 주로 사용하는 도구로서  사용자와 시스템 모두 사용 가능하다.  - 데이터 사전(Data Dictionary)이라고도 칭한다.  (2)  데이터 디렉토리(Data Directory) - DB에 저장된 데이터를 참조(Reference)하는데 필요한 정보를 수록하는 시스템 테이블이다.  - 시스템만 사용할 수 있다.  [심화 학습]  	1
0000	DB 시스템 개요 8 [심화 학습 #2] 데이터 정의어의 상세 구분 ① DB를 ANSI/SPARC의 3단계로 엄격히 구분하는 시스템의 경우 - 외부 스키마 정의어와 개념 스키마 정의어  내부 스키마 정의어를 각각 제공해야 한다.  ② DB를 ANSI/SPARC의 3단계로 엄격히 구분하지 않는 시스템의 경우 - DDL을 외부 스키마와 개념 스키마를 정의(개체와 속성  관계  제약조건 및 스키마 간의 사상(Mapping) 등 포함)할 때 모두 사용한다.  ③ 개념 스키마와 내부 스키마를 분명히 구분하는 경우 - 내부 스키마 정의를 위해 별도의 데이터 저장 정의어(DSDL: Data Storage Definition Language) 를 사용한다.  ④ 외부 스키마와 개념 스키마를 분명히 구분하는 경우 - 외부 스키마를 정의할 때 대개 약간 확장된 DDL을 사용한다.  - 외부 스키마 대신 서브스키마(Subschema)라는 용어를 사용하는 시스템의 경우   스키마 DDL과 서브스키마 DDL로 구분한다.  - 외부 스키마는 응용 프로그램 안에 DDL 명령문으로 정의되는 경우가 많다.  [심화 학습]  	1
0000	DB 시스템 개요 9 (4) 데이터 조작어 1) 데이터 조작어(DML: Data Manipulation Language)란? - DB 사용자(응용 프로그램 포함)와 DBMS 사이의 통신 수단으로서   데이터 검색과 삽입  삭제  갱신과 같은 DB 연산을 처리한다.    2) 데이터 조작어의 종류 ① 절차적 DML ② 비절차적 DML 3) 절차적 DML이란? - 사용자가 무슨(What) 데이터를 어떻게(How) 접근해서 처리해야 하는지 기술해야 하는 저수준(Low level) 데이터 언어이다.  - 한번에 하나의 레코드(One record at a time)만 검색해서 호스트 언어로 전달해서 처리되는 특성이 있다.   따라서  독자적으로 사용하지 못하고  응용 프로그램 속에 삽입(embedded)되어 사용됨 - 호스트 언어로 작성된 응용 프로그램 안에 프로시저(Procedure) 호출문 형식으로 표현되며   DML 예비 컴파일러(Pre-compiler)에 의해서 별도로 컴파일 된다.  데이터 언어 	1
0000	DB 시스템 개요 10 4) 비절차적 DML이란? - 사용자가 무슨(What) 데이터를 원하는 지만 기술하고  어떻게(How) 접근해서 처리해야 하는지는 기술하지 않고 DBMS에게 위임하는 고급(High level) 데이터 언어이다.  - 한번에 여러 개의 레코드(Set of records at a time)를 처리할 수 있다.  - 단말기에서 일반 사용자가 대화식으로 사용할 수도 있고  응용 프로그램 속에 삽입해서 사용할 수도 있다.  - 독자적이고 대화식으로 사용하는 고급 명령어 형태의 데이터 조작어를 질의어(Query Language)라고 칭한다.   데이터 부속어(DSL  Data Sublanguage)  - 절차적이든 비절차적이든  호스트 프로그램 속에 삽입해서 사용하는 DML 명령어를 지칭한다.  데이터 언어 	1
0000	DB 시스템 개요 11 (5) 데이터 제어어 1) 데이터 제어어(DCL: Data Control Language)란? - 공용 DB의 관리를 위해서 데이터 제어를 정의하고 기술하는 언어로서    DB 관리를 목적으로 주로 DB  관리자가 사용한다.  2) 데이터 제어의 기능 ① 데이터 보안(Security) ② 데이터 무결성(Integrity) ③ 데이터 복구(Recovery) ④ 병행 수행 제어(Concurrency Control) [주의]  - 데이터 언어가 개념적으로는 DDL  DML  DCL로 구분되지만  현실적으로는 별도의 언어로 존재하는 것이 아니라  하나의 언어 안에 포함된 다른 명령어로서 기능적으로만 구분되는 것이 일반적이다.  데이터 언어 	1
0000	DB 시스템 개요 12 DB 사용자 * 질의어(Query Language) – 독 자적이고 대화식으로 사용하는 고급 명령어 형태의 독립된 데이 터 조작어이다.  * 호스트(Host) 언어 – 응용 프로 그램을 작성할 때 사용되는 범용 프로그래밍 언어이다.   3. DB 사용자 (1)  일반 사용자 - 대개 질의어(Query Language)를 사용해서 DB에 접근하는 사람으로  터미널 사용자(Terminal User) 또는 최종 사용자(End User)라고도 칭한다.  - DB에 대한 특별한 지식 없이  주로 데이터 검색 및 삽입  삭제  갱신을 목적으로 DB에 접근한다.  (2) 응용 프로그래머(Application Programmer) - 일반 사용자들이 보다 쉽게 DB에 접근할 수 있도록  업무 중심의 응용 프로그램을 개발하는데 참여하는 시스템 분석가나 프로그래머 등의 정보기술 전문가를 의미한다.  - C  Java 등과 같은 호스트(Host) 언어와 DML에 익숙하며  DB에 대한 기초 지식을 갖춘 프로그래밍 전문가들이다.  	1
0000	DB 시스템 개요 13 DB 사용자 (3)  DB 관리자(DBA: DB Administrator)  1) DB 관리자란? - DB 시스템이 기능을 원활히 수행할 수 있도록 관리를 책임지는 사람이다.  - 즉  DB 시스템을 총체적으로 감시하고 관리하는 책임과 권한을 갖고 있는 사람으로서  DB를 설계 및 구축하고  필요한 경우 DB의 변경 계획도 수립하는 역할을 한다.  2) DB 관리자의 주요 역할 ① DB 시스템 감시(Monitoring) 및 성능 분석 ② DB의 구성 요소 결정 및 스키마 정의 ③ DB의 저장 구조와 접근 방법 결정 ④ 보안 및 권한 부여 정책  데이터의 유효성 검사 방법 수립 ⑤ 백업(Backup) 및 복구(Recovery) 절차 수립 ⑥ DB의 무결성 유지를 위한 대책 수립 ⑦ DB 시스템의 성능 향상 및 새로운 요구에 대응한 DB 재구성 ⑧ 시스템 카탈로그의 관리 ⑨ 데이터 표현 및 시스템 문서화에 대한 표준 설정 ⑩ 사용자의 요구 및 불만 해소 등 	1
0000	DB 시스템 개요 14 DB 컴퓨터 * 펌웨어(Firmware) – 변경할 필 요가 없는 소프트웨어를 ROM 등에 고정시켜서 하드 웨어처럼 사용하는 것이다.   4. DB 컴퓨터 (1)  DB 컴퓨터란?    - 대규모 DB(VLDB: Very Large DataBase)를 보다 효율적으로 관리하기 위한 DB 관리 전용 컴퓨터로서   DB 머신(Machine)이라고도 칭한다.  (2) DB 컴퓨터의 특징 - 호스트 컴퓨터 후위에서 DB 관리 및 연산 수행 기능을 전담하는 특수 목적의 컴퓨터로서   일종의 후위 컴퓨터(Backend computer)이다.  - DB 관리 기능을 소프트웨어만으로 처리하는 것이 아니라  펌웨어(Firmware)나 하드웨어로 수행 하기 때문에 저비용으로 고성능을 달성할 수 있다.  - 후위 처리기(Backend processor)  고성능의 메인 메모리와 CPU  대용량 저장장치  병렬 처리 및 DB 연산 수행을 위한 특수 처리기 등으로 구성된다.   DB의 규모가 그리 크지 않는 경우에는 별도로 DB 컴퓨터를 사용하지 않을 때가 많다.  	1
0000	DB 시스템 개요 15 DB 컴퓨터 호스트 컴퓨터 DB 컴퓨터 인터페이스 일반 작업 처리기 DB 후위 처리기 특수 처리기 메모리 저장 DB 질의어 DML/ 응용프로그램 DML/ 응용프로그램 사용자 1 사용자 2 사용자 n … DB 컴퓨터 (후위 컴퓨터) [ DB 컴퓨터와 호스트 컴퓨터의 관계]  	1
0000	DB 시스템 개요 16 DB 컴퓨터 (3)  DB 컴퓨터의 주요 역할 ① DB 연산 기능 - 호스트 컴퓨터가 일반 사용자나 응용 프로그램으로부터 DB 접근 요청을 받아서 DB 컴퓨터로 전달하면  실제로 DB 컴퓨터가 데이터 검색 또는 삽입  삭제  갱신 등의 연산을 수행한다.  ② DB 관리 기능 - 데이터 접근 권한 확인  병행 수행 제어  데이터 복구  최적의 접근 경로 선정 등을 포함하는 데이터 관리 기능을 직접 수행한다.  	1
0000	DB 시스템 개요 17 Lesson.   DBMS의 구성 1. DBMS의 DB  연산 처리 방법 2. DBMS의 구성 요소 DBMS의 구성 	1
0000	DB 시스템 개요 18 1. DBMS의 DB  연산 처리 방법 DBMS의 DB  연산 처리 방법 (1) DBMS의 주요 기능 - DB 관리 및 사용자 요구를 처리하기 위한 연산을 수행해서 필요한 정보를 생성한다.  (2) DBMS의 연산 수행 절차 ① 데이터 언어로 작성된 사용자의 접근 요구(Access Request)를 접수해서 분석한다.  ② 시스템이 이해할 수 있는 형태로 변환한다.   ③ 외부/개념/내부 스키마 간의 사상(Mapping)을 수행해서 저장 DB에 접근한다.    ④ 저장된 목표 데이터에 대해 필요한 연산(Operation)을 실행한다.  	1
0000	DB 시스템 개요 19 2. DBMS의 구성 요소 DBMS의 구성 요소 (1) DBMS의 기능적 구성 요소 질의어 DML/응용프로그램 DDL/스키마 질의어 처리기 DML예비컴파일러 DDL 컴파일러 DML컴파일러 저장 데이터 관리자 일반 사용자 응용 프로그래머 DBMS DB 관리자 런타임 데이터베이스 처리기 트랜잭션 관리자 시스템 카탈로그 (데이터 사전) 저장 데이터베이스 	1
0000	DB 시스템 개요 20 DBMS의 구성 요소 (2) DDL 컴파일러(DDL Compiler)의 역할 - DDL로 정의된 스키마를 내부 형태로 변환해서 시스템 카탈로그에 저장한다.  시스템 카탈로그에 저장된 데이터를 메타 데이터(Metadata) 즉  데이터의 데이터라 칭함 - DDL 처리기(Processor)라고도 칭한다.  (3) 질의어 처리기(Query Processor)의 역할 - 터미널에서 일반 사용자가 입력한 질의문을 컴파일해서  DB에 접근하기 위한 오브젝트 코드 (Object Code)를 생성한다.  (4) DML 예비 컴파일러(Pre-compiler)의 역할 - 호스트 언어로 작성된 응용 프로그램에 삽입된 DML을 추출한 다음  그 자리에 함수 호출문 (Procedure Call Statement)을 삽입한다.  - 추출된 DML은 DML 컴파일러로 전달되고  수정된 응용 프로그램은 호스트 프로그래밍 언어의 컴파일러로 전달된다.  * 오브젝트 코드(Object Code)  – 원시 코드(Source Code) 가 컴파일러(Compiler)에 의해서 처리기(Processor)가 이해할 수 있는 명령어 형태 로 번역된 것이다.  	1
0000	DB 시스템 개요 21 DBMS의 구성 요소 (5) DML 컴파일러(DML Compiler)의 역할 - DML 명령어를 컴파일해서 오브젝트 코드로 변환한다.  - 이 오브젝트 코드는 호스트 프로그래밍 언어의 컴파일러에 의해 처리된 수정된 응용 프로그램의 오브젝트 코드와 연결되어 런타임 DB 처리기에 의해 실행된다.  - DML 처리기(Processor)라고도 칭한다.  (6) 런타임 DB 처리기(Runtime Database Processor)의 역할 - 실행 시간에 DB 접근을 관리한다.  - 여러 가지 DB 연산(Operations)을 저장 데이터 관리자(Stored Data Manager)를 통해서 수행한다.  	1
0000	DB 시스템 개요 22 DBMS의 구성 요소 (7)  트랜잭션 관리자(Transaction Manager)의 역할 - 데이터를 일관되게 변경하는 하나 이상의 DML 문장으로 구성된 트랜잭션(Transaction) 단위의 작업을 수행한다.  - 예를 들면  DB 접근 과정에서의 무결성(Integrity) 제약조건 검사  데이터에 대한 접근 권한 검사   여러 사용자의 요구를 동시에 처리하기 위한 병행 제어(Concurrency Control)  장애 발생 시 복구(Recovery) 작업 등을 수행한다.  (8) 저장 데이터 관리자(Stored Data Manager)의 역할 - 디스크에 저장되어 있는 사용자 DB나 시스템 카탈로그에 대한 접근을 제어한다.  - 다음과 같은 운영 체제의 기본 모듈(File Manager  Disk Manager)을 이용한다.  o 파일 관리자(File Manager) : 요구된 저장 레코드가 어떤 파일의 어떤 페이지에 있는지 결정한다.  o 디스크 관리자(Disk Manager) : 실제로 디스크와 메인 메모리 버퍼 간의 데이터 전송을 책임진다. 트랜잭션(Transaction)  - 데이 터를 일관되게 변경하는 하 나 이상의 데이터 조작어 (DML) 문장이다.  	1
0000	DB 시스템 개요 1. DB 시스템의 구성 요소 23 학습 요약 및 정리 학습 요약 및 정리 No. 구성 요소 역할 1 데이터베이스(DB)  데이터를 저장한다.  2 데이터베이스 관리시스템 (DBMS) DB를 생성  관리  조작함으로써 사용자와 DB를 연결해 주는 소프트웨어이다. 3 데이터 언어 (Data Language)  DB 정의와 조작  제어를 위한 DB 전용 언어이다.  4 DB 사용자 데이터 언어를 사용해서 DB에 접근하는 사람으로  일 반 사용자와 응용 프로그래머  DB 관리자로 구분할 수 있다.  5 DB 컴퓨터 효율적인 DB 관리를 위해서 DB에 대한 연산을 전담하 는 DB 관리 전용 컴퓨터이다.  	1
0000	DB 시스템 개요 24 학습 요약 및 정리 학습 요약 및 정리 2. 데이터 언어의 종류 ① 데이터 정의어(DDL: Data Definition Language) - DB 구조를 정의하거나 변경하기 위해서 사용하는 언어이다.  ② 데이터 조작어(DML: Data Manipulation Language) - DB 사용자(응용 프로그램 포함)와 DBMS 사이의 통신수단으로서   데이터 검색과 삽입  삭제  갱신과 같은 DB 연산을 처리한다.    ③ 데이터 제어어(DCL: Data Control Language) - 공용 DB의 관리를 위해 데이터 제어를 정의하고 기술하는 언어이다.  	1
0000	DB 시스템 개요 3. DB 관리자의 주요 역할 ① DB 시스템 감시(Monitoring) 및 성능 분석 ② DB의 구성 요소 결정 및 스키마 정의 ③ DB의 저장 구조와 접근 방법 결정 ④ 보안 및 권한 부여 정책  데이터의 유효성 검사 방법 수립 ⑤ 백업(Backup) 및 복구(Recovery) 절차 수립 ⑥ DB의 무결성 유지를 위한 대책 수립 ⑦ DB 시스템의 성능 향상 및 새로운 요구에 대응한 DB 재구성 ⑧ 시스템 카탈로그의 관리 ⑨ 데이터 표현 및 시스템 문서화에 대한 표준 설정 ⑩ 사용자의 요구 및 불만 해소 등 25 학습 요약 및 정리 학습 요약 및 정리 	1
0000	DB 시스템 개요 4. DBMS의 기능적 구성 요소와 그 역할 26 학습 요약 및 정리 학습 요약 및 정리 No. 구성 요소 역할 1 DDL 컴파일러 (DDL Compiler) DDL로 정의된 스키마를 내부 형태로 변환해서 시스템 카탈로그에 저장한다. 2 질의어 처리기 (Query Processor) 터미널에서 일반 사용자가 입력한 질의문을 컴파일해서   DB에 접근하기 위한 오브젝트 코드(Object Code)를 생성한다.  3 DML 예비 컴파일러 (DML Pre-Compiler) 호스트 언어로 작성된 응용 프로그램에 삽입된 DML을 추출한 다음  그 자리에 함수 호출문(Procedure Call  Statement)을 삽입한다.  4 DML 컴파일러 (DML Compiler)  DML 명령어를 컴파일해서 오브젝트 코드로 변환한다. 5 런타임 DB 처리기 (Runtime Database Processor) 실행 시간에 DB 접근을 관리한다.  6 트랜잭션 관리자 (Transaction Manager) 트랜잭션(Transaction) 단위의 작업을 수행한다.  7 저장 데이터 관리자 (Stored Data Manager)  디스크에 저장되어 있는 사용자 DB나 시스템 카탈로그 에 대한 접근을 제어한다.  	1
0000	데이터베이스 데이터베이스 4 회차 : 데이터 모델링 개요 김 은 경 	1
0000	데이터 모델링 개요 2 학습목표 학습에 앞서 학습목표 동기유발 & 학습목표 학습내용 1. 데이터 모델링 이해하기 학습목표 2. 개념적 데이터 모델과 논리적 데이터 모델 1. 데이터 모델링이 무엇인지 정의할 수 있다. 2. 데이터 모델링을 구성하는 3 단계를 나열할 수 있다.     3. 데이터 모델을 구성하는 3 가지 요소를 나열할 수 있다.  1. 개념적 데이터 모델이 무엇인지 설명할 수 있다.  2. 논리적 데이터 모델의 특징을 설명할 수 있다.  	1
0000	데이터 모델링 개요 3 Lesson.  데이터 모델링 이해하기 1. 데이터의 구분 2. 데이터 모델링이란?  3. 데이터 모델의 이해 데이터 모델의 개념 	1
0000	데이터 모델링 개요 4 데이터의 구분 1. 데이터의 구분 (1) 데이터가 속한 세계에 따른 데이터 구분 No. 세계 구분 데이터의 특징 1 현실 세계 (Real World) 오감으로 인지할 수 있는 실체로서  하나 이상의 특성으로 구성된 개체(Entity)로 표현된다.  2 개념 세계 (Conceptual World) 개체의 의미로부터 얻은 개념(Concept)으로서  하나 이상의 속성으로 구성된 개체 타입으로 표현된다.  3 컴퓨터 세계 (Computer World) 개념을 컴퓨터가 처리할 수 있도록 표현한 데이터(Data)로서   하나 이상의 필드(Field)로 구성된 레코드 타입으로 표현된다.  	1
0000	데이터 모델링 개요 5 데이터의 구분 (2)  각 데이터의 구성 요소 현실 세계(실체) 개체 타입 속성 값 개념 세계(개념) 컴퓨터 세계(데이터) 레코드 타입 필드 값 특성 값 개체 현실 세계의 실체 는 하나 이상의 특 성으로 구성된 개 체로 표현됨 개념 세계에서는 하나 의 개체가 하나 이상의 속성으로 구성된 개체 타입으로 표현됨 컴퓨터 세계에서는 하나의 개체 타입이 하나 이상의 필드로 구성된 하나의 레코 드 타입으로 표현됨 	1
0000	데이터 모델링 개요 6 데이터의 구분 (3)  데이터의 구분 사례 구분 특징 현실 세계의 학생 개체 얼굴 모습 등 신체적 특징  이름  주민등록번호  고향  학력  취미  별명  연락처  교우 관계  가족 관계 등 수없이 많은 특성으로 구성됨 대학이라는 개념 세계의 학생 개체 타입 이름  학번   전공  지도교수  이수학점수  평균평점 등 대학에서 필요로 하는 많은 속성들로 구성됨 컴퓨터 세계의 학생 레코드 타입 이름(문자 20바이트)  학번(문자 10바이트)  전공(문자 20바이트) 등 개념 세계의 속성에 대응하는 많은 필드들로 구성됨 	1
0000	데이터 모델링 개요 7 DB 모델링이란?  2. 데이터 모델링이란?  (1) 데이터 모델링(Data Modeling)의 정의 - 현실 세계의 데이터를 DB로 표현하기 위한 모델을 만드는 과정으로  개념적 구조(개념적 데이터 모델)와 논리적 구조(논리적 데이터 모델)를 거쳐서  실제로 디스크에 저장할 수 있는 물리적 구 조로 변환하는 일련의 DB 설계 과정을 데이터 모델링이라고 한다. 	1
0000	데이터 모델링 개요 8 DB 모델링이란?  (2) 데이터 모델링의 3 단계 - 크게 개념적 모델링과 논리적 모델링  물리적 모델링의 3단계로 구성된다. 논리적 구조 (논리적 데이터 모델) 개념적 구조 (개념적 데이터 모델) 물리적 구조 (저장DB) 현실 세계 개체 개념 세계 ② 논리적 모델링 컴퓨터 세계 ③ 물리적 모델링 ① 개념적 모델링 [DB 모델링의 3 단계]  	1
0000	데이터 모델링 개요 9 DB 모델링이란?  * 추상화(Abstraction)   - 세세하고 지엽적인 특징은 무시하고 핵심만을 추출하는 것을 의미한다.  * ER(Entity-Relationship) 모델 - 1976년 피터 첸(Peer Chen)이 제안한 개념적 데이터 모델로서  개체 집합과 관계 집합을 이용해 서 현실 세계의 데이터를 개념적 으로 표현하는 모델이다. (3) 개념적 모델링(Conceptual Modeling)  1) 개념적 모델링이란?  - 현실 세계의 데이터를 추상화(Abstraction)를 통해서 개념 세계의 데이터로 표현하는 과정이다. - 정보 모델링(Information modeling) 또는 개념적 설계(Conceptual design)와 동일한 개념이다. 2) 개념적 모델링 방법 - 일반적으로 개체와 관계라는 추상적 개념을 이용해서 모델링 한다. - 주로 ER(Entity-Relationship) 모델이라는 개념적 데이터 모델을 사용하며  모델링 결과를 ER 다이어그램(Diagram)으로 표현한다. 	1
0000	데이터 모델링 개요 10 DB 모델링이란?  3) 개념적 모델링 예제 - 현실 세계의 학생이라는 개체는 ‘대학’이라는 개념 세계에서 “학생”은 “이름  학번  전공  이수학점    지도교수” 라는 속성을 갖는 대학생 개체 타입으로 모델링 할 수도 있고  ‘인터넷 쇼핑몰’이라는 개념 세계에서는 “이름  주민등록번호  연락처  주소”라는 속성을 갖는 고객 개체 타입으로 모델링 할 수 있다.  (얼굴 모습과 목소리  머리 색깔  이름 등 헤아릴 수 없을 정도로 많은 특성을 가짐) 현실 세계의 학생 인터넷 쇼핑몰이라는 개념 세계의 고객 고객 이름 주민등록번호 연락처 주소 (여러 특성 가운데 이름  주민등록학번  연락처 등과 같이 쇼핑몰에 필요한 특성만 추출함) 대학이라는 개념 세계의 대학생 대학생 이름 학번 전공 이수학점 (여러 특성 가운데 이름  학번  전공 등과 같이 대학 업무에 필요한 특성만 추출함) 지도교수 [개념적 모델링의 예] 	1
0000	데이터 모델링 개요 11 DB 모델링이란?  (4) 논리적 모델링(Logical  Modeling)  1) 논리적 모델링이란?  - 개념 세계의 개체 타입을 DBMS가 지원하는 논리적 데이터 모델로 변환시키는 과정이다. - 논리적 설계(Logical design)와 동일한 개념이다. 2) 논리적 데이터 모델이란?  - DB에 저장할 데이터의 구조를 DBMS가 이해할 수 있는 논리적인 구조로 표현하기 위해 사용하는 일종의 지능적인 도구이다.  - 논리적 데이터 모델의 종류 : 관계형  네트워크형  계층형 데이터 모델 등 3) 논리적 모델링 방법 - ER 다이어그램으로 표현된 개념적 구조를 DBMS가 지원하는 논리적 데이터 모델로 변환한다.   - 논리적 데이터 모델로 변환하는 방법은 논리적 데이터 모델의 종류에 따라 다르다.  	1
0000	데이터 모델링 개요 12 DB 모델링이란?  릴레이션(Relation) – 관계형 데이터 모델에서 개체나 관계를 표현하는 2차원 테이블로서  릴 레이션 이름과 하나 이상의 속성 을 포함한다.   4) 논리적 모델링의 예 - 앞의 개념적 모델링 예제에서 표현한 대학생 개체 타입을 관계형 데이터 모델로 변화하면   2차원 테이블 형태 또는 간단히 리스트 형태로 릴레이션을 표현할 수 있다.  대학생 개체 타입의 ER 다이어그램 대학생 이름 학번 전공 이수학점 지도교수 논리적 모델링 [논리적 모델링의 예] 관계형 데이터 모델 혹은 대학생(이름  학번  전공  이수학점  지도교수)  이름 학번 전공 지도교수 이수학점 대학생 테이블 테이블 형태 표현 리스트형태 표현 	1
0000	데이터 모델링 개요 13 DB 모델링이란?  (5) 물리적 모델링(Physical  Modeling)  1) 물리적 모델링이란?  - 디스크에 데이터가 저장될 수 있도록 논리적 데이터 모델을 물리적 데이터 구조로 변환시키는 과정이다. - 물리적 설계(Physical design)와 동일한 개념이다. 2) 물리적 모델링 방법 - 저장 레코드 양식(각 필드의 이름  데이터 타입  크기 등) 정의 및 인덱스(Index)나 뷰(View) 등을 설계한다. 관계형 데이터 모델 이름 학번 전공 지도교수 이수학점 물리적 모델링 물리적 구조 (저장 DB) [물리적 모델링의 개념] 	1
0000	데이터 모델링 개요 14 데이터 모델이란?  3. 데이터 모델의 이해 (1) 데이터 모델(Data Model)이란?  - 복잡한 현실 세계 데이터를 쉽게 이해할 수 있도록 기술하는 개념적 도구이다.  (2)  데이터 모델의 구분 ① 개념적 데이터 모델 - 구성요소가 ‘개체’와 ‘관계’라는 추상적인 개념으로 구성된 데이터 모델이다.  - 대표적 모델: ER(Entity-Relationship: 개체-관계) 모델 ② 논리적 데이터 모델 - 구성요소가 ‘레코드’와 ‘관계’라는 논리적인 개념으로 구성된 데이터 모델이다.  - 대표적 모델: 관계형 데이터 모델  개념적 또는 논리적으로 구분하지 않고 그냥 ‘데이터 모델’이라고 하면   일반적으로 ‘논리적 데이터 모델’을 의미한다. 	1
0000	데이터 모델링 개요 15 데이터 모델이란?  개체 인스턴스(Instance)   - 개체 타입을 구성하는 각 속성 들이 구체적인 값을 가진 것을 의미한다.  (3)  데이터 모델의 구성 - 데이터 모델(D: Data Model)은 데이터 구조(S: Structure)와 연산(O: Operation)  그리고 제약조건(C: Constraint)으로 구성된다. 1) 데이터 구조(S) - 데이터 모델의 정적 성질(Static Properties)에 해당한다.  - 개체 타입과 이들 간의 관계에 대한 명세를 의미한다.  2) 데이터 구조에서 허용될 수 있는 연산(O) - 데이터 모델의 동적 성질(Dynamic Properties)에 해당한다.  - 개체 인스턴스(Instance)를 처리하는 작업에 대한 명세를 의미한다.  - 즉  데이터 조작 방법이다. 3) 데이터 구조와 연산에 대한 제약 조건(C) - 데이터 모델의 논리적 제약(Logical Constraints)을 의미한다.  - 개체 인스턴스의 존재 조건으로서  구조적 제약과 의미상 제약을 모두 포함한다.  - 즉  데이터 조작의 한계를 표현하는 규정이다.  D = <S   O   C>  심화 학습 	1
0000	데이터 모델링 개요 16 [심화 학습]  [심화 학습] 구조적 제약과 의미상 제약의 의미 (1) 구조적 제약 - 개체 인스턴스가 반드시 만족해야 하는 구조적인 특성을 의미한다.  - 예:  학생의 학번이라는 속성은 구조적으로 반드시 숫자 8자리로 구성되어야 한다.   학번에 문자가 포함되어 있거나 숫자가 8자리 이상인 경우  오류(Error)로 처리해서 그 개체 인스턴스가 삽입되지 않도록 한다.  (2) 의미상 제약 - 개체 인스턴스가 반드시 만족해야 하는 의미상의 특성을 의미한다.  - 예: 학생의 성별이라는 속성은 구조적으로는 하나의 문자로 구성되지만  의미상으로 반드시 ‘M(Male)’ 또는 ‘F(Female)’라는 값을 가져야 한다.  성별에 ‘M’이나 ‘F’ 이외의 값이 포함된 경우  오류(Error)로 처리해서 그 개체 인스턴스가 삽입되지 않도록 한다.  	1
0000	데이터 모델링 개요 17 Lesson.   개념적 데이터 모델과 논리적 데이터 모델 개체 타입과 관계 타입 1. 개념적 데이터 모델 2. 논리적 데이터 모델 	1
0000	데이터 모델링 개요 18 1. 개념적 데이터 모델 (1)  개념적 데이터 모델이란?  - 개념적 모델링을 통해서 얻을 수 있는 추상화된 데이터 구조로서   구성요소가 ‘개체’와 ‘관계’라는 추상적인 개념으로 구성된 데이터 모델이다.  (2)  개념적 데이터 모델의 특징 - DB 설계자의 이해를 돕기 위한 것으로  DBMS는 개념적 데이터 모델을 이해할 수 없다.  (3)  개념적 데이터 모델의 종류 ① 개체-관계(ER: Entity-Relationship) 모델 ② 시멘틱 네트워크 (Semantic Network) 데이터 모델 ③ 의미 객체(Semantic Object) 모델 ④ OMT(Object-Modeling Technique) 모델 개념적 데이터 모델 	1
0000	데이터 모델링 개요 19 (4)  ER 모델이란?  - 개체 집합과 관계 집합을 이용해서 현실 세계를 개념적으로 표현하는 방법으로서  현재 가장 널리 사용되는 대표적인 개념적 데이터 모델이다. - 1976년  피터 첸(Peter Chen)이 처음 소개한 이후  계속 변형  발전되고 있다. - ER 다이어그램(Diagram)을 사용해서 표현한다. 예) ‘학생’과 ‘교수’ 개체 사이의 ‘지도’라는 관계를 표현하는 ER 다이어그램 개념적 데이터 모델 * 학생 교수 지도 이름 교수 번호 소속 학번 전공 학년 이름 n 1 학생 번호 학번 학년 이름 #1 	1
0000	데이터 모델링 개요 20 논리적 데이터 모델 2. 논리적 데이터 모델 (1)  논리적 데이터 모델이란?  - 개념적 데이터 모델을 DB로 구현하기 위한 중간 단계로서  구성요소가 ‘레코드’와 ‘관계’라는 논리적인 개념으로 구성된 데이터 모델이다.  (2)  논리적 데이터 모델의 특징 - DBMS는 하나의 논리적 데이터 모델을 기반으로 개발되므로  DBMS가 논리적 데이터 모델을 이해할 수 있다.   따라서 ER 다이어그램을 논리적 데이터 모델로 변환할 때는 반드시 사용할 DBMS가 기초로 하고 있는 논리적 데이터 모델로 변환해야 한다.  [논리적 모델의 위치]  추상화 변환 변환 개념적 데이터 모델 (예: ER 모델) 논리적 데이터 모델 (예: 관계형 데이터 모델) 현실 세계 (개체) 저장 DB 	1
0000	데이터 모델링 개요 21 논리적 데이터 모델 (3) 논리적 데이터 모델의 종류 ① 관계 데이터 모델(Relational data model) ② 네트워크 데이터 모델(Network data model) ③ 계층 데이터 모델(Hierarchical data model) ④ 객체지향 데이터 모델 (Object-Oriented Data Model) ⑤ 객체 데이터 모델(Object Data Model) ⑥ 객체-관계 데이터 모델 (Object-Relational Data Model) ⑦ 확장 관계 데이터 모델(Extended Relational Data Model) 	1
0000	데이터 모델링 개요 22 논리적 데이터 모델 (4)  대표적인 논리적 데이터 모델 ① 관계 데이터 모델(Relational data model) - DB를 릴레이션(Relation)  즉 테이블(Table)의 집합으로 모델링한 구조이다. ② 네트워크 데이터 모델(Network data model) - DB를 그래프(Grape) 형태로 모델링한 구조이다. ③ 계층 데이터 모델(Hierarchical data model) - DB를 트리(Tree) 형태로 모델링한 구조이다. 예제 예제 예제 	1
0000	데이터 모델링 개요 23 논리적 데이터 모델 교수 교수번호 이름 학과 교수번호 학번 시간 장소 학번 이름 학년 학과 교과목번호 교과목이름 학점 교과목 학생 학번 교과목번호 교수번호 교과목번호 수강 강의 지도 교수 교수번호 이름 학과 교수번호 이름 학과 교수번호 학번 시간 장소 교수번호 학번 시간 장소 학번 이름 학년 학과 학번 이름 학년 학과 학점 학점 학생 교수번호 교수번호 강의 지도 [관계 데이터 모델의 예]  	1
0000	데이터 모델링 개요 24 논리적 데이터 모델 [네트워크 데이터 모델의 예]  [계층 데이터 모델의 예] 교수 학생 교과목 수강 과목 수강 학생 교수 과목 학생 등록 지도 수강 강의 교수 과목 학생 등록 지도 수강 강의 교 	1
0000	데이터 모델링 개요 25 논리적 데이터 모델 ER(이알) 다이어그램을 관계형 데이터 모델로 변환하는 방법에 대해서는 뒤에서 자세히 학습하도록 하겠습니다.   (4)  논리적 데이터 모델링의 예 - 교수/학생/교과목 개체 및 그들 간의 관계를 모델링한 ER 다이어그램을 관계형 데이터 모델로 변환 하기 교수 교수번호 이름 학과 교수번호 학번 시간 장소 학번 이름 학년 학과 교과목번호 교과목이름 학점 교과목 학생 개체 릴레이션 학번 교수번호 수강 강의 지도 관계 릴레이션 교수 교수번호 이름 학과 교수번호 이름 학과 교수번호 학번 시간 장소 교수번호 학번 시간 장소 학번 이름 학년 학과 학번 이름 학년 학과 학점 학점 학생 개체 릴레이션 학번 학번 교과목번호 교수번호 교과목번호 교수번호 강의 지도 관계 릴레이션 논리적 데이터 모델링 교수 학생 교과목 수강 강의 지도 교과목 이름 교수 번호 이름 교과목 번호 학과 학점 시간 장소 학번 학과 학년 이름 1 1 m m m n 교수 학생 강의 지도 이름 교수 번호 이름 번호 학과 학점 시간 장소 학번 학과 학년 이름 1 1 m m m n 	1
0000	데이터 모델링 개요 26 쉼터 쉼터 • 봄길 - 정호승 길이 끝나는 곳에서도 길이 있다 길이 끝나는 곳에서도 길이 되는 사람이 있다 스스로 봄길이 되어 끝없이 걸어가는 사람이 있다 강물은 흐르다가 멈추고 새들은 날아가 돌아오지 않고 하늘과 딸 사이의 모든 꽃잎은 흩어져도 보라 사랑이 끝나는 곳에서도 사랑으로 남아 있는 사람이 있다 스스로 사랑이 되어 한없이 봄길을 걸어가고 있는 사람이 있다 	1
0000	데이터베이스 데이터베이스 5 회차 : ER 모델 개요 김은경 	1
0000	ER 모델 개요 2 학습목표 학습에 앞서 학습목표 동기유발 & 학습목표 학습내용 1. ER 모델 이해하기 학습목표 2. ER 다이어그램과 EER  모델 1. ER 다이어그램을 구성하는 3가지 기본 요소를 나열할 수 있다.  2. 속성의 종류와 각각의 특성을 설명할 수 있다.  3. 관계의 유형을 나열할 수 있다.  1. ER 다이어그램의 특징을 설명할 수 있다. 2. 강한 개체 타입과 약한 개체 타입을 구분해서 설명할 수 있다.   	1
0000	ER 모델 개요 3 Lesson.  ER 모델 이해하기 1. ER 모델이란?   2. 개체 3. 속성 4. 관계 ER 모델 이해하기 	1
0000	ER 모델 개요 4 ER 모델이란? 1. ER 모델이란?  (1) ER 모델의 정의 - 1976년 피터 첸(Peer Chen)이 제안한 개념적 데이터 모델로서  개체 집합과 관계 집합을 이용해서 현실 세계의 데이터를 개념적으로 표현하는 모델이다. (2) ER 모델의 특징 - 단순하다는 장점 때문에 현재 가장 널리 사용되고 있는 개념적 데이터 모델이다.  - 개체와 속성  관계라는 3가지 기본 요소로 구성되는 ER 다이어그램(Diagram)으로 표현된다.   - 사용자 즉  DB 설계자를 위한 모델이므로 DBMS는 이해할 수 없다.   (3) ER 모델의 주요 구성 요소 구분 정의 개체 (Entity) DB가 표현하려고 하는 유형  무형의 정보 대상으로  존재하면서 서로 구별될 수 있는 요소이다.  관계 (Relationship) 개체들 간의 의미 있는 연결 또는 연관성을 의미하는 요소이다.  속성 (Attribute) 개체나 관계의 특성을 나타내는 요소로서  이름을 가진 정보의 가장 작은 논리적 단위이다. 	1
0000	ER 모델 개요 5 2. 개체 (1)  개체(Entity)란?  - DB가 표현하려고 하는 유형  무형의 정보 대상으로  존재하면서 서로 구별될 수 있는 요소이다. (2)  개체의 종류 ① 개념적 개체(무형의 개체) : 개념적으로는 존재하지만 눈에 보이지 않는 개체 예) 약속  사건  승진 등 ② 물리적 개체(유형의 개체) : 현실 세계에 존재하면서 눈에 보이는 개체 예) 사람  상품  건물 등 (3) 개체의 특징 - 파일 시스템에서 레코드(Record)에 대응한다. - 단독으로 존재 가능하고  정보로서의 역할이 가능하다. - 하나 이상의 속성(Attribute)으로 구성된다. 예) 개체 - 학생 속성 - 학번  이름  학과 등 개체 	1
0000	ER 모델 개요 6 (4) 개체 관련 주요 개념들 ① 개체 타입(Entity Type)이란? - 개체의 정의  즉 개체의 이름과 개체를 구성하는 속성들을 정의한 것을 의미한다.  ② 개체 인스턴스(Entity Instance) 또는 개체 출현(Entity Occurrence) - 개체의 속성들이 구체적인 값을 가짐으로써 실체화된 것을 의미한다. ③ 개체 집합(Entity Set) - 개체 인스턴스들의 집합을 의미한다. ④ 속성(Attribute) - 개체의 특성을 나타내는 요소를 의미한다. 개체 	1
0000	ER 모델 개요 7 개체 학생 개체 타입 개체 인스턴스 학 번 이 름 2011845 홍길동 2012823 김철수 전 공 컴퓨터 전 자 속 성 개체 집합 개체 [개체 관련 주요 개념들] 	1
0000	ER 모델 개요 8 개체 (5)  개체의 표현 - ER 다이어그램으로 표현할 때는 직사각형으로 표현한다. - 예: 학생 개체 학생 [학생 개체의 표현]  	1
0000	ER 모델 개요 9 3. 속성 (1)  속성(Attribute)란?  - 개체나 관계의 특성을 나타내는 요소로  이름을 가진 정보의 가장 작은 논리적 단위이다. (2)  속성의 특징 - 파일 시스템에서 데이터 항목(Data Item) 혹은 필드(Field)에 대응한다. - 단독으로 존재할 때는 대개 무의미하다. (3)  속성의 표현 - ER 다이어그램으로 표현할 때는 개체 집합을 나타내는 직사각형에 실선으로 연결된 타원형으로 표현한다.  - 예: 학생 개체를 특성을 나타내는 학번  이름  전공  연락처 속성들 속성 [학생 개체의 속성들 표현]  학생 학번 이름 전공 연락처 	1
0000	ER 모델 개요 10 (4)  도메인(Domain)이란?  - 각 속성마다 가질 수 있는 값의 범위를 의미한다.  - 예 : 학번의 도메인은 정수 10자리  주소의 도메인은 문자 30자리 (5)  속성의 종류 ① 상수 속성(Constant Attribute) - 시간이 지나도 값이 변하지 않는 속성 예) 고객의 주민등록번호 속성 ② 시변 속성(Time Varying Attribute) - 갱신함에 따라 값이 변할 수 있는 속성 예) 고객의 주소 속성 ③ 단순 속성(Simple Attribute 또는 Atomic Attribute) ④ 복합 속성(Composite Attribute) ⑤ 단일치 속성(Single-valued Attribute) ⑥ 다중치 속성(Multi-valued Attribute) ⑦ 유도 속성(Derived Attribute) ⑧ 저장 속성(Stored Attribute) ⑨ 널 속성(Null Attribute) ⑩ 키 속성(Key Attribute) 또는 식별자(Identifier) ⑪ 부분 키 속성(Partial Key Attribute) 속성 	1
0000	ER 모델 개요 11 (6)  단순 속성과 복합 속성 ① 단순 속성(Simple Attribute 또는 Atomic Attribute) - 더 이상 작은 구성 요소로 분해할 수 없는 속성 - 예: 회원번호  이름  연락처 ② 복합 속성(Composite Attribute) - 독립적인 의미를 갖는 단순 속성들로 분해할 수 있는 속성 - 예: 주소 (도  시  구  우편번호라는 4개의 단순 속성으로 분해됨) 속성 어떤 속성이 단순 속성인지 복합 속성인지는 고정된 것은 아닙디다. 즉  필요에 따라서 이름도 성과 이름을 따로 분해하면 복합 속성이 되고  주소도 도와 시  구 등으로 분해하지 않고 하나의 문자열로 취급하면 단순 속성으로 볼 수 있습니다.  [단순 속성과 복합 속성] 이름 주소 도 우편번호 시 구 회원 회원번호 연락처 	1
0000	ER 모델 개요 12 (7)  단일치 속성과 다중치 속성 ① 단일치 속성(Single-valued Attribute) - 특정 개체에 대해 반드시 하나의 값만 갖는 속성 - 예: 주민등록번호  학번 ② 다중치 속성(Multi-valued Attribute) - 특정 개체에 대해 여러 개의 값을 가질 수 있는 속성 - 예: 전화번호 (집  휴대폰  회사 전화번호 등)  취미 - ER 다이어그램에서 이중선 타원으로 표시함 속성 [다중치 속성] 취미 	1
0000	ER 모델 개요 13 (8)  유도 속성과 저장 속성 ① 유도 속성(Derived Attribute) - 속성의 값이 다른 관련된 속성이나 개체가 갖고 있는 값으로부터 유도되어 결정되는 속성 - ER 다이어그램에서 유도 속성은 점선 타원으로 표시 ② 저장 속성(Stored Attribute) - 유도 속성을 결정하기 위해 사용된 속성 속성 [유도 속성과 저장 속성]  나이 ‘오늘’로 수정!! 	1
0000	ER 모델 개요 14 (9)  널 속성 ① 널 속성(Null Attribute)이란?  - 널 값을 갖는 속성이다. ② 널 값이란?  - 어떤 개체 인스턴스가 특정 속성에 대한 값을 갖고 있지 않을 때  이를 명시적으로 표시하기 위해 사용하는 값이다.  ③ 널 값을 갖는 경우 a) 어떤 속성 값이 그 개체에 “해당되지 않는(not applicable)” 경우 b) 어떤 속성 값을 “알 수 없는(unknown)” 경우 가)  값이 존재하지만 값이 “누락(missing)”된 경우 나)  값이 존재하는지 여부를 “모르는(not known)” 경우 속성 (널 속성까지 학습이 끝난 다음)  키 속성과 부분 키 속성에 대해서는 뒤에서 자세히 설명하도록 하겠습니다.  	1
0000	ER 모델 개요 15 4. 관계 (1)  관계(Relationship)란?  - 개체들 간의 의미 있는 연결 또는 연관성을 의미하는 요소이다. (2)  관계의 특성 - 관계도 하나의 개체로 간주될 수 있다. - 관계도 속성을 가질 수 있다. - 두 개의 개체 사이에 두 개 이상의 관계가 존재할 수 있다. (다중 관계라 칭함) (3)  관계의 표현 - ER 다이어그램으로 표현할 때는 개체 집합을 나타내는 직사각형에 실선으로 연결된 마름모로 표현한다.  관계 	1
0000	ER 모델 개요 16 (4)  관계 타입의 속성 - 관계 타입은 관계의 특성을 나타내는 속성(들)을 가질 수 있다. - 관계 타입은 키 속성을 갖지 않는다. - 예: 교수 개체와 교과목 개체 사이에 시간과 장소라는 2개의 속성을 갖는 ‘강의하다’라는 관계 표현 (5)  관계의 유형 ① 일 대 일(1 : 1) : 어느 개체를 기준으로 보더라도  한 개체가 한 개체와만 연관성이 있는 유형이다. ② 일 대 다(1 : n) : 두 개체 가운데 어느 한 개체를 기준으로 보면 하나 이상의 개체와 연관성이 있고  다른 개체를 기준으로 보면 한 개체와만 연관성이 있는 유형이다. ③ 다 대 다(m : n) : 두 개체 가운데 어느 개체를 기준으로 보더라도 하나 이상의 개체와 연관성이 있는 유형이다. 즉  여러 개체가 여러 개체와 연관성이 있는 것이다. 관계 교수 교과목 시간 장소 강의하다 	1
0000	ER 모델 개요 17 관계 O O O O O 1 2 3 4 5 O O O O O a b c d e 일 대 일(1 : 1) O O O O O 1 2 3 4 5 O O O O O a b c d e 일 대 다(1 : n) O O O O O 1 2 3 4 5 O O O O O a b c d e 다 대 다(m : n) [제목] 관계 유형 및 예제 (예) 부부 관계 (예) 모자 관계 (예) 이성친구 관계 아내 개체 남편 개체 1) 부부 관계 설명: 일부일처제를 기준으로 아내 개체 하나가 남편 개체 하나  반대로 남편 개체 하나도 아내 개체 하나와만 연관되므로 일 대 일 유형이다.  한편  혼자가 된 아내나 남편이 있을 수 있으므로 다른 개체와 연관되지 않는 개체가 존재할 수 있다. 2) 모자 관계 설명: 엄마의 경우 한 명 이상의 아들이 있거나 또 아들이 없을 수 있으므로  엄마 개체를 기준으로 보면 아들 개체와의 관계는 일 대 다 유형이다. 한편 아들 개체는 한 명의 엄마가 있거나 엄마가 없는 경우도 있으므로  아들 개체를 기준으로 보면 엄마 개체와의 관계는 일 대 일 유형이다. 따라서 이를 종합하면 엄마 개체와 아들 개체 사이의 관계는 일 대 다 유형이 된다.  3) 이성친구 관계 설명: 한 명의 여학생이 한 명 이상의 남학생 친구가 있을 수 있고  그 반대도 성립되므로 여학생과 남학생 개체 간의 관계는 다 대 다 유형이다. 한편  이성 친구가 한 명도 없는 학생도 있으므로  다른 개체와 전혀 관계를 맺지 않는 개체가 존재할 수 있다.  엄마 개체 아들 개체 여학생 개체 남학생 개체 	1
0000	ER 모델 개요 18 (6) 관계의 구분 ① 속성 관계(Attribute Relationship) - 한 개체내의 속성과 속성 사이의 연관성을 의미한다. ② 개체 관계(Entity Relationship) - 개체와 개체 사이의 연관성을 의미한다. - 그냥 “관계”라고 하면 개체 관계를 의미한다. DB의 개념적 구성 요소 학번 이름 학과 학생 교수 번호 이름 학과 교수 지도하다 :개체 관계 :속성 관계 [제목] 개체 관계과 속성 관계 비교 교수 개체와 학생 개체 사이에 ‘지도하다’라는 관계가 존재함 	1
0000	ER 모델 개요 19 (7) 카디널리티(Cardinality)  ① 카디널리티란?  - 관계에 참여하는 하나의 개체에 대해 다른 개체가 몇 개 대응하는지를 나타내는  관계에 대응하는 개체의 수를 의미한다. ② 카디널리티의 표현 - 대응 개체 수는 (min  max)의 한 쌍의 값으로 표현하는데  여기서 min은 관계에 참여하는 개체의 최소 개수  max는 관계에 참여하는 최대 개수를 의미한다. DB의 개념적 구성 요소 	1
0000	ER 모델 개요 20 DB의 개념적 구성 요소 교과목 개체에 대해 교수 개체 가 최소 1개  최대 1개 대응함.  즉 각 교과목은 단 한 명의 담 당 교수가 강의함 한 교과목은 최소 15명에서 최 대 30명의 학생이 수강할 수 있 음을 나타낸다.  교수 교과목 강의하다 m 1 (1  3)  (1  1)  학생 교과목 수강하다 n m (1  7)  (15  30)  ③ 예:  교수 개체에 대해 교과목 개체 가 최소 1개  최대 3개 대응함.  즉 교수는 최소 1개  최대 3개 교과목 강의함 학생은 1개 이상  7개 이하의 교과목을 수강할 수 있음을 나타낸다.  	1
0000	ER 모델 개요 21 (8) 차수(Degree) ① 차수란?  - 관계로 연결된 개체 타입의 개수를 의미한다. ② 차수의 유형 - 1진 관계  2진 관계  3진 관계  n진 관계 등으로 구분하며  현실 세계에서 가장 흔한 관계는 2진 관계이다. DB의 개념적 구성 요소 [관계의 차수 유형] 직원 직원 부서 근무하다 연구과제 관리하다. 공급하다. 공급처 재료 	1
0000	ER 모델 개요 22 ER 다이어그램 작성하기 1. ER 다이어그램이란?   2. 강한 개체 타입과 약한 개체 타입 표현 방법 3. 부분 참여와 전체 참여 표현 방법 4. EER 모델 소개 Lesson. ER 다이어그램과 EER 모델 	1
0000	ER 모델 개요 23 1. ER 다이어그램이란?  ER 다이어그램이란?  (1) ER 다이어그램의 정의 - 1976년 피터 첸(Peter Chen)이 처음 제안한 것으로  개념적 데이터 모델인 ER 모델을 표현하는 그래픽 방식의 표현 방법이다.  (2) ER 다이어그램 작성 지침 ① 개체 타입은 키(Key) 속성 이외에 개체 타입을 설명하는 속성들을 갖는다. ② 다중치 속성은 별도의 개체 타입으로 분류해야 한다. ③ 개체 타입을 직접적으로 설명하는 속성들을 개체 타입과 연결한다. ④ 관계 타입은 일반적으로 독자적으로 존재할 수 없다. ⑤ 키 속성(또는 속성 집합)에는 밑줄을 표시한다. (3) ER 다이어그램의 특징 ① 다 대 다(m : n) 관계를 표현할 수 있다. ② 다원 관계(n-ary Relationship) 표현이 가능하다. - 두 개 이상의 개체 타입이 하나의 관계에 관련될 수 있다.  ③ 다중 관계(Multiple Relationship) 표현이 가능하다.  - 두 개 개체 타입 사이에 둘 이상의 관계가 존재할 수 있다.  ④ 관계 타입도 속성을 가질 수 있다.  * 키(Key) – 개체 타입 안에서 모든 개체 인스턴스를 유일 하게 식별하는 속성 또는 속 성 집합을 의미한다.  	1
0000	ER 모델 개요 24 ER 다이어그램이란?  (4)  ER 다이어그램 표현 기호 ① 개체 타입:  ⑤ 약한 개체 타입:  ② 관계 타입:  ⑥ 식별 관계 타입:  ⑦ 전체 참여 개체 타입:  ⑧ 속성:  ⑨ 키 속성:  ⑩ 부분 키 속성:  ⑪ 다중치 속성:  ⑫ 복합 속성:  ⑬ 유도 속성:  ③ 연결선(Link): ④ 레이블(Label): 연결선 위에 1  n  m 으로 표현 	1
0000	ER 모델 개요 25 ER 다이어그램이란?  (5)  ER 다이어그램 작성 예제 교수 학생 교과목 수강하다 강의하다 지도하다 교과명 사번 이름 과목 번호 학과 학점 시간 장소 학번 학과 학년 이름 1 1 m m m n (1  3)  (1  1)  (15  30)  (1  6)  (5  10)  (1  1)  [교수/학생/교과목 개체의 관계를 모델링한 ER 다이어그램]  	1
0000	ER 모델 개요 26 강한 개체 타입과 약한 개체 타입 표현 방법 (1) 강한 개체 타입(Strong Entity Type)이란? - 독자적으로 존재하면서  개체 타입 내에서 자신의 키(Key) 속성을 사용해서 고유하게 개체를 식별할 수 있는 개체 타입을 의미한다.  - ER 다이어그램에서 일반 직사각형으로 표현한다.  (2)  약한 개체 타입(Weak  Entity Type)이란? - 개체를 식별할 수 있는 키를 형성하기에 충분한 속성을 갖지 못한 개체 타입을 의미한다.  - 약한 개체 타입이 존재하기 위해서는 반드시 소유 개체 타입(Owner Entity Type)이 존재해야 한다. - 약한 개체 타입의 구별자(부분 키)와 소유 개체 타입의 키 속성을 결합해야 약한 개체를 고유하게 식별할 수 있다.  - ER 다이어그램에서 이중선(겹줄) 직사각형으로 표현한다.  - 예:  부양가족 개체 – 사원 개체가 존재할 때만 존재할 수 있는 개체 2.  강한 개체 타입과 약한 개체 타입 표현 방법 부양가족 관계 이름 	1
0000	ER 모델 개요 27 (3) 존재 종속(Existence-dependence)  - 한 개체 타입(a)의 존재가 다른 개체 타입(b)의 존재에 영향을 받는 경우  a는 b에 ‘존재 종속’이라 고 칭한다. (a는 종속 개체(Subordinate Entity) 타입   b는 주 개체(Dominant Entity) 타입)  또는 소유 개체 타입)  - 예: ‘상환’ 개체 타입은 ‘대출’ 개체 타입에 존재 종속이다.  대출 대출상환 상환 대출번호 대출금액 상환번호 상환일자 상환금액 주 개체 타입 (소유 개체 타입) 종속 개체 타입 (약한 개체 타입) [대출(주 개체 타입)과 상환(종속 개체 타입) 간의 대출상환 관계를 모델링한 ER 다이어그램]  강한 개체 타입과 약한 개체 타입 표현 방법 (그림에 대한 나레이션)  상환 개체 타입의 경우 ‘상환번호’만으로는 키가 될 수 없기 때문에  소유 개체 타입인 대출의 ‘대출번호’와 ‘상환번호’를 결합해야 상환 개체 타입의 키가 될 수 있습니다.    	1
0000	ER 모델 개요 28 (4) 구별자와 식별 관계 타입 ① 구별자(Discriminator)란?  - 하나의 강한 개체 타입과 연관된 약한 개체 집합 안에서만 서로 구별할 수 있는 속성을 의미한다 - 부분 키(Partial Key)라고도 칭한다.  - ER 다이어그램에서 구별자 아래 점선 밑줄로 표현한다.  ② 식별 관계 타입(Identifying  Relationship Type)이란?  - 약한 개체 타입을 강한 개체 타입과 연관시켜서  약한 개체를 유일하게 식별하도록 하는 관계를 의미한다.  - ER 다이어그램에서 겹줄 마름모로 표현한다.  - 예: 부양 관계 타입 – 부양가족 개체를 사원 개체와 연관시킴  부양가족 개체를 고유하게 식별하려면  사원 개체 타입의 키 속성인 ‘사번’과 약한 개체 타입의 구별자인 ‘관계’를 결합해야 함 [사원(강한 개체 타입)과 부양가족(약한 개체 타입) 간의 부양 관계를 모델링한 ER 다이어그램]  부양가족 사원 관계 사번 이름 이름 1  n 부서 부양하다 구별자(부분 키)  식별 관계 타입 강한 개체 타입과 약한 개체 타입 표현 방법 보충 학습 	1
0000	ER 모델 개요 29 [보충 학습]  [보충 학습]  보험 회사가 “이몽룡”이라는 사원과 그의 부양가족에게 보험 혜택을 준다고 할 때  “사 원”  “부양_정보”라는 개체타입들을 정의한다고 하자.  “이몽룡”에게 “박하늘  이구름   이단비”라는 3명의 부양가족이 있다면  부양가족 3명은 “이몽룡”없이는 보험 혜택을 받 을 수 없다. 다시 말해 부양가족 3명의 정보는 “부양_정보”에 존재하지만 “사원”과 연관 되는 경우에만 존재하게 되는데  이를 존재 종속이라 한다. 만약 “이몽룡”이 직장을 그만 두어 “사원” 테이블에서 삭제되면  부양가족 3명도 함께 “부양_정보” 테이블에서 삭제되어야 한다.  	1
0000	ER 모델 개요 30 부분 참여와 전체 참여 표현 방법 (1) 부분 참여(Partial Participation)란?  - 어떤 개체 타입의 일부 개체만이 관계를 이루는 다른 개체 타입의 개체와 연관되는 것을 의미한다.  예) 학생-교과목 간의 수강 관계 - 관계의 참여 제약조건(Participation Constraint) 가운데 선택적(Optional) 참여에 해당한다.  - 대응 개체 수(min  max)로 표현하는 경우  min의 값은 ‘0’이 된다.  - ER 다이어그램에서 실선으로 표시한다.  (2) 전체 참여(Total Participation)란? - 어떤 개체 타입의 모든 개체가 반드시 관계를 이루는 다른 개체 타입의 개체와 연관되는 것을 의미한다.  예) 회원-국가 간의 국적 관계 - 관계의 참여 제약조건(Participation Constraint) 가운데 의무적(Mandatory) 참여에 해당한다. - 대응 개체 수(min  max)로도 표현하는 경우  min의 값은 ‘1’이 된다.  - ER 다이어그램에서 이중 실선으로 표시한다.  3.   부분 참여와 전체 참여 표현 방법 사원 부서 근무하다 부분 참여 전체 참여 (1  1)  (0  12)  [전체 참여와 부분 참여] 모든 사원은 한 부서에 근무 해야 하지만  부서의 경우 사 원이 한 명도 없는 신설 부서 가 존재함을 나타냄 	1
0000	ER 모델 개요 31 EER  모델 소개 4. EER  모델 소개 (1) EER(Enhanced ER  강화된 ER)이란?  - 보다 완전하고 정확한 모델링을 위해서  기본적인 ER 모델에 몇 가지 새로운 개념을 추가한 것이다. - Extended ER(E2R  EER  확장된 ER) 모델이라고도 칭하며  현재 DB 설계에 널리 사용되고 있다. (2) EER 모델의 특징 - 기본적인 ER 모델의 모든 모델링 개념을 포함한다. - 서브타입(Subtype)/슈퍼타입(Super type)  세분화(Specialization)/일반화(Generalization)  카테고리(Category)  속성 상속(Attribute Inheritance)등의 개념이 추가되었다. - 상속(Inheritance)과 같은 객체지향 개념을 일부 포함한다.   	1
0000	ER 모델 개요 32 EER  모델 소개 (3) 서브타입과 슈퍼타입 개체 ① 서브타입(Subtype) 개체란?  - 한 개체 타입에 속하는 개체들을 어떤 기준에 의해 몇 개의 소규모 그룹으로 나눈 것을 원래 개체의 서브 타입 개체라고 칭한다. - 서브 타입 개체는 원래 개체 타입의 하위 개체 타입이며  부분 집합이다.  - 예:  개체 타입 :  학생 서브타입 개체 :  학부생  대학원생 개체 타입 :   학부생 서브타입 개체 :   여학생  남학생 개체 타입 :   남학생 서브타입 개체 :   군필자  군미필자 ② 슈퍼타입(Super type) 개체란?  - 여러 개체 타입이 속하는 상위의 개체 타입을 슈퍼 타입 개체라고 칭한다. - 예:   개체 타입 : 교수  조교  직원 슈퍼타입 개체 : 교직원 개체 타입 : 교직원  재학생  졸업생 슈퍼타입 개체 : 사람 교직원은 교수  직원  조교의 슈퍼타입이지만  사람의 서브 타입이다. 즉  슈퍼타입인지 서브타입인지는 상대적으로 결정된다. 학생은 학부생과 대학원생의 슈퍼타입 개체가 된다.  	1
0000	ER 모델 개요 33 EER  모델 소개 ③ 슈퍼-서브 관계(또는 IS-A 관계) 표현 - ER 다이어그램에서 작은 역삼각형(∇) 또는 작은 원(● 혹은 ○)으로 표현한다.       사람 재학생 졸업생 교직원 주민등록번호 이름 연락처 교수 조교 직원 졸업연도 직장 학번 학과 직급 담당업무 입사일 급여 지원과목 소속 	1
0000	ER 모델 개요 34 EER  모델 소개  9개의 슈퍼-서브 관계가 존재함 : ① 사람과 재학생 사이 (A student is a human being.) ② 사람과 졸업생 사이 ③ 사람과 교직원 사이 ④ 교직원과 교수 사이 ⑤ 교직원과 조교 사이 ⑥ 교직원과 직원 사이 ⑦ 사람과 교수 사이 (슈퍼타입의 슈퍼타입도 역시 슈퍼타입이다.) ⑧ 사람과 조교 사이 ⑨ 사람과 직원 사이 ④ 속성 상속(Inheritance)  - 서브타입 개체는 슈퍼타입 개체의 모든 속성을 상속받는다. - 예: 교수 개체의 속성은 직급이라는 고유 속성 외에 주민등록번호  이름  연락처  소속  입사일   급여와 같은 속성을 2개의 슈퍼 타입 개체로 부터 상속받아 포함하게 된다.  슈퍼-서브 관계를 IS-A 관계로 칭하는 것은 이 “is a “ 서술어 에서 인용된 것이다.  	1
0000	ER 모델 개요 35 EER  모델 소개 (4) 세분화와 일반화 개념 ① 세분화(Specialization)란?  - 한 개체 타입에 속하는 서브타입을 결정하는 작업을 세분화 또는 특수화라고 칭한다.  - 일정한 기준에 따라 몇 가지 서브타입으로 나누고  각 서브타입의 이름과 고유 속성을 결정한다.  Top-down 방식의 모델링 - 세분화를 통해서 현실 세계를 보다 정교하게 모델링하여  널 값을 갖는 속성을 최소화시킬 수 있다.  - 예:  {교수  조교  직원}는 업무 유형에 따라 교직원을 세분화한 것임 - 하나의 개체 타입에 대해 필요에 따라 여러 가지 세분화가 가능하다.  예)  {정규직직원  계약직지원}은 계약 유형에 따라 교직원을 세분화한 것임 - 세분화에 따라 서브타입 개체는 다른 서브타입 개체가 갖고 있지 않는 고유한 속성을 가져야 한다. 예) 교수는 직급 속성  조교는 지원과목 속성  직원은 담당업무라는 고유 속성을 가짐 슈퍼타입 개체 서브타입 개체 세분화 교직원 교수 조교 직원 Top-down 교수  조교  직원 이 하나의 서브타 입군(群)이 됨 	1
0000	ER 모델 개요 36 EER  모델 소개 ② 일반화(Generalization)란?   - 세분화와는 반대로  여러 개체 타입들의 슈퍼타입을 결정하는 작업을 일반화라고 칭한다.  - 즉  여러 개체 타입의 공통점만 수집해서  그 공통점에 근거해서 새로운 슈퍼타입을 만드는 것으로  모델링을 단순화시킬 수 있다.  Bottom-up 방식의 모델링 - 예:  승용차  트럭  버스 개체 타입은 ‘운송수단’으로 일반화할 수 있다.  슈퍼타입 개체 서브타입 개체 일반화 운송수단 승용차 트럭 버스 Bottom-up 	1
0000	ER 모델 개요 37 EER  모델 소개 (5) 카테고리 개념 ① 카테고리(Category) 란?  - 별개의 개체 타입의 집합을 카테고리 또는 합집합(Union) 타입이라 칭한다. 예) 차량 소유주 카테고리 – {사람  회사  은행}  -> 차량 등록 DB에서 차량 소유주는 사람이나 회사  은행(담보물로 소유함)이 될 수 있고  실제로 DB에 등록되는 차량 소유주는 사람  회사  은행의 합집합의 부분 집합에 해당한다. - ER 다이어그램에서 작은 삼각형 혹은 원 안에 Union의 첫 자인 ‘U’자를 표시해서 표현한다.  예) 차량 소유주 카테고리 - 하나 이상의 슈퍼타입 개체와 단 하나의 서브타입 개체가 슈퍼-서브 관계를 갖는 상황을 모델링 할 때 유용하다.    - 카테고리에 속하는 멤버(member)는 슈퍼타입 개체 가운데 하나에 속해야 한다.  차량 소유주 사람 회사 은행 U 슈퍼타입 개체 카테고리(서브타입 개체) 	1
0000	ER 모델 개요 38 쉼터 쉼터 우리에게 필요한 지식은 엄격한 정보가 아니라 생각하는 힘입니다.  현학적인 수사가 아니라 마음을 움직이는 메시지입니다. 빈틈없는 논리가 아니라 비어 있는 공간입니다. 사고를 구속하는 것이 아니라 더욱 자유롭게 하는 것입니다.  엄격하게 구분 짓는 잣대가 아니라 경계를 넘나드는 이해입니다. 말하는 쪽의 입이 아니라 듣는 쪽의 귀입니다. 책 속의 깨알 같은 글씨가 아니라 책을 쥔 손에 맺힌 작은 땀방울입니다. 머리를 높게 하는 것이 아니라 마음을 낮게 하는 것입니다. 	1
0000	데이터베이스 데이터베이스 6 회차 : 관계 데이터 모델 김 은 경 	1
0000	관계 데이터 모델 2 학습목표 동기유발 & 학습목표 학습내용 1. 관계 데이터 모델 이해 학습목표 2. 키(Key)와 무결성 제약조건 1. 관계 데이터 모델의 특징을 설명할 수 있다. 2. 관계 데이터 모델의 주요 용어를 설명할 수 있다.  3. 릴레이션의 특징을 나열할 수 있다.  1. 키(Key)의 종류와 특징을 나열할 수 있다. 2. 무결성 제약조건을 3가지로 구분해서 설명할 수 있다.   	1
0000	관계 데이터 모델 3 Lesson.  관계 데이터 모델 이해 1. 관계 데이터 모델이란?  2. 주요 용어들 3. 릴레이션의 개념 4. 릴레이션의 특징 관계 데이터 모델이란?  	1
0000	관계 데이터 모델 4 관계 데이터 모델의 특징 1. 관계 데이터 모델이란?  (1) 관계 데이터 모델의 정의 - DB를 2차원 테이블(Table) 즉  릴레이션(Relation)의 집합으로 모델링하는 논리적 데이터 구조이다. - 1970년 E. F. Codd 박사가 처음 제안한 모델로서  현재 가장 많은 DBMS가 기초로 하고 있는 논리적 데이터 모델이다. 예) 사원 개체를 표현한 관계 데이터 모델 사번 이름 입사일 호봉 휴대폰 1101 1102 1103 1201 1202 1203 1312 1314 김정아 이기원 박영종 최강희 조현수 박제성 김민수 이정숙 1995-03-01 1997-01-01 2005-09-01 1994-02-01 2007-03-15 1999-09-01 2011-03-01 2011-03-01 20 18 15 21 14 17 10 10 010-3452-0022 011-3478-1287 010-3214-1234 010-1122-3344 010-5566-4321 019-3452-3457 011-2340-0023 010-3420-0991 사원 릴레이션 (2) 관계 데이터 모델의 특징 ① 개체와 관계가 모두 2차원 테이블(릴레이션)로 표현된다. ② ER 모델을 관계 데이터 모델로 변형하는 것이 매우 쉽다. 	1
0000	관계 데이터 모델 5 관계 데이터 모델의 특징 ▶ 릴레이션과 테이블의 차이점 ① 릴레이션은 추상적인 개념(Abstract concept)이다. ② 테이블은 릴레이션을 표현하는 구체적인 표현(Concrete representation)방법이다. -> 하나의 릴레이션은 여러 가지 형태의 테이블로 표현될 수 있다. ③ 테이블은 중복되는 행을 허용하지만  릴레이션은 중복되는 행을 허용하지 않는다. 이 내용을 8번 슬라이드에 풍선 도움말 형태로 표시 바람 	1
0000	관계 데이터 모델 6 [참고]  [참고] 관계 DB 이론의 창시자인 E. F. Codd 박사 이야기 E. F. Codd 박사(1923는~ 2003)는 1970년 6월 ACM(Association of Computer Machinery)의 Communications of the ACM＇이라는 잡지에 “A Relational Model of Data for Large Shared Data Banks”라 는 논문을 발표했는데  이 논문에서 DB 시스템을 위한 관계 데이터 모델을 처음으로 제안했으며  이 모델은 현재 관계형 데이터베이스 관리시스템(RDBMS)의 표준적인 모델로서 인정 받고 있다. 그 당시 계층 및 네트워크 데이터 모델이 더 많이 알려진 모델이었으나  Codd 박사가 제안한 관계 데이터 모델 이 갖는 여러 가지 장점 때문에 짧은 시간 안에 널리 알려지게 되었고  많은 DBMS 업체들이 이 관계 데이터 모 델을 기초로 DBMS를 개발하게 되어 현재에 이르기까지 가장 널리 사용되고 있다. - E. F. Codd 박사(1923 ~ 2003)  	1
0000	관계 데이터 모델 7 2. 주요 용어들 - 관계 데이터 모델과 관련한 주요 용어에는 다음과 같은 것이 있다.  주요 용어들 * 원자 값(Atomic Value) – 더 이 상 분해할 수 없는 값이 다. * Not Null – Null 값을 허용하지 않는 것. 즉 공백을 허 용하지 않고  반드시 값 이 존재해야 함을 나타 내는 값이다. 용어 의미 튜플(Tuple)  릴레이션의 각 행(Row)으로서  개체(Entity)에 대응한다.  속성(Attribute)  릴레이션의 각 열(Column)로서  이름을 가진 정보의 가장 작은 논리적인 단위이다.  도메인(Domain)  한 속성이 취할 수 있는 모든 원자 값의 집합을 의미한다.  (데이터 타입  크기  형식  제한 범위  Not Null 여부 등으로 정의함) 기수(Cardinality) 하나의 릴레이션이 갖는 튜플의 수를 의미한다. 차수(Degree)  하나의 릴레이션이 갖는 속성의 수를 의미한다. 릴레이션 스키마 (Relation Schema)  릴레이션을 구성하는 속성들의 집합을 의미한다. 릴레이션 인스턴스 (Relation Instance) 릴레이션을 구성하는 튜플들의 집합을 의미한다. 릴레이션(Relation) 행과 열로 구성된 2차원 구조로서  릴레이션 스키마와 릴레이션 인스턴스가 합쳐진 개념이다.  (릴레이션 스키마 + 릴레이션 인스턴스) 키(Key)  튜플들을 유일(Unique)하게 식별할 수 있는 속성  또는 속성들의 집합 을 의미한다.  	1
0000	관계 데이터 모델 사번 이름 입사일 호봉 휴대폰 1101 1102 1103 1201 1202 1203 1312 1314 김정아 이기원 박영종 최강희 조현수 박제성 김민수 이정숙 1995-03-01 1997-01-01 2005-09-01 1994-02-01 2007-03-15 1999-09-01 2011-03-01 2011-03-01 20 18 15 21 14 17 10 10 010-3452-0022 011-3478-1287 010-3214-1234 010-1122-3344 010-5566-4321 019-3452-3457 011-2340-0023 010-3420-0991 8 [예제] 사원 릴레이션에서 주요 용어 확인하기 주요 용어들 사원 릴레이션 속성 튜플 1) 사원 릴레이션 스키마 :    사원 = {사번  이름  직책  부서번호  호봉}   또는 간단히 사원(사번  이름  직책  부서번호  호봉)으로 표현한다. 2) 사원 릴레이션의 튜플 수 : 8 3) 릴레이션 인스턴스 : 8개의 튜플로 구성된다. 즉  {(1101  김정아  부장  100  20)  …  (1314  이정숙  사원  200  10)} 4) 사번의 도메인 : 4자리 정수 5) 사원 릴레이션의 기수 : 8   (튜플의 수) 6) 사원 릴레이션의 차수 : 5   (속성의 수)  7) 키(Key) : 사번  휴대폰 릴레이션 스키마 릴레이션 인스턴스 	1
0000	관계 데이터 모델 9 3. 릴레이션의 개념 (1)  릴레이션(Relation)이란?  - 행(Row)과 열(Column)로 구성된 2차원 구조로서  각 행은 튜플이고  각 열은 속성이다.  - 릴레이션 스키마와 릴레이션 인스턴스가 합쳐진 개념이다.  (릴레이션 스키마 + 릴레이션 인스턴스) (2)  릴레이션 스키마(Relation Schema)란?  - 릴레이션을 구성하는 속성들의 집합을 의미한다.  - 릴레이션 내포(Intension) 또는 릴레이션 스킴(Scheme)이라고도 칭한다.  - “릴레이션 이름 + 속성 이름”으로 표현한다.  ;    R : 릴레이션 이름   A : 속성 이름  D :도메인 - 릴레이션의 정적인 성질이다.  ① 시간이 지나도 자주 변경되지 않는다. (시간과 무관한 정적 성질) ② 릴레이션 타입과 같은 의미이다.  릴레이션의 개념 R(A1  A2  ...   An)     Ai ⇔ Di  = R({A1  A2  ...   An})  	1
0000	관계 데이터 모델 10 (2)  릴레이션 인스턴스(Relation  Instance)란?  - 릴레이션을 구성하는 튜플들의 집합을 의미한다.  - 릴레이션 외포(extension)라고도 칭한다.  - 릴레이션의 내용  즉 어느 한 시점에 릴레이션 R이 포함하고 있는 튜플들의 집합이다.  ;    V : 속성 값   D :도메인 - 릴레이션의 동적인 성질이다.  ① 삽입  삭제  갱신으로 인해 시간에 따라 변경된다. ② 릴레이션의 값을 의미이다.  - 그냥 릴레이션이라고 하면  릴레이션 인스턴스를 의미한다.  릴레이션의 개념 {< V1  V2  ...   Vn >}       Vi ∈ Di 	1
0000	관계 데이터 모델 11 (3)  릴레이션의 정의 1) 수학적 정의 - 릴레이션 R은 다음과 같이 모든 도메인의 카티션 프로덕트(Cartesian Product)의 부분집합으로 정의할 수 있다. 릴레이션의 개념 * 카티션 프로덕트(Cartesian Product) – 두 릴레이션의 조합 가능한 모든 릴레이션을 구하기 위한 집합 연산자이다. R ⊆ D1 × D2 × ... × Dn (단 Di :  i 번째 속성의 도메인) 1101 1102 1103 100 200 <1101  100> <1101  200> <1102  100> <1102  200> <1103  100> <1103  200> 사번 부서번호 사번 ⅹ부서번호 [사번과 부서번호의 카티션 프로덕트 결과] ] [사원 릴레이션에 실제로 포함된 튜플 값]  <1101  100> <1102  200> <1103  200> 부분 집합 	1
0000	관계 데이터 모델 12 2) 개념적 정의 - 릴레이션은 릴레이션 스키마와 릴레이션 인스턴스가 합쳐진 개념이다.  릴레이션의 개념 릴레이션 =  릴레이션 스키마 + 릴레이션 인스턴스 	1
0000	관계 데이터 모델 13 4. 릴레이션의 특성 1) 튜플의 유일성 - 하나의 릴레이션에 포함된 튜플들은 모두서로 달라야 한다. - 즉  중복된 튜플이 존재하지 않는 튜플들의 집합(Set)이다.  릴레이션에는 항상 튜플을 유일하게 식별할 수 있는 키(key)가 존재해야 한다. 2) 튜플의 무순서성 - 하나의 릴레이션에서 튜플들의 순서(order)는 아무런 의미가 없다.  순서만 다른 튜플들로 구성된 릴레이션은 다른 릴레이션이 될 수 없다. 3) 속성의 무순서성 - 하나의 릴레이션에서 속성들의 순서는 아무런 의미가 없다.  속성은 순서가 아니라 ‘이름’(예: 사번  부서번호 등)에 의해서 참조된다. 4) 속성의 유일성 - 하나의 릴레이션에는 같은 이름을 갖는 속성은 존재할 수 없다. 5) 속성의 원자성 - 모든 속성은 반드시 원자 값(Atomic Value)을 가져야 한다.  속성 값은 논리적으로 더 이상 분리될 수 없으며  여러 개의 값을 갖는 속성은 직접 표현할 수 없다. - 널(Null) 값도 원자 값으로 간주한다. 릴레이션의 특성 [참고] 수학적 “집합”의 성질 : {a  b  c} = {c  b  a} [원자성에 대한 보충 설명]  성명은 성(Last name)과 명(First name)으로 분리될 수 있으나   이런 분리가 필요하다면 성과 명이 처음부터 별개의 속성으로 설계되어야 하며  성명이 하나의 속성으로 설계되면 그 값은 더 이상 분리될 수 없는 원자 값이 된다. 	1
0000	관계 데이터 모델 14 Lesson.   키(Key)와 무결성 제약조건 1. 관계 DB란?   2. 키(Key)  3. 무결성 제약조건 키(Key)와 무결성 제약조건 	1
0000	관계 데이터 모델 15 1. 관계 DB란?  관계 DB란?  (1)  관계 DB의 구성 - 관계 DB는 릴레이션(테이블)들의 집합으로 구성된다. - 시간에 따라 내용이 변할 수 있는 테이블 형태로 DB를 표현한다.  (2) 관계 DB 스키마 - 관계 DB 스키마는 릴레이션 스키마와 무결성 제약조건으로 정의된다. - 즉  관계 DB를 정의하기 위해서는 릴레이션 스키마만으로는 충분하지 않으며  반드시 무결성 제약조건도 함께 정의해야 한다. * 무결성 제약조건 – 데이터의 정확성과 일관성 유지를 위 해 DB가 항상 만족시켜야 하 는 조건을 의미한다.  {릴레이션 스키마} + {무결성 제약조건} 	1
0000	관계 데이터 모델 16 관계 DB란?  (3) 관계 DB 사례: A라는 회사 DB를 구성하는 3개의 릴레이션 1) 릴레이션 스키마 사원(사번  이름  입사일  호봉  휴대폰) 부서(부서번호  부서명  부서장  사무실  전화번호) 근무(사번   부서번호   직책)  2)  릴레이션 (릴레이션 스키마 + 릴레이션 인스턴스)  사번 이름 입사일 호봉 휴대폰 1101 1102 1103 1201 1202 1203 1312 1314 김정아 이기원 박영종 최강희 조현수 박제성 김민수 이정숙 1995-03-01 1997-01-01 2005-09-01 1994-02-01 2007-03-15 1999-09-01 2011-03-01 2011-03-01 20 18 15 21 14 17 10 10 010-3452-0022 011-3478-1287 010-3214-1234 010-1122-3344 010-5566-4321 019-3452-3457 011-2340-0023 010-3420-0991 사원 릴레이션 밑줄 표시는 사번이 키임을 나타냄 밑줄 표시는 사번이 키(Key)임을 나타냄 릴레이션 스키마 릴레이션 인스턴스 	1
0000	관계 데이터 모델 17 관계 DB란?  부서 릴레이션 부서번호 부서명 부서장 사무실 전화번호 100 200 300 400 500 기획실 비서실 총무부 인사부 자재부 1101 1102 1201 1203 A402 A501 B311 B201 A102 02-233-1233 02-455-1221 041-567-3454 041-344-6776 02-458-45012 근무 릴레이션 사번 부서번호 직책 1101 1102 1103 1201 1202 1203 1312 1314 100 200 200 300 300 400 100 400 부장 과장 대리 부장 대리 과장 사원 사원 릴레이션 스키마 릴레이션 인스턴스 릴레이션 스키마 릴레이션 인스턴스 	1
0000	관계 데이터 모델 18 2. 키(Key) 키(Key) (1) 키(Key)란?  - 릴레이션을 구성하는 튜플들을 유일(Unique)하게 식별할 수 있는 속성  또는 속성들의 집합이다.  (2) 키의 종류 종류 특징 후보 키 (Candidate Key)  키 가운데 유일성 (Uniqueness)과 최소성(Minimality)을 만족하는 속성 집합 슈퍼 키 (Super Key)  유일성은 만족하지만 최소성이 만족되지 않는 속성 집합 기본 키 (Primary Key)  - 후보 키 가운데 업무에 적합하게 선택된 하나의 키 (대개 DB 설계자가 지정함) - 널 값을 가질 수 없고  중복되지 않는 유효한 값을 가져야 함 대체 키 (Alternative Key)  기본 키를 제외한 나머지 후보 키들 외래 키 (Foreign Key)  릴레이션 간의 관계를 정의하는 키로서  하위 릴레이션(참조 릴레이션) 에서 상위 릴레이션(피참조 릴레이션)의 기본 키를 외래 키로 포함하게 됨 	1
0000	관계 데이터 모델 19 키(Key) (3) 후보 키(Candidate  Key)란?  - 릴레이션 R(A1  A2  ...  An)의 전체 속성 집합 A의 부분 집합이면서   유일성 (Uniqueness)과 최소성(Minimality)을 만족하는 속성 집합 K({Ai   Aj   ...  Ak}) 이다.  ① 유일성 : 각각의 튜플을 유일하게 식별할 수 있는 것 ② 최소성: 각각의 튜플을 유일하게 식별하는데 필요한 최소 속성만 포함하는 것 (즉  키가 하나 이상의 속성으로 구성되어 있을 때  어떤 속성을 제거해도 유일성을 만족하는 경우  최소성이 만족되지 않는 것임)      - 예: 사원 릴레이션의 후보 키: 사번 속성  휴대폰 속성 (이름과 입사일  호봉 속성은 유일성을 만족하지 않고   {사번  이름}  {사번  호봉} 등의 속성 집합은 최소성을 만족하지 않기 때문에 후보 키가 될 수 없음)  사원 릴레이션 사번 이름 입사일 호봉 휴대폰 1101 1102 1103 1201 1202 1203 1312 1314 김정아 이기원 박영종 최강희 조현수 박제성 김민수 이정숙 1995-03-01 1997-01-01 2005-09-01 1994-02-01 2007-03-15 1999-09-01 2011-03-01 2011-03-01 20 18 15 21 14 17 10 10 010-3452-0022 011-3478-1287 010-3214-1234 010-1122-3344 010-5566-4321 019-3452-3457 011-2340-0023 010-3420-0991  모든 릴레이션은 최소 한 개 이상의 후보 키가 있어야 한다.   	1
0000	관계 데이터 모델 20 키(Key)  (4) 외래 키(Foreign  Key)란?  - 릴레이션 R의 어떤 속성 집합 FK가 릴레이션 S의 기본 키일 때  FK를 릴레이션 R의 외래 키라고 한다. 1) 외래 키의 특징 - 외래 키의 도메인은 릴레이션 S의 기본 키의 도메인과 동일하다.  - 외래 키의 값은 릴레이션 S에 존재하는 값이거나 널 값을 가질 수 있다. - 하나 이상의 테이블을 연결해서 사용하는 경우 필요한 키이다.  - 릴레이션 R과 S가 동일한 릴레이션인 경우도 있다.  2) 참조 릴레이션과 피참조 릴레이션 - 외래 키를 포함하는 릴레이션 R을 참조 릴레이션(Referencing Relation)  외래 키가 참조하는 기본 키를 포함하는 릴레이션 S를 피참조 릴레이션(Referenced Relation)이라 칭한다.  릴레이션 R은 외래 키(FK)를 통해 릴레이션 S를 참조한다.  	1
0000	관계 데이터 모델 21 키(Key)  3) 외래 키의 유형 ① 다른 릴레이션의 기본 키를 참조하는 외래 키 사원_1 릴레이션 사번 이름 담당업무 부서번호 1101 1102 1103 1201 1203 김정아 이기원 박영종 최강희 조현수 기획 비서실장 비서 회계 인사 100 200 200 300 400 부서 릴레이션 부서번호 부서명 사무실 100 200 300 400 기획실 비서실 총무부 인사부 A402 A501 B311 B201 기본 키 외래 키 기본 키 [다른 릴레이션의 기본 키를 참조하는 외래 키] 부서 릴레이션의 기본 키인 부서번호를 참조함 	1
0000	관계 데이터 모델 22 키(Key)  ② 동일한 릴레이션의 기본 키를 참조하는 외래 키 사원_2 릴레이션 사번 이름 관리자 부서번호 1101 1102 1103 1201 1203 김정아 이기원 박영종 최강희 조현수 1203 1101 1201 1102 100 200 200 300 400 기본 키 외래 키 [동일 릴레이션의 기본 키를 참조하는 외래 키] 동일한 릴레이션인 사원_2 릴레 이션의 기본 키인 사번을 참조함 	1
0000	관계 데이터 모델 23 키(Key)  ③ 기본 키의 구성 요소가 되는 외래 키 사원 릴레이션 사번 이름 … 1101 1102 1103 1201 1203 김정아 이기원 박영종 최강희 조현수 … … … … … 부서 릴레이션 부서번호 부서명 … 100 200 300 400 기획실 비서실 총무부 인사부 … … … … 기본 키 기본 키 [기본 키의 구성 요소가 되는 외래 키] 사번 부서번호 직책 1101 1102 1103 1201 1203 100 200 200 300 400 부장 과장 대리 부장 과장 근무 릴레이션 외래 키 외래 키 합쳐서 기본 키 근무 릴레이션의 기본 키는 2개 속성 의 집합인 {사번  부서번호}임 	1
0000	관계 데이터 모델 24 (5) 예제 – 학생 릴레이션과 교수 릴레이션에서 본 여러 가지 키들 키(Key)  학생 릴레이션 교수 릴레이션 교수번호 이름 연구실 휴대폰 01223 02355 05378 장경구 김민숙 이장수 A112 B344 A322 010-9876-2121 010-1234-5678 010-2266-9988 학번 주민등록번호 이름 주소 휴대폰 지도교수 98201002 99202012 98201025 800321 811123 810923 김정욱 이기원 박문구 천안 서울 대전 010-2233-0495 010-2200-0045 010-2341-2312 01223 02355 01223 	1
0000	관계 데이터 모델 25 키(Key)  1) 키 : 주민등록번호  학번  휴대폰 (주민등록번호  이름)  (학번  이름)  (휴대폰  이름) (주민등록번호  주소)  (학번  주소)  (휴대폰  주소)  (주민등록번호  나이) 등 2) 후보 키 :  주민등록번호  학번  휴대폰 ; 키 가운데 이 세가지를 제외하고는 유일성은 만족되지만 최소성이 만족되지 않는다. 예를 들면  (주민등록번호  이름) 키의 경우  ‘이름’을 제거해도 유일성이 만족되므로 최소성을 만족하지 않는 것이다. 3) 기본 키 : 주민등록번호나 학번  휴대폰 가운데 하나를 업무의 특성에 맞게 선택한다. ; 단  휴대폰이 없는 사람이 있는 경우  휴대폰은 널 값을 가질 수 있으므로 기본 키가 될 수 없다. 4) 외래 키 : 지도교수 ; 이 속성은 남학생의 지도교수 이름을 검색할 때  교수 릴레이션의 기본 키(교수번호)를 참조하게 되므로 외래 키이다. 지도교수가 배정되지 않은 학생의 경우 널 값을 갖게 된다. 	1
0000	관계 데이터 모델 26 3. 무결성 제약조건 무결성 제약조건 (1) 무결성 제약조건(Integrity Constraints) 이란?  - DB에 저장된 데이터의 정확성과 일관성 유지를 위해서 DB가 항상 만족해야 하는 조건을 의미한다.  (2) 무결성 제약 조건의 중요성 - 사용자에 의한 DB 갱신이 DB의 일관성을 깨지 않도록 보장하는 수단이 된다. - 즉  DB의 상태가 현실 세계에서 허용되는 상태만 나타낼 수 있도록 보장하는 수단이 된다. (3) 관계 데이터 모델의 무결성 제약조건 ① 개체 무결성(Entity Integrity) - “기본 키는 튜플들을 유일하게 식별하기 위해서 널 값을 가질 수 없다.”는 제약 조건을 뜻한다.  튜플을 유일하게 식별하기 위해서 기본 키는 반드시 값을 가져야 함을 의미한다. 예) 회원 가입 시에 ‘주민등록번호’를 입력하지 않으면 회원 가입을 할 수 없는 것은 주민등록번호가 회원 개체의 기본 키이기 때문이다. 	1
0000	관계 데이터 모델 27 무결성 제약조건 ② 참조 무결성(Referential Integrity) - “외래 키는 반드시 피참조 릴레이션의 기본 키 값이나 널 값을 가져야 한다.“는 제약 조건을 뜻한다.  외래 키는 대응하지 않는 값을 가질 수 없으며  이를 위배하는 경우 두 릴레이션은 서로 참조될 수 없음을 의미한다. 예) 앞의 예제에서  교수 릴레이션에 없는 ‘교수번호’ 속성 값이 학생 릴레이션의 ‘지도교수’ 속성 값이 될 수 없다. ③ 의미 무결성(Semantic Integrity) - “특정 속성은 반드시 미리 정해진 값을 가져야 한다.“는 제약 조건을 뜻한다.  반드시 허용되는 값을 가져야 함을 의미한다. 예) 대학생의 학년 속성은 1 ~ 4 값만 가질 수 있다. 예) 대학생의 평점 속성은 0부터 5 사이의 숫자 값만 가질 수 있다. 	1
0000	관계 데이터 모델 28 무결성 제약조건 (4) 무결성 제약조건 정의 방법 - 일관된 DB 상태를 정의하는 규칙들을 묵시적 또는 명시적으로 정의한다. ① 묵시적 정의 - 릴레이션을 정의할 때 기본 키와 외래 키를 정의하면  개체 무결성과 참조 무결성이 묵시적으로 정의된다.  DB가 갱신될 때마다 DBMS가 자동으로 제약조건의 만족 여부를 검사하므로 응용 프로그램에서 별도로 검사할 필요가 없다. ② 명시적 정의 - 개체 무결성과 참조 무결성 이외에  데이터의 정확성과 일관성 유지를 위해서 특정 속성이 만족해야 하는 의미 무결성 제약조건은 명시적으로 정의해야 한다.  널 값 허용 여부(NOT NULL 제약조건)  고유 값 여부(UNIQUE 제약조건)  속성 값이 만족 해야 하는 특정 조건(CHECK 제약조건) 등의 제약조건은 릴레이션을 생성할 때 정의한다.  이렇게 정의된 무결성 제약조건 역시 DB가 갱신될 때마다 DBMS가 자동으로 제약조건의 만족 여부를 검사하므로 응용 프로그램에서 별도로 처리할 필요가 없다. - DBMS가 자동으로 처리하는 제약조건 외에 특수한 제약조건은 응용 프로그램에서 별도로 처리해야 하는 경우도 있다. 	1
0000	관계 데이터 모델 29 무결성 제약조건 (5) 무결성 제약조건 정의 사례 : A라는 회사의 관계 DB 스키마를 위한 명시적 무결성 제약조건 정의 1) 사원 릴레이션 ① 이름과 입사일  호봉  휴대폰 번호는 널 값을 가질 수 없다. (NOT NULL 제약조건) ② 휴대폰은 유일한 값을 가져야 한다. (UNIQUE 제약조건) ③ 호봉은 1부터 30 사이의 정수 값만 가질 수 있다. (CHECK 제약조건) 2) 부서 릴레이션 ① 부서명과 전화번호는 널 값을 가질 수 없다. (NOT NULL 제약조건) ② 사무실은 유일한 값을 가져야 한다. (UNIQUE 제약조건) 3) 근무 릴레이션 ① 직책은 널 값을 가질 수 없다. (NOT NULL 제약조건) 	1
0000	관계 데이터 모델 30 쉼터 쉼터 성공이란 무엇인가?  자주 그리고 많이 웃는 것 현명한 이에게 존경을 받고 아이들에게 사랑을 받는 것 정직한 비평가로부터 찬사를 듣고  친구의 배반을 참아내는 것 아름다움을 식별할 줄 알며  다른 사람의 좋은 점을 알아보는 것 건강한 아이를 낳든  한 뙈기의 정원을 가꾸든  사회 환경을 개선하든  자기가 태어나기 전보다 세상을 조금이라도 좋은 곳으로 만들어 놓고 떠나는 것 자신이 한때 이곳에 살았음으로 해서 단 하나의 다른 사람의 인생이라도 행복해지는 것 이것이 진정한 성공이다.  - 랠프 월도 에머슨 (미국의 사상가이자 시인)  	1
0000	데이터베이스 데이터베이스 - Story Board - 7 회차 : SQL 언어 	1
0000	SQL  언어 2 Lesson.  SQL 데이터 정의어와 데이터 제어어 1. SQL 언어 개요 2. SQL 데이터 정의어 3. SQL 데이터 제어어 SQL 데이터 정의어와 데이터 제어어 	1
0000	SQL  언어 3 SQL 언어 개요 SEQUEL – 1974년  IBM의 실험 적 관계 DB인 SYSTEM R 의 인터페이스로서 구현된 언어\이 다. 1. SQL 언어 개요 (1) SQL이란?   - “Structured Query Language(구조화된 질의어)”의 약자로  1974년 IBM 연구소에서 발표한 SEQUEL(Structured English QUEry Language)에서 유래한 데이터 언어이다. - 현재 미국표준연구소(ANSI)와 국제표준기구(ISO)에게 관계 DB의 표준 언어로 채택하고 있다. - 상용 DBMS인 IBM의 DB2와 SQL/DS뿐만 아니라  ORACLE  INFORMIX  SYBASE 등과 같은 거의 모든 회사에서 채택하고 있는 언어이다. (2) 표준 SQL의 변화 ①1986년 표준 언어로 채택: SQL-86 또는 SQL1이라 칭함 ② 1992년 개정: SQL/92  SQL-92 또는 SQL2라 칭함 ③ 1999년 개정: SQL3 또는 SQL-99라 칭함 ④ 2003년 개정: 가장 최신 버전으로  SQL4 또는 SQL-2003이라 칭하며   객체 개념을 지원하는 기능이 추가됨 	1
0000	SQL  언어 4 SQL 언어 개요 * 관계 대수 –원하는 데이터를 어떻게 검색할 것인가를 기술하 는 절차적 언어이다.  * 관계 해석 – 원하는 데이터만 명시하고  어떻게 검색할 지는 기술하지 않는 선언적 언어이다.  (3) SQL의 특징 ① 단순히 검색만을 위한 데이터 질의어가 아니라  데이터 정의어(DDL)  데이터 조작어(DML)  데이터 제어어(DCL)의 기능을 모두 제공하는 종합적인 DB 언어이다.  ② 관계 데이터 모델의 데이터 연산 언어인 관계 대수와 관계 해석을 기초로 하는 고급 데이터 언어 이다. ③ 데이터 연산에 대한 처리 과정은 명시하지 않고  데이터 연산의 결과만을 명시하는 비절차적 언어 즉  선언적 언어이므로  사용자 편의 중심의 언어이다.  ④ SQL의 표준화로 인해 상용 관계 DBMS들 간의 전환이 용이하다. ⑤ 단말기(Terminal)에서 단독으로 대화식 질의어로 사용할 수 있다.  ⑥ 자바  C/C++ 등으로 개발된 응용 프로그램에 삽입해서 사용할 수 있다. ⑦ 개개의 레코드(튜플) 단위로 처리하기 보다는 레코드의 집합 단위로 처리한다.   ⑧ 릴레이션  튜플  속성 등과 같은 관계 데이터 모델의 공식 용어 대신  테이블  행  열과 같은 일반적인 용어를 사용한다.  	1
0000	SQL  언어 5 SQL 데이터 정의어 2. SQL 데이터 정의어 (1) 데이터 정의어(DDL: Data Definition Language)란?   - DB 객체의 구조를 정의하거나 변경 또는 삭제하기 위해 사용하는 언어이다. (2) DB 객체란?   - 생성된 DB를 효율적으로 관리하고 동작하게 만드는 요소로서  논리적인 데이터 저장 구조이며  스키마 객체라고도 칭한다. - DB 객체의 종류에는 테이블(Table)  뷰(View)  시퀀스(Sequence)  인덱스(Index)  동의어 (Synonym) 등이 있다.   DB 객체 특징 테이블(Table) 행과 열로 구성된 기본적인 데이터 저장 영역의 기본 단위이다. 뷰(View) 하나 이상의 테이블 또는 다른 뷰로부터 유도된 논리적 관점에서의 가상 테이블이다. 시퀀스(Sequence) 자동으로 생성되는 유일한(Unique) 일련 번호로서  대개 기본 키 값을 생성하는데 사용된다. 인덱스(Index) DB 검색의 성능 향상을 위해서 만들어지는 데이터 구조이다.   동의어(Synonym) DB 객체의 복잡한 이름을 간단하게 해주기 위해 부여하는 별칭이다.  	1
0000	SQL  언어 6 SQL 데이터 정의어 (3)  데이터 정의어의 명령어 종류 DDL 명령어 역할 CREATE DB(또는 스키마) 및 DB 객체를 생성한다.  ALTER 기존의 DB 객체를 변경한다.  DROP  DB(또는 스키마) 및 DB 객체를 삭제한다.  (4) 테이블의 종류 종류 특징 기본 테이블 (Base Table) - CREATE TABLE 문으로 만들어지는 테이블 - DBMS의 파일로 생성되고 저장됨 가상 테이블 (Virtual Table) - CREATE VIEW 문으로 만들어지는 테이블 - 어떤 기본 테이블로부터 만들어지는 테이블 - 독자적으로 존재할 수 없음 임시 테이블 (Temporary Table) - 질의문 처리 과정의 중간 결과로 만들어지는 테이블 	1
0000	SQL  언어 7 SQL 데이터 정의어 (5) 기본 테이블 생성 1) CREATE TABLE 명령 - 새로운 테이블을 생성하는 명령이다. - 여러 가지 무결성 제약조건을 함께 지정할 수 있다. - 테이블 생성 권한을 가진 사용자만 사용할 수 있는 명령이다.   2) CREATE TABLE 명령의 일반 형식 CREATE  TABLE  기본테이블_이름 ( {열이름 데이터타입 [NOT NULL] [DEFAULT 값] }+ [PRIMARY  KEY  (열이름_리스트) ] {[UNIQUE (열이름_리스트) ]}* {[FOREIGN  KEY(열이름_리스트) REFERENCES 참조테이블_이름[(열이름_리스트)] [ON DELETE   옵션] [ON UPDATE  옵션]  ]} * [CONSTRAINT 제약조건이름]  [CHECK(조건식)] ); 참고하세요 #1 	1
0000	SQL  언어 8 참고하세요 [참고하세요]   SQL 명령의 형식을 기술할 때 사용하는 기호들 1) 중괄호({ }) : 값의 리스트(List)  즉 여러 값을 나열해야 함을 의미한다.  2) 대괄호([ ]) : 생략 가능함(Optional)을 의미한다.  3) + : 괄호 안의 내용이 1번 이상 반복될 수 있음을 의미한다.  즉  최소 1번은 나타나야 함을 의미한다.  4) * : 괄호 안의 내용이 0번 이상 반복될 수 있음을 의미한다.  즉  나타나지 않을 수도 있음을 의미한다.  5) 수직바(|) :  둘 중 하나를 선택하라는 ‘OR’의 의미이다. 	1
0000	SQL  언어 9 SQL 데이터 정의어 3)  각 키워드의 기능 ① NOT NULL: 속성이 널 값을 가질 수 있는지 여부를 설정함 ② DEFAULT : 속성의 디폴트 값을 설정함 ③ PRIMARY KEY: 기본 키(개체 무결성 제약조건)를 설정함 ④ UNIQUE: 속성이 유일한 값을 가져야 한다는 무결성 제약조건을 설정함 ⑤ FOREIGN KEY: 외래 키(참조 무결성 제약조건)를 설정함  SQL에서는 참조된 테이블의 후보 키도 외래 키가 될 수 있음 ⑥ 옵션: NO ACTION  SET NULL  SET DEFAULT  CASCADE 가운데 하나를 설정함 예) ON DELETE SET NULL - 피참조 튜플(열 값)이 삭제되면  널 값으로 갱신하도록 설정함 예) ON UPDATE CASCADE - 피참조 튜플(열 값)이 갱신되면  이 튜플을 참조하는 튜플도 파급적으로 갱신하도록 설정함 ⑦ CONSTRAINT: 제약조건의 이름을 설정함 ⑧ CHECK(조건식): 삽입 또는 갱신 시에 만족해야 하는 무결성 제약조건을 설정함 	1
0000	SQL  언어 10 SQL 데이터 정의어 4)  대표적인 데이터 타입 데이터 타입 특징 NUMBER(p  s) 소수점을 포함해서 20자리까지의 숫자 기억 INT  INTEGER  SMALLINT 정수 기억 CHAR(n) 고정 길이 문자열 기억 VARCHAR(n)  VARCHAR2(n) 가변 길이 문자열 기억 DATE YY/MM/DD 형식의 날짜 기억 TIME hh:mm:ss 형식의 시간 기억 LONG  최대 2기가 바이트까지의 가변 길이 문자 기억 LOGICAL  논리 값(T/F) 기억 	1
0000	SQL  언어 11 SQL 데이터 정의어 5) 기본 테이블 생성 예제 - 사원  부서  근무라는 3개의 테이블을 생성한다.  CREATE   TABLE   사원 ( 사번 INTEGER  이름 CHAR(10)   NOT NULL  입사일 DATE  NOT NULL  호봉 INTEGER   휴대폰 CHAR(13)     PRIMARY KEY(사번)  UNIQUE(휴대폰)    CONSTRAINT  사원_unique_key);   테이블 확인 CREATE   TABLE   부서 ( 부서번호 INTEGER  부서명 CHAR(6)   NOT NULL  부서장 INTEGER  사무실 CHAR(4)   전화번호 CHAR(12)   PRIMARY KEY(부서번호)  UNIQUE(부서명  사무실  전화번호) );   테이블 확인 사번이 사원 테이블 의 기본 키이다. 휴대폰은 널 값을 가질 수는 있 지만  값이 있는 경우 반드시 유 일한 값을 가져야 하며  이 제약 조건에 사원_unique_key라는 이 름을 설정했다.  이름과 입사일은 널 값을 가질 수 없지 만  호봉은 널 값을 가질 수 있다.  	1
0000	SQL  언어 12 SQL 데이터 정의어 CREATE   TABLE   근무 ( 사원번호 INTEGER  부서번호 INTEGER  직책 CHAR(8)  PRIMARY KEY(사원번호  부서번호)  FOREIGN KEY(사원번호) REFERENCES 사원(사번) ON DELETE   CASCADE  ON UPDATE   CASCADE   FOREIGN KEY(부서번호) REFERENCES 부서(부서번호)  ON DELETE   CASCADE  ON UPDATE   CASCADE );  테이블 확인 근무 테이블의 기본 키는 사원번호와 부 서번호의 조합으로 정의했다.  사원번호는 사원 테 이블의 사번을 참조 하는 외래 키로 정 의했다.  	1
0000	SQL  언어 13 [테이블 확인] CREATE  TABLE(크리에이트 테이블) 명령으로 테이블을 생성하면  데이터가 하나도 없는 테이블의 구조만 만들어지며  여기에 제시한 세 개의 테이블은 뒤에서 배울 INSERT(인서트) 명령으로 초기 데이터를 삽입한 상태입니다.  [테이블 확인] 사원 테이블 부서 테이블 부서번호 부서명 부서장 사무실 전화번호 100 200 300 400 500 기획실 비서실 총무부 인사부 자재부 1101 1102 1201 1203 A402 A501 B311 B201 A102 02-233-1233 02-455-1221 041-567-3454 041-344-6776 02-458-45012 사번 이름 입사일 호봉 휴대폰 1101 1102 1103 1201 1202 1203 1312 1314 김정아 이기원 박영종 최강희 조현수 박제성 김민수 이정숙 1995-03-01 1997-01-01 2005-09-01 1994-02-01 2007-03-15 1999-09-01 2011-03-01 2011-03-01 20 18 15 21 14 17 11 11 010-3452-0022 011-3478-1287 010-3214-1234 010-1122-3344 010-5566-4321 019-3452-3457 011-2340-0023 010-3420-0991 근무 릴레이션 사번 부서번호 직책 1101 1102 1103 1201 1202 1203 1312 1314 100 200 200 300 300 400 100 400 부장 과장 대리 부장 대리 과장 사원 사원 	1
0000	SQL  언어 14 SQL 데이터 정의어 DROP  TABLE  기본테이블_이름 { RESTRICT |  CASCADE };  (6) 기본 테이블 삭제 1) DROP TABLE 명령 - 기존의 기본 테이블을 삭제하는 명령이다. - 테이블 구조와 함께 저장된 데이터와 인덱스까지 한꺼번에 삭제한다.  - 테이블을 생성한 사용자 또는 테이블 삭제 권한이 부여된 사용자만 사용할 수 있는 명령이다.   - 삭제 후 복구가 불가능하므로 신중하게 사용해야 한다.  2) DROP TABLE 명령의 일반 형식  RESTRICT 옵션: 이 기본 테이블을 참조하고 있는 뷰나 제약조건이 있으면  이 기본 테이블을 삭제할 수 없다.  CASCADE 옵션: 이 기본 테이블을 참조하고 있는 뷰나 제약조건이 있으면  그 뷰나 제약조건도 함께 모두 삭제한다.  	1
0000	SQL  언어 15 SQL 데이터 정의어 3) 기본 테이블 삭제 예제 - ‘취미’라는 이름의 테이블을 삭제하되  만약 이 테이블을 참조하고 있는 뷰나 제약조건이 있으면 함께 삭제한다.  DROP  TABLE  취미 CASCADE;  [참고]  테이블 구조는 남겨두고 저장된 데이터만 삭제하는 명령은 TRUNCATE TABLE 명령이다.  	1
0000	SQL  언어 16 SQL 데이터 정의어 (7) 기본 테이블 변경 1) ALTER TABLE 명령 - 기존의 기본 테이블의 구조를 변경하는 명령이다. - 구조 변경 허용 범위 :  ① 새로운 열을 추가할 수 있다. (ADD 절) ② 기존 열을 삭제할 수 있다.  (DROP 절)   (열 삭제는 오라클 8i 버전부터 지원함)  ③ 기존 열의 데이터타입을 변경할 수 있다. (MODIFY 절)  ④ 열에 대한 디폴트 값을 삭제하거나 새로 정의할 수 있다.  (MODIFY 절)   ⑤ 새로운 무결성 제약조건을 명시하거나 . 기존 무결성 제약조건을 삭제할 수 있다.  	1
0000	SQL  언어 17 SQL 데이터 정의어 ALTER  TABLE 기본테이블_이름 ([ADD 열이름 데이터타입] [DEFAULT 값] | [DROP 열이름] [무결성 제약조건] [RESTRICT | CASCADE] [MODIFY 열이름 [데이터타입] (DROP DEFAULT | SET DEFAULT  값)]); - 열을 삭제할 때는 반드시 RESTRICT나 CASCADE를 명시해야 한다.   RESTRICT 옵션: 이 열을 참조하고 있는 뷰나 제약조건이 있으며   이 열을 삭제할 수 없다.   CASCADE 옵션: 이 열을 참조하고 있는 모든 뷰나 제약조건을 함께 삭제한다.  2) ALTER TABLE 명령의 일반 형식 	1
0000	SQL  언어 18 SQL 데이터 정의어 3) 기본 테이블 변경 예제 ① 새로운 열 추가하기 - 사원 테이블에 최대 10 바이트의 가변 길이 문자열 타입의 ‘최종학력’ 열을 추가하고  디폴트 값을 ‘대졸’로 설정한다.  ② 기존 열 삭제하기 - 사원 테이블의 ‘호봉’ 열을 삭제하되  이 열을 참조하는 뷰나 제약조건이 있으면 함께 삭제하도록 한다.  ③ 기존 열의 데이터 타입 변경하기 - 사원 테이블의 ‘이름’ 열의 데이터 타입을 20바이트의 가변 길이 문자열로 변경한다.  ALTER TABLE   사원 MODIFY   이름 VARCHAR2(20); ALTER  TABLE   사원 DROP   호봉 CASCADE; ALTER TABLE   사원 ADD   최종학력 VARCHAR2(10)   DEFAULT  ‘대졸; 	1
0000	SQL  언어 19 SQL 데이터 정의어 ④ 열의 디폴트 값 변경하기 - 사원 테이블의 ‘최종학력’ 열의 디폴트 값을 ‘고졸’로 수정한다.  ⑤ 무결성 제약조건 삭제하기 - 사원 테이블의 ‘휴대폰’ 열이 유일한 값을 갖도록 UNIQUE 옵션을 설정할 때 설정한 ‘사원_unique_key’라는 이름의 제약조건을 삭제한다.  ALTER TABLE   사원 DROP   CONSTRAINT 사원_unique_key; ALTER TABLE   사원 MODIFY 최종학력 SET  DEFAULT  ‘고졸; 	1
0000	SQL  언어 20 SQL 데이터 정의어 3. SQL 데이터 제어어 (1) 데이터 제어어(DCL: Data Control  Language)란?   - DB 사용자의 권한을 제어하기 위해서 사용하는 언어이다. (2) 데이터 제어어의 명령어 종류 DCL 명령어 역할 GRANT 사용자에게 DB 객체에 대한 권한을 부여한다.  REVOKE 사용자에게 이미 부여된 DB 객체에 대한 권한을 취소한다.  (3) 권한 부여 1) GRANT  명령 - DB 관리자가 한 명 이상의 사용자에게 여러 개의 시스템 권한을 부여할 때 사용하는 명령이다.  2) GRANT 명령의 일반 형식 GRANT 시스템권한1[  시스템권한2  . . .] TO   사용자명1[   사용자명2   . . .]; GRANT 명령으로 객체의 소유자가 특정 객체 권한을 다른 사용자에게 부여할 수도 있는데  이 과정에서 는 자세한 설명은 생략함 	1
0000	SQL  언어 21 SQL 데이터 정의어 (4) 응용 프로그램 개발자가 가질 수 있는 시스템 권한의 종류 시스템 권한 설명 CREATE  SESSION 사용자가 DB로 접속할 수 있는 권한 CREATE  TABLE 사용자의 스키마에서 테이블을 생성할 수 있는 권한 CREATE SEQUENCE 사용자의 스키마에 시퀀스를 생성할 수 있는 권한 CREATE VIEW 사용자의 스키마에서 뷰를 생성할 수 있는 권한 CREATE  PROCEDURE 사용자의 스키마에 내장된 프로시저  함수  패키지를 생성할 수 있는 권한 (5) 권한 부여 사례 - DB 관리자가 ‘mkpark’ 및 ‘yhkim’ 사용자에게 테이블과 시퀀스  뷰를 생성할 수 있는 권한을 부여한다. GRANT CREATE  TABLE  CREATE SEQUENCE  CREATE VIEW  TO   mkpark    yhkim;    	1
0000	SQL  언어 22 SQL 데이터 정의어 (6) 권한 철회 1) REVOKE  명령 - 사용자에게 부여한 권한을 철회할 때 사용하는 명령이다.  2) REVOKE 명령의 일반 형식 (7) 권한 철회 사례 - DB 관리자가 ‘mkpark’ 사용자에게 부여한 테이블 및 뷰 생성 권한을 철회한다. REVOKE CREATE  TABLE   CREATE VIEW    FROM   mkpark;    REVOKE 시스템권한1[  시스템권한2  . . .] FROM   사용자명1[   사용자명2   . . .]; 	1
0000	SQL  언어 23 Lesson.   SQL 데이터 조작어와 SQL 뷰 1. SQL 데이터 조작어 2. SQL 뷰 SQL 데이터 조작어와 SQL 뷰 	1
0000	SQL  언어 24 SQL 데이터 조작어 1. SQL 데이터 조작어 (1) 데이터 조작어(DML: Data Manipulation Language)란?   - 데이터의 검색 및 삽입  삭제  변경을 위해서 사용하는 언어이다. (2) 데이터 조작어의 명령어 종류 (3) SQL의 테이블과 관계 데이터 모델의 릴레이션과의 차이점 ① SQL의 테이블은 반드시 기본 키를 가져야 하는 것은 아니다. ② SQL의 한 테이블에는 동일한 행(레코드)이 중복될 수 있다.   검색할 때 ‘DISTINCT’ 옵션을 지정하면  동일한 행을 제거할 수 있다 DML 명령어 역할 SELECT DB 객체에서 데이터를 검색한다.  INSERT DB 객체에 데이터를 삽입한다.  DELETE DB 객체에서 데이터를 삭제한다.  UPDATE DB 객체의 기존 데이터를 변경한다.  	1
0000	SQL  언어 25 SQL 데이터 조작어 (4) 데이터 검색 1) SELECT  명령 - 테이블에서 데이터를 검색할 때 사용하는 명령이다. - 검색한 결과도 테이블이 되는 폐쇄적 성질을 갖고 있는 명령이다.  2) SELECT 명령의 일반 형식 SELECT [ALL | DISTINCT] { * | 열_리스트 [AS 열별칭]}  FROM        테이블_리스트 [WHERE     조건] [GROUP BY 열_리스트 [HAVING    그룹조건]] [ORDER BY  열_리스트 [ASC | DESC]]; SELECT 명령의 해석 순서 ⑤ ① ② ③ ④ ⑥ ① SELECT 문을 실행할 때  맨 먼저 검색할 데이터가 어떤 테이 블에 있는지를 알아야 하기 때문 에  FROM 절이 가장 먼저 해석 됨 ② 어떤 조건을 만족하는 열을 검 색해야 할지를 알기 위해  WHERE절이 두 번째로 해석됨 ③ 그룹에 대한 정보를 알기 위해 서 GROUP BY 절이 세 번째로 해석됨 ④ 그룹에 대한 조건을 알기 위해 서 HAVING 절이 네 번째로 해석됨 ⑤ 앞의 모든 조건을 만족하는 열을 검색하기 위해서 SELECT 절이 다섯 번째로 해석됨 ⑥ 검색된 열을 정렬하는 ORDER BY  절이 맨 마지막에 해석됨 	1
0000	SQL  언어 26 SQL 데이터 조작어 * 열 별칭(Alias) – 열 이름에 부 여하는 새로운 이름을 의미한다.   3) SELECT 명령의 구성 구성 기능 SELECT 절 검색할 하나 이상의 데이터 항목 즉  열 이름이나 열 별칭(Alias)을 기 술한다. ① ALL : 검색 결과에서 중복되는 행을 그대로 표시하도록 지정함 ② DISTINCT : 검색 결과에서 중복되는 행을 삭제하도록 지정함 ③ * : 테이블의 모든 열을 검색하도록 지정하는 와일드카드(Wildcard)  문자임 ④ AS 열별칭 :  열 이름에 새로운 이름을 부여하는 것으로  AS는 생략 해도 됨 FROM 절 검색할 테이블 이름을 기술한다.  WHERE 절 검색할 조건을 기술한다.  GROUP BY 절 그룹 질의를 수행할 열 이름을 기술한다. 즉  특정 열의 값이 동일한 행들을 그룹핑해서  각 그룹별로 한 행의 질의 결과를 생성할 때 사용한다.  HAVING 절 GROUP BY 절에 의해 구성된 그룹에 적용할 제한 조건을 기술한다.  ORDER BY 절 특정 열 값을 기준으로 질의 결과를 정렬할 때 기준이 되는 열 이름을 기술한다.  ① ASC : 오름차순(Ascending) 정렬을 지정함 (디폴트 값임)  ② DESC : 내림차순(Descending) 정렬을 지정함 	1
0000	SQL  언어 27 SQL 데이터 조작어 4) 데이터 검색 예제 - 앞의 기본 테이블 생성 예제에서 생성한 사원 및 근무 테이블에서 검색한다.  ① 모든 열 검색하기 - 사원 테이블의 모든 열의 내용을 검색한다.  ② 조건이 만족하는 모든 열 검색하기 - 사원 테이블에서 호봉이 11이라는 조건을 만족하는 사원의 모든 정보를 검색한다.  ③ 조건이 만족하는 특정 열만 검색 - 사원 테이블에서 호봉이 11이라는 조건을 만족하는 사원의 사번과 이름만을 검색한다.  SELECT   * FROM    사원 WHERE 호봉 = 11 ;  SELECT   * FROM    사원;  SELECT   사번   이름 FROM    사원 WHERE 호봉 = 11 ;  검색 결과 확인 검색 결과 확인 검색 결과 확인 	1
0000	SQL  언어 28 [검색 결과]  검색 결과-1 검색 결과-2 검색 결과-3 사번 이름 입사일 호봉 휴대폰 ------------------------------------------------------------ 1101              김정아 1995-03-10           20           010-3452-0022 1102              이기원 1997-01-01           18           011-3478-1287 1103              박영종 2005-09-01           15           010-3214-1234 1201              최강희 1994-02-01           21           010-1122-3344 1202              조현수 2007-03-15           14           010-5566-4321 1203              박제성 1999-09-01           17           019-3452-3457 1312              김민수 2011-03-01           11           011-2340-0023 1314              이정숙 2011-03-01           11           010-3420-0991 사번 이름 입사일 호봉 휴대폰 ------------------------------------------------------------ 1312              김민수 2011-03-01           11           011-2340-0023 1314              이정숙 2011-03-01           11           010-3420-0991 사번 이름 ------------------------- 1312 김민수 1314                     이정숙 	1
0000	SQL  언어 29 SQL 데이터 조작어 ④ 중복된 행을 제거하고 검색하기 - 현재 사원들이 근무하는 부서번호가 무엇인지 근무 테이블에서 검색한다.  ⑤ 행 정렬 검색하기 - 사원 테이블에서 입사일이 빠른 사람부터 출력하고  입사일이 같은 경우 사원번호가 더 큰 번호를 갖는 사원부터 출력한다.     SELECT   DISTINCT 부서번호 FROM    근무;      SELECT   사번   이름  입사일 FROM     사원 ORDER BY    입사일 ASC   사원번호 DESC;  검색 결과 확인 검색 결과 확인 	1
0000	SQL  언어 30 [검색 결과]  검색 결과-4 검색 결과-5 부서번호 ------- 100             200 300 400 사번 이름 입사일 ---------------------------------- 1201              최강희 1994-02-01 1101 김정아 1995-03-10            1102 이기원 1997-01-01            1203              박제성 1999-09-01     1103              박영종 2005-09-01            1202              조현수 2007-03-15        1314              이정숙 2011-03-01        1312              김민수 2011-03-01        오름차순(ASC)  내림차순(DESC)  	1
0000	SQL  언어 31 SQL 데이터 조작어 ⑥ GROUP BY 절을 이용해서 검색하기 - 사원_2 테이블에서 같은 부서에 근무하는 사원들의 평균 연봉을 계산해서 출력한다.  ⑦ HAVING 절을 이용해서 검색하기 - 사원_2 테이블에서 같은 부서에 근무하는 사원들의 평균 연봉을 계산해서 출력하되  평균 연봉이 5000 이상인 부서만 출력한다.  SELECT        부서번호   AVG(연봉)  AS 평균연봉 FROM          사원_2  GROUP BY 부서번호; SELECT        부서번호   AVG(연봉)  AS  평균연봉 FROM          사원_2  GROUP BY 부서번호 HAVING AVG(연봉) ≥ 5000 ; AVG: 평균을 계산해서 반환하는 그룹 함수 AS: 연봉의 평균을 계산한 열의 제목으로 ‘평균연봉’이라는 별칭을 부여함 부서번호가 같은 데이터들끼리 그룹을 생성함 그룹을 제한하는 조건을 명시할 때 사용하며   HAVING 절의 조건을 만족하는 그룹만 표시하게 됨 검색 결과 확인 검색 결과 확인 	1
0000	SQL  언어 32 SQL 데이터 조작어 검색 결과-6 부서번호 평균연봉 ------------------ 100                 4500 200                 5250 300                 5750 400                 3750  사원_2 테이블 사번 이름 입사일 부서번호 연봉 휴대폰 1101 1102 1103 1201 1202 1203 1312 1314 김정아 이기원 박영종 최강희 조현수 박제성 김민수 이정숙 1995-03-01 1997-01-01 2005-09-01 1994-02-01 2007-03-15 1999-09-01 2011-03-01 2011-03-01 100 200 200 300 300 400 100 400 7000 6000 4500 7500 4000 5500 2000 2000 010-3452-0022 011-3478-1287 010-3214-1234 010-1122-3344 010-5566-4321 019-3452-3457 011-2340-0023 010-3420-0991 검색 결과-7 부서번호 평균연봉 ------------------ 200                 5250 300                 5750 	1
0000	SQL  언어 33 SQL 데이터 조작어 (5)  데이터 삽입 1) INSERT  명령 - 기존 테이블에서 새로운 데이터(행)를 삽입할 때 사용하는 명령이다. - 삽입할 테이블 이름과 열 이름들  그리고 각 열의 값을 기술한다.   2) INSERT 명령의 일반 형식 ① 새로운 데이터 직접 삽입하기 ② 다른 테이블의 데이터를 복사해서 삽입하기 - 부속 질의문(SELECT 문)을 이용해서 검색한 결과를 복사해서 삽입한다.  3) INSERT 명령의 특징 ① VALUES 절에 열의 값을 명시하므로 한번에 하나의 행만 삽입할 수 있다.  ② 열 이름을 명시하지 않으면  테이블에 정의된 열의 순서대로 값을 나열해야 한다. INSERT  INTO  테이블_이름 [(열이름_리스트)] VALUES  (열값_리스트); INSERT  INTO  테이블_이름 [(열이름_리스트)] SELECT 문; 	1
0000	SQL  언어 34 SQL 데이터 조작어 4) 데이터 삽입 예제 ① 새로운 데이터 직접 삽입하기 - 사원 테이블에 신입 사원 “이동문”의 데이터를 직접 삽입한다.  ② 다른 테이블의 데이터를 복사해서 삽입하기 - 사원_2 테이블의 데이터 가운데 100번 부서에 근무하는 사원의 사번과 이름 열의 값만 복사해서 ‘기획실_사원 ‘테이블에 삽입한다. (이때 기획실_사원 테이블은 미리 생성되어 있어야 함)  INSERT  INTO  사원(사번  이름  입사일  호봉  휴대폰) VALUES  (1411   ‘이동문’  2012-09-01  8  ‘010-8766-4889’); INSERT  INTO  기획실_사원(사번  이름) SELECT 사번  이름 ; FROM 사원_2; WHERE 부서번호 = 100; INSERT  INTO  사원 VALUES (1411   ‘이동문’  2012-09-01  8  ‘010-8766-4889’); 혹은 삽입 결과 확인 삽입 결과 확인 사원 테이블에 정의된 열의 순서와 VAULES 절에 명시 한 열 값의 순서가 동일하므 로  테이블 이름 뒤에 열 이 름 리스트를 생략함 	1
0000	SQL  언어 35 SQL 데이터 조작어 삽입 결과-1 사원 테이블 삽입 결과-2 사번 이름 입사일 호봉 휴대폰 1101 1102 1103 1201 1202 1203 1312 1314 1411 김정아 이기원 박영종 최강희 조현수 박제성 김민수 이정숙 이동문 1995-03-01 1997-01-01 2005-09-01 1994-02-01 2007-03-15 1999-09-01 2011-03-01 2011-03-01 2012-09-01 20 18 15 21 14 17 11 11 8 010-3452-0022 011-3478-1287 010-3214-1234 010-1122-3344 010-5566-4321 019-3452-3457 011-2340-0023 010-3420-0991 010-8766-4889 기획실_사원 테이블 사번 이름 1101 1312 김정아 김민수 	1
0000	SQL  언어 36 SQL 데이터 조작어 (6)  데이터 삭제 1) DELETE  명령 - 테이블에서 기존 데이터(행)를 삭제할 때 사용하는 명령이다. - 삭제할 데이터가 포함된 테이블 이름과 삭제 조건을 기술한다.   2) DELETE  명령의 일반 형식 3) 데이터 삭제 예제 ① 한 개의 데이터(행) 삭제하기 - 사원 테이블에서 사원번호가 1203인 사원을 삭제한다.  ② 복수 개의 데이터(행) 삭제하기 - 사원_2 테이블에서 부서번호가 200인 사원을 모두 삭제한다.  DELETE   FROM  테이블_이름 [WHERE  조건]; DELETE   FROM  사원 WHERE  사번 = 1203; DELETE   FROM  사원_2  WHERE  부서번호 = 200; 	1
0000	SQL  언어 37 SQL 데이터 조작어 (7)  데이터 변경 1) UPDATE  명령 - 테이블에서 기존 데이터(행)를 변경할 때 사용하는 명령이다. - 변경할 데이터가 포함된 테이블 이름과 변경할 열 이름  변경 조건을 기술한다.   2) UPDATE 명령의 일반 형식 3) 데이터 변경 예제 ① 한 개의 데이터(행) 변경하기 - 사원 테이블에서 사원번호가 1202인 사원의 호봉을 15 호봉으로 변경한다.  ② 복수 개의 데이터(행) 변경하기 - 사원 테이블에서 호봉이 11인 사원의 호봉을 모두 12로 변경한다.  UPDATE   테이블_이름 SET {열이름 = 산술식}+ [WHERE  조건]; UPDATE   사원 SET 호봉 = 15 WHERE  사번 = 1202; UPDATE   사원 SET 호봉 = 12 WHERE  호봉 = 11; 	1
0000	SQL  언어 38 2. SQL 뷰 SQL 뷰 (1)  뷰(View)란?  - 다른 테이블로부터 유도된 가상의 테이블(Virtual Table)로서  물리적으로 생성되지 않는 논리적인 테이블이다.  (2) 뷰의 특징 ① 논리적인 테이블이므로 실제로 물리적으로 생성되지 않으며  뷰의 정의만 시스템에 저장된다. ② 기본 테이블뿐만 아니라 다른 뷰를 기초로 생성할 수 있다. ③ 뷰 자체는 데이터를 직접 포함하지 않지만  창문 역할을 하는 뷰를 통해서 데이터의 검색과 삽입  변경이 가능하다. ④ 뷰에 대한 검색은 기본 테이블과 거의 유사하지만  뷰를 통한 삽입  삭제  변경은 일부 제약을 받는다.  ⑤ 외부 스키마는 뷰와 기본 테이블의 정의로 구성된다.  ⑥ 뷰의 기본이 되는 기본 테이블이 삭제(변경)되면  뷰도 자동으로 삭제(변경)된다. ⑦ 뷰는 ALTER 문을 사용해서 변경할 수 없으며  변경이 필요한 경우 삭제하고 다시 생성해야 한다.  ⑧ 뷰는 DROP문을 사용해서 삭제할 수 있다.  	1
0000	SQL  언어 39 삽입 SQL  (3)  뷰 사용의 장점 ① 보안을 위해서 DB에 대한 접근을 제한할 수 있다. - 사용자는 특정 테이블의 데이터 가운데 뷰로 정의된 특정 부분만을 보게 된다. ② 복잡한 질의를 단순한 질의로 변환할 수 있다. - 여러 테이블을 기초로 뷰를 생성하면 테이블 조인(Join)이 불필요하게 된다.  즉  주로 사용하는 정보만을 대상으로 데이터 조작을 수행할 수 있다. ③ 데이터 독립성을 허용한다.            - 테이블이 변경되어도 뷰는 그대로 유지할 수 있으므로  임시 사용자와 응용 프로그램에 대한 데이터 독립성을 제공할 수 있다. ④ 동일한 테이블에 대해서 다른 뷰를 생성할 수 있다. - 조건에 따라 데이터에 접근하는 사용자 그룹을 분류해서  각각 동일한 테이블의 다른 뷰를 기초로 데이터를 조작할 수 있게 한다.  (4)  뷰 사용의 단점 ① 뷰의 정의를 변경할 수 없다. - 변경이 필요한 경우 뷰를 삭제하고 다시 생성해야 한다.  ② 삽입  삭제  변경 연산에 제한이 많다. * 조인(Join) – 하나 이상의 테이 블로부터 필요한 데이 터를 검색하기 위한 일 종의 연산이다. 	1
0000	SQL  언어 40 삽입 SQL  (5)  뷰의 종류 1) 단순 뷰(Single View) - 오직 하나의 테이블만을 기초로 생성된 뷰이다.. - 산술식 등에 의해 데이터가 조작된 경우를 제외하면  뷰를 통한 모든 DML 연산의 수행이 가능하다. 2) 복합 뷰(Complex or Join View) - 여러 테이블을 기초로 생성된 뷰이다. - 데이터 그룹핑 또는 그룹 함수를 사용해서 뷰를 생성할 수 있다.   - 뷰를 통한 모든 DML이 항상 가능한 것은 아니다. 	1
0000	SQL  언어 41 삽입 SQL  (6)  뷰 생성 1) CREATE  VIEW  명령 - SELECT 문이 수행되어 가져온 열들로 구성된 뷰를 생성한다.  2) CREATE  VIEW  명령의 일반 형식 CREATE  VIEW  뷰_이름[(열_이름 리스트)] AS SELECT문 [WITH CHECK OPTION];  WITH CHECK OPTION : 삽입이나 변경할 때 뷰의 정의 조건을 검사해서 뷰에 의해 접근 가능한 행만 삽입 또는 변경될 수 있도록 지정함 3) 뷰 생성 예제 ① 단순 뷰 생성하기 - 사원_2 테이블에서 부서번호가 200인 사원 데이터의 사번과 이름  연봉  휴대폰만 포함하는 ‘비서실_사원’이라는 이름의 뷰를 생성한다. CREATE  VIEW  비서실_사원(사번   이름   연봉  휴대폰) AS    SELECT   사번   이름   연봉  휴대폰 FROM      사원_2 WHERE    부서번호 =  200;  뷰 확인 	1
0000	SQL  언어 42 삽입 SQL  ② 열 별칭을 사용해서 뷰 생성하기 - 사원_2 테이블에서 부서번호가 300인 사원 데이터의 사번과 이름  연봉  휴대폰만 포함하는 ‘총무부_사원’이라는 이름의 뷰를 생성하되   열 이름은 id. name  salary   cellphone으로 지정한다. CREATE  VIEW  총무부_사원(id   name   salary  cellphone) AS    SELECT   사번   이름   연봉  휴대폰 FROM      사원_2 WHERE    부서번호 =  300;  뷰 확인 	1
0000	SQL  언어 43 [뷰 확인]  뷰 확인-1 비서실_사원 뷰 사번 이름 연봉 휴대폰 1102 1103 이기원 박영종 6000 4500 011-3478-1287 010-3214-1234 뷰 확인-2 총무부_사원 뷰 id name salary cellphone 1201 1202 최강희 조현수 7500 4000 010-1122-3344 010-5566-4321 	1
0000	SQL  언어 44 삽입 SQL  (7)  뷰 삭제 1) DROP  VIEW  명령 - 기존의 뷰를 삭제한다.   2) DROP  VIEW  명령의 일반 형식 DROP VIEW  뷰_이름 [RESTRICT  | CASCADE]; 3) 뷰 삭제 예제 - 앞에서 생성한 총무부_사원 뷰를 삭제하되  이 뷰가 다른 곳에서 참조되고 있으면 삭제하지 않는다.  DROP  VIEW 총무부_사원 RESTRICT;   RESTRICT : 뷰가 다른 곳에서 참조되고 있지 않을 때만 제거함  CASCADE  : 뷰를 참조하는 다른 모든 뷰나 제약조건을 함께 제거함 	1
0000	SQL  언어 45 삽입 SQL  (8)  뷰 조작 1) 뷰 조작 연산의 한계점 - 기본 테이블에서 사용 가능한 검색(SELECT 명령)은 모두 사용할 수 있지만    삽입  삭제  변경은 제한적으로 사용 가능하다.  2) 삽입  삭제  변경이 허용되는 경우 - 뷰가 하나의 기본 테이블의 행과 열의 부분 집합으로 정의된 경우 3) 삽입  삭제  변경이 허용되지 않는 경우 ① 뷰의 열이 상수나 산술 연산자 또는 함수가 사용된 산술식으로 만들어진 경우 ② 그룹 함수(COUNT  SUM  AVG  MAX  MIN)를 사용해서 정의된 경우 ③ DISTINCT  GROUP BY  HAVING 절이 사용되어 정의된 경우 ④ 두 개 이상의 테이블이 관련되어 정의된 경우 ⑤ 변경할 수 없는 뷰를 기초로 정의된 경우 	1
0000	데이터베이스 데이터베이스 8 회차 : 관계 DB 구축 단계 김은경 	1
0000	관계 DB 구축 단계 2 학습목표 동기유발 & 학습목표 학습내용 1. 관계 DB 구축의 6 단계 학습목표 2. 관계 DB 구축 단계별 세부 내용 1. DB의 라이프 사이클 5 단계를 나열할 수 있다. 2. 관계 DB 구축의 6 단계를 나열할 수 있다.   3. DB 구축 시 고려사항을 설명할 수 있다.  1. 요구 수집 및 분석 절차에 대해 설명할 수 있다.  2. 개념적 설계의 2가지 주요 업무를 나열할 수 있다. 3. 논리적 설계의 3가지 주요 업무를 나열할 수 있다.   	1
0000	관계 DB 구축 단계 3 Lesson. 관계 DB 구축의 6 단계 1. DB 라이프사이클 2. DB 구축의 6 단계 3. DB 구축 시 고려사항 관계 DB 구축의 6 단계 	1
0000	관계 DB 구축 단계 4 DB의 생명주기 1. DB 라이프사이클 (1) DB 라이프사이클(Life Cycle)란?    - DB가 생성되어 사용되는 동안 반복적으로 거치게 되는 일련의 과정을 의미하며  요구사항 분석  설계  구현  운영  감시 및 개선의 5 단계를 포함한다. 요구사항 분석 설 계 구 현 운 영 감시 및 개선 [DB 라이프사이클]  	1
0000	관계 DB 구축 단계 5 DB의 생명주기 (2) 요구사항 분석(Requirement Analysis)  단계 - DB에 저장할 데이터의 범위를 결정하기 위해서 사용자와 응용 프로그램이 필요로 하는 요구사항을 수집하여 분석하는 단계이다. (3) 설계(Design) 단계 - 개념적 설계  DBMS 선정  논리적 설계  물리적 설계를 단계별로 수행한다. (4) 구현(Implementation) 단계 - 설계된 DB 스키마를 기초로 DB 생성  초기 데이터 저장  응용 프로그램 개발 등을 수행한다. (5) 운영(Operation) 단계 - 사용자 요구에 따라 DB 시스템과 응용 프로그램을 실제로 운영해서 서비스를 제공한다. (6) 감시 및 개선(Monitoring & Tuning) - DB 시스템의 성능을 감시하여 향상시키고  새로운 요구조건이나 응용 프로그램의 필요성에 적절히 대처한다. 	1
0000	관계 DB 구축 단계 6 DB의 생명주기 2. DB 구축의 6 단계 (1) DB 구축 단계 및 수행 업무 요구수집 및 분석 개념적 설계 DBMS 선정 논리적 설계 물리적 설계 구현 및 테스트 [DB 구축의 6 단계]  DB 구축 단계는 순서대로만 진 행되는 것은 아니며  DB 구축 도중에 이전 단계의 오류가 발 견되거나 변경이 불가피한 경우  앞 단계로 되돌아가서 변경할 수 있음 	1
0000	관계 DB 구축 단계 7 DB의 생명주기 * 트랜잭션(Transaction)  - 데이터를 일관되게 변경하는 하나 이상의 데이터 조작어 (DML) 문장이다.  단계 주요 업무 1. 요구수집 및 분석 - 사용자 요구사항 수집 - 업무별 데이터 및 트랜잭션 요구 분석 명세서 작성 2. 개념적 설계 - 개념적 모델링(ER 다이어그램 작성) - 트랜잭션 모델링 3. DBMS  선정 - 논리적 데이터 모델. 운영 환경  경제성 등을 고려해서 선정 4. 논리적 설계 - 논리적 모델링 (릴레이션 스키마 및 무결성 제약조건 정의)  - 트랜잭션 인터페이스 설계 - 스키마 평가 및 정제 5. 물리적 설계 - 물리적 모델링(내부 스키마 정의  뷰와 인덱스 정의 등)   - 트랜잭션 상세 설계 6. 구현 및 테스트 - DB 구축(DDL로 DB 생성) 및 초기 데이터 적재 - 트랜잭션 처리용 응용 프로그램 작성 및 테스트 	1
0000	관계 DB 구축 단계 8 DB의 생명주기 데이터 중심 설계와 처리 중심 설계를 병행하는 것이 일반적이지만  처리 중심 설계까지 다루면 범위가 너무 넓어지므로  이 과정에서는 데이터 중심 설계에 초점을 맞추어 설명하도록 하겠습니다.  (2) DB 설계 전략 1) 데이터 중심(Data-driven) DB 설계 - DB의 내용과 구조에 치중해서 설계하는 방법이다.  2) 처리 중심(Processing-driven) DB 설계 - 데이터의 처리와 응용에 치중해서 설계하는 방법이다.   두 가지를 병행해서 진행하는 것이 일반적이다.  	1
0000	관계 DB 구축 단계 9 DB의 생명주기 3. DB 구축 시 고려사항 항목 설명 무결성 (Integrity) DB에 저장된 데이터가 제약조건을 만족해야 한다. (갱신  삽입  삭제 등의 연산 후에도 데이터 값이 정확해야 한다.) 일관성 (Consistency) 저장된 데이터들 간에  또는 특정 질의에 대한 응답들 간에 모순이 없어야 한다. 회복 (Recovery) 시스템에 장애가 발생한 경우  장애 발생 이전의 일관된 DB 상태로 복구 가능해야 한다. 보안 (Security) 불법적인 접근(데이터의 변경  손실  노출 등)에 대해 보호 가능해야 한다. 효율성 (Efficiency) 응답시간 단축  저장 공간 최적화  시스템의 생산성(처리도) 등을 고려해야 한다. 확장 (Growth) 시스템에 영향을 주지 않고 새로운 응용 프로그램이나 데이터를 추가할 수 있어야 한다. 	1
0000	관계 DB 구축 단계 10 Lesson. 관계 DB 구축 단계별 세부 내용 1. 요구수집 및 분석 단계 2. 개념적 설계 단계 3. DBMS 선정 단계 4. 논리적 설계 단계 5. 물리적 설계 단계 6. 구현 및 테스트 관계 DB 구축 단계별 세부 내용 	1
0000	관계 DB 구축 단계 11 요구수집 및 분석 단계 성공적인 DB(디비) 구축을 위해서는 먼저 사용자의 요구사항을 정확히 파악하는 것이 필수적입니다. DB 구축의 첫 단추를 잘 끼울 수 있도 록 꼼꼼하게 요구사항을 수집을 해야 합니다.   1. 요구수집 및 분석 단계 (1) 요구수집 및 분석이란?  - DB가 제공해야 할 정보 내역을 수집하고 분석해서  개념적 설계의 기초가 되는 요구 분석 명세서 를 작성하는 것이다.  (2) 요구 수집 및 분석의 주요 업무 사용자 그룹 및 담당자 식별 요구사항 수집 요구사항 분석 요구 분석 명세서 작성 사용자의 요구사항 수집 범 기관적 제약조건 파악 기존 문서 조사 업무 영역 분할 상세 업무 분석 수용 범위 결정 	1
0000	관계 DB 구축 단계 12 요구수집 및 분석 단계  사용자 그룹 및 담당자 식별 - DB를 사용할 사용자 그룹과 요구 수집 및 분석에 참여할 업무 담당자를 식별한다.  사용자의 요구사항 수집 - 주요 사용자 및 업무 담당자와의 대화  인터뷰  회의 등과 같은 직접적인 방법이나  설문조사와 같은 간접적인 방법을 활용해서 DB의 용도를 파악하고 전체적인 요구사항을 수집한다.   범 기관적 제약조건 파악 - DB를 사용할 조직의 경영 정책이나 규정  조직 관리와 기획 정보 등을 파악해서 요구사항에 어떻게 반영할 지 결정한다.   기존 문서 조사 - 기존 응용 프로그램과 관련된 매뉴얼과 각종 양식(Form)  보고서(Report)  차트(Chart) 등 기존 문서를 조사한다. 	1
0000	관계 DB 구축 단계 13 요구수집 및 분석 단계  업무 영역 분할 - 전체 업무를 상세 업무 분석의 기본 단위가 되는 소단위의 업무 영역으로 분할하고  업무 영역 분할도를 작성한다.  상세 업무 분석 - 요구 수집 결과를 기초로 분할한 각 업무 영역별로 요구되는 데이터 및 트랜잭션을 분석한다.   요구 분석 명세서 작성 - 각 업무별로 요구되는 데이터 요구분석 명세서와 트랜잭션 요구분석 명세서를 각각 작성한다.   수용 범위 결정 - 요구 사항을 어디까지 수용할 지 그 범위를 결정한다.  	1
0000	관계 DB 구축 단계 14 요구수집 및 분석 단계 (3) 요구 분석의 산출물 - 인터뷰 내용  기존 문서 조사 결과  업무 분장표 등을 기초로 업무 영역을 분할하고  각 업무 영역별로 사용자의 요구사항을 일목요연하게 정리해서 공식적인 요구분석 명세서(데이터 및 트랜 잭션)를 작성한다.  - 데이터 요구분석 명세서는 데이터 중심 설계에 초점을 맞춘 것이고   트랜잭션 요구분석 명세서는 처리 중심 설계에 초점을 맞춘 것이다.  . 인터뷰 내용 . 설문조사 내용 . 업무 분장표 . 업무흐름도 . 현 시스템 분석도 . 범 기관적 제약조건 . 기존 문서 조사 결과 . 기존 보고서 양식 등 요구 분석 요구분석 명세서 (데이터 및 트랜잭션) 1) 업무 영역 분할 2) 상세 업무 분석 	1
0000	관계 DB 구축 단계 15 개념적 설계 단계 원칙적으로 요구수집 및 분석 단계가 완전히 끝난 다음에 개념적 설계를 진행해야 하지만  실무에서는 이 두 단계가 완전히 독립적으로 진행되기는 어렵습니다. 왜냐하면 개념적 설계를 진행하면서  미처 수집되지 않은 새로운 요구사항을 발견하는 경우가 생기기 때문입니다. 따라서 한 단계를 완벽하게 끝낸 후 다음 단계로 넘어가기 보다는  어느 정도 요구사항이 분석되면 개념적 설계를 하면서 완성해 나갈 수 있습니다.  2. 개념적 설계 단계 (1) 개념적 설계란?  - 요구 분석 명세서를 기초로 DBMS와는 무관한 추상적인 형태로 사용자의 요구를 표현하는 것이다. (2) 개념적 설계의 주요 업무 - 개념적 모델링과 트랜잭션 모델링(프로세스 모델링)을 병행해서 수행한다. (3) 개념적 설계의 필요성 - 사용자의 다양한 요구사항을 처음부터 완벽하게 DB가 이해할 수 있는 방법으로 표현하는 것이 어려우므로  우선 개념적이고 다소 추상적인 방법으로 표현할 필요가 있다.  사용자의 요구사항이 빠짐없이 표현되었는지 쉽게 파악하는데 도움이 되고  사용자와 개발자 간의 의사소통을 원활히 하는데 도움이 됨 개념적 모델링 트랜잭션 모델링 + - 데이터의 조직 및 표현에 초점을 맞추기 때문에 데이터 중심 설계가 된다.  - 데이터 요구분석 명세서를 기초로 ER  모델을 도출한다.  - 응용을 위한 데이터 처리에 초점을 맞추기 때문에 처리 중심 설계가 된다.  - 트랜잭션 요구 분석 명세서를 기초로 업무 단위의 유형별 트랜잭션을 나열한다.  	1
0000	관계 DB 구축 단계 16 개념적 설계 단계 (4)  개념적 모델링의 산출물 - 업무별 데이터 요구 분석 명세서를 기초로 개체와 관계를 식별하고  개체 및 관계의 속성 등을 식별해서 ER 다이어그램을 작성한다.  데이터 요구 분석 명세서 Input 개념적 모델링 ER 다이어그램 Output ① 요구 분석 명세서를 기초로 핵심 개체 타입 식별 ② 개체 타입들 간의 관계 식별 ③ 관계 타입의 유형과 카디널리티(옵션) 결정 ④ 개체 타입의 속성 식별 ⑤ 개체 타입의 식별자(후보 키) 결정 ⑥ 관계 타입의 속성 식별 	1
0000	관계 DB 구축 단계 17 개념적 설계 단계 개념적 설계에 대해서는 뒤에서 자세히 학습할 것이므로  여기서는 전체적인 개념만 이해하도록 노력해주세요.   (4)  트랜잭션 모델링의 산출물 - 업무별 트랜잭션 요구 분석 명세서를 기초로  DB 설계에 반영할 필요가 있는 주요 트랜잭션을 식별해서 업무 단위의 유형별 트랜잭션 명세서를 작성한다.  - 주요 트랜잭션의 기능적 특성(입력 데이터와 출력 데이터  내부적인 제어의 흐름 등)을 개념적으로 작성한다.   주요 트랜잭션을 처리하는데 필요한 모든 정보를 DB 스키마에 포함시킬 수 있음 트랜잭션 요구 분석 명세서 Input 트랜잭션 모델링 Output 트랜잭션 명세서 ① DB 설계에 반영할 필요가 있는 주요 트랜잭션 식별 ② 각 트랜잭션의 입력 데이터와 출력 데이터  그리고 내부적인 제어의 흐름 파악 ③ 트랜잭션들 간의 상대적인 중요도와 예상 실행 빈도수 파악 (추후 물리적 설계를 위한 중요한 정보가 됨)  	1
0000	관계 DB 구축 단계 18 DBMS  선정 단계 DB 설계를 시작하기 전에 이미 DBMS(디비엠에스)가 선정된 상태라면 물론 이 단계는 생략할 수 있지만  원칙적으로는 개념적 DB(디비)  스키마를 가장 잘 표현할 수 있는 논리적 데이터 모델이 무엇인지 판단한 다음  그런 논리적 데이터 모델을 기반으로 하는 DBMS를 선정하 는 것이 바람직합니다. 이 과정에서는 관계 데이터 모델을 기초로 하는 오라클 DBMS를 선정한 것으로 하겠습니다.    3. DBMS  선정 단계 (1) DBMS  선정의 필요성 - ER 다이어그램으로 표현된 개념적 데이터 모델을 논리적 데이터 모델로 변환하기 위해서는 먼저 어떤 논리적 데이터 모델(관계형  네트워크형  계층형 등)로 변환할 지가 결정되어야 하며  이를 결정하기 위해서는 DBMS가 선택되어야 한다. (2) DBMS  선정 기준 (1) 논리적 데이터 모델 (2) 운영 환경 (3) 경제성 D B M S 의 선 정 기 준 • 개념적 설계 단계의 산출물인 개념적 DB 스키마를 가장 효율적이고 안정적으로 표현할 수 있는 논리적 데이터 모델 (예: 관계 데이터 모델)을 기초로 하는 DBMS를 선택한다.  • DB를 구축할 하드웨어 환경(PC  워크스테이션  메인프레임 등)과 운영체제(윈도우   리눅스  유닉스 등) 등을 고려해서 운영 환경에 적합한 DBMS를 선택한다. • DBMS의 가격과 하드웨어 구입 비용  교육 비용  운영 비용   유지 비용 등 경제적인 측면을 고려해서 DBMS를 선택한다. 	1
0000	관계 DB 구축 단계 19 논리적 설계 단계 논리적 설계에 대해서도 뒤에서 별도로 학습할 것이므로  여기서는 전체적인 개념만 이해하도록 노력해주세요.  4. 논리적 설계 단계 (1) 논리적 설계란?  - 개념적 데이터 모델(개념적 스키마)을 DBMS가 지원하는 논리적 데이터 모델(논리적 스키마)로 변환하는 것이다. (2) 논리적 설계의 주요 업무 - 논리적 모델링과 트랜잭션 인터페이스 설계  그리고 스키마 평가 및 정제라는 3 단계를 순차적으로 수행한다. (3) 논리적 설계의 필요성 - 선택한 DBMS를 이용해서 DB를 구축하기 위해서는 먼저 ER 다이어그램으로 표현된 개념적 데이터 모델을 DBMS가 지원하는 논리적 데이터 모델  즉 논리적 스키마로 변환하는 단계를 거쳐야 한다. 1) 논리적 모델링 2) 트랜잭션 인터페이스 설계 - ERD로 표현된 개념적 데이터 모델을 논리적 데이터 모델(관계 데이터 모델)로 변환한다.  - 정규화를 통해서 보다 바람직한 형태로 변환한다.   - 요구 분석 명세서를 기초로 일관성과 무결성을 위한 제약조건을 정의한다.    - 트랜잭션 모델링을 기초로 인터페이스를 설계한다.  - 트랜잭션의 전체적인 골격과 DB 접근 방법 등을 개괄적으로 정의한다.  3) 스키마 평가 및 정제 - 논리적 스키마를 정량적 정보와 성능 평가기준에 따라 평가한다. . 정량적 정보: 데이터의 양  처리 빈도수  처리 작업량 등 . 성능 평가기준: 데이터 전송량  DB의 크기 등 	1
0000	관계 DB 구축 단계 20 논리적 설계 단계 (4)  논리적 모델링의 산출물 - 개념적 스키마(ER 다이어그램)를 DBMS가 지원하는 논리적 데이터 모델(관계 데이터 모델)에 맞는 논리적 스키마로 변환한다. 개념적 스키마 (ER 다이어그램) Input 논리적 모델링 Output 릴레이션 스키마  무결성 제약조건 ① 개체와 관계를 모두 릴레이션으로 변환 ② 릴레이션 단순화 ③ 정규화를 통해서 보다 바람직한 형태로 변환 ④ 무결성 제약조건 정의 	1
0000	관계 DB 구축 단계 21 물리적 설계 단계 물리적 설계에 대해서는 뒤에서 자세히 학습할 것이므로  여기서는 전체적인 개념만 이해하도록 노력해주세요.  5. 물리적 설계 단계 (1) 물리적 설계란?  - 논리적 스키마(릴레이션 스키마)를 기초로  DBMS가 지원하는 방법 가운데 효율적이고 구현 가능한 방법을 선택해서 내부 스키마(물리적 데이터 구조)로 변환하는 것이다. - 트랜잭션 응답 시간과 저장 공간의 효율화  트랜잭션 처리도 등을 감안해서 물리적 구조를 결정 해야 한다. (2) 물리적 설계 단계의 주요 업무 - 물리적 모델링과 트랜잭션 상세 설계를 병행해서 수행한다. 물리적 모델링 트랜잭션 상세 설계 + - 내부 스키마(즉  저장 레코드 양식) - 트랜잭션 분석 - 뷰와 인덱스 등 설계 - 응용 프로그램 개발을 위해 각 트랜잭션의 입출력 데이터를 결정하고  내부적인 제어 흐름을 상세히 설계 	1
0000	관계 DB 구축 단계 22 물리적 설계 단계 (3)  물리적 모델링의 산출물 - 내부 스키마는 릴레이션을 테이블로 표현하고  속성은 칼럼으로  관련성은 외부 키로 표현하며  데이터 타입과 크기  제약조건 등을 포함한다. - 내부 스키마를 선정한 DBMS의 DDL로 기술해도 된다. (구현 단계에서 DDL로 기술할 수도 있음) 릴레이션 스키마  무결성 제약조건 Input 물리적 모델링 Output 내부 스키마(DDL로 기술)  뷰(View) 정의 인덱스 정의 ① 릴레이션은 테이블로  속성은 칼럼으로 표현 ② 관련성은 외부 키로 표현 ③ 데이터 타입과 크기  제약조건 등 표현 ④ 뷰와 인덱스 정의 	1
0000	관계 DB 구축 단계 23 DB 구현 및 테스트 단계 6. 구현 및 테스트 단계 (1) 구현 및 테스트란?  - 물리적 설계 단계가 완료된 다음  앞에서 선택한 DBMS로 DB를 생성하고  적절한 프로그래밍 언어나 개발 도구를 이용해서 트랜잭션을 처리하는 응용 프로그램을 구현한 후  충분한 테스트 단계를 거쳐서 전체적인 DB 구축을 완성하는 것이다. (2) 구현 단계의 주요 업무 - 설계된 DB 구조를 선택한 DBMS의 DDL로 작성한 다음 초기 데이터를 삽입하고  트랜잭션 처리를 위한 응용 프로그램을 작성하는 등의 업무 뿐만 아니라  추후 유지보수를 위한 문서화 작업도 주요 업무 가운데 하나이다.  설계된 DB 구조를 DDL로 작성 기존 DB를 새로운 DB로 변환 (옵션)  DB에 초기 데이터 적재(Loading) 구현 단계 의 주요 업무 트랜잭션 처리용 응용 프로그램 작성 유지보수를 위한 문서화 작업 	1
0000	관계 DB 구축 단계 24 DB 구현 및 테스트 단계 (3) 테스트 단계의 주요 업무 ① 생성된 DB 구조가 설계된 DB 구조와 일치하는지 확인한다. ② 응용 프로그램과 DB의 연동이 원활한지 확인한다. ③ 트랜잭션 유형별로 테스트 케이스를 선정하여  데이터 조작이 원활한지 확인한다. 	1
0000	관계 DB 구축 단계 25 관계 DB 구축의 6 단계와 각 단계별 결과물을 요약한 다음 내용을 완성하시오.  적용하기 적용하기 요구수집 및 분석 DBMS 선정 논리적 설계 구현 및 테스트 1) ER 다이어그램 2) 트랜잭션 명세서 1) 내부 스키마(DDL로 기술)  2) 뷰와 인덱스 정의 3)  트랜잭션 상세 설계서 1) DB 및 응용 프로그램 2) 유지보수를 위한 문서화 	1
0000	관계 DB 구축 단계 26 쉼터 쉼터 물감을 아끼면 그림을 그릴 수 없다. 꿈을 아끼면 성공을 그릴 수 없다. 자신을  노력을  실패를 아끼지 말고   자신의 꿈을 그려라!   	1
0000	데이터베이스 데이터베이스 9 회차 : 요구 수집 및 분석 단계 김은경 	1
0000	요구 수집 및 분석 단계 2 학습목표 동기유발 & 학습목표 학습내용 1. 요구 수집 및 분석 방법 학습목표 2. 요구 분석 명세서 작성 방법 1. 요구 수집 방법을 설명할 수 있다. 2. 요구 수집의 주요 산출물을 나열할 수 있다.   3. 요구 분석 단계의 핵심 업무를 설명할 수 있다. 1. 데이터 요구 분석 명세서 작성 시 유의사항을 나열할 수 있다. 2. 요구 사항의 특성에 대해 설명할 수 있다.  	1
0000	요구 수집 및 분석 단계 3 Lesson.  요구 수집 및 분석 방법 1. 요구 수집 방법 2. 요구 수집 산출물 3. 요구 분석 방법 4. 요구 분석 산출물 요구 수집 및 분석 방법 	1
0000	요구 수집 및 분석 단계 4 요구 수집 방법 1. 요구 수집 방법 (1) 요구 수집 단계의 핵심 업무 - 직·간접적인 방법을 통해서 사용자(고객)의에게 필요한 것이 무엇이며  또 사용자가 원하는 시스템이 무엇인지  사용자의 요구사항을 정확히 파악한다. (2) 요구 수집 방법 ① 요구 사항을 직접적 또는 간접적인 방법으로 수집할 수 있다.  - 직접적인 요구 수집 : 주요 사용자 및 업무 담당자와의 대화  인터뷰  회의 등을 통한 요구 수집 - 간접적인 요구 수집 : 온라인 설문조사 또는 설문지 배포  기존 문서 조사 등을 통한 요구 수집 ② 요구를 수집할 사용자 그룹 및 업무 담당자를 식별한다.  - DB를 사용할 사용자 그룹을 식별한다.   사용자 그룹(경영진 혹은 일반사원  숙련자 혹은 초보자 등)에 따라 요구사항이 달라질 수 있다.  - DB와 연동할 주요 응용 분야와 업무 담당자를 식별한다.  추후 DB와 연동하는 응용 프로그램 개발을 위한 요구사항을 수집한다.  - 업무 담당자는 요구 수집 및 분석의 타당성 검토에서 중요한 역할을 하며   사용자는 구축된 DB 및 응용 프로그램의 일관성 및 무결성 테스트에도 참여한다.  	1
0000	요구 수집 및 분석 단계 5 요구 수집 방법 ③ 범 기관적 제약조건을 파악한다.  - DB를 사용할 조직의 경영 정책이나 규정  조직 관리나 기획 정보 등을 파악한다.  요구사항에 어떻게 반영하느냐에 따라 요구 분석 결과가 달라진다. ④ 기존 문서를 조사한다.  - 기존 응용 프로그램과 관련된 매뉴얼과 각종 양식(Form)  보고서(Report)  차트(Chart) 등 기존 문서를 조사한다.  업무의 흐름을 파악할 수 있다.   추후 DB와 연동하는 응용 프로그램을 개발할 때 사용자가 익숙한 출력물(Output)을 참조할 수 있다.  ⑤ 운영 환경을 파악한다.  - DB를 운영할 컴퓨터 환경(DB 서버의 종류  시스템 구성  처리 속도 등)과 업무 환경(자동화 수준) 등을 파악한다.   추후 DB 구축 및 응용 프로그램 개발 시 참고자료가 된다.  	1
0000	요구 수집 및 분석 단계 6 요구 수집 방법 (3) 효율적인 인터뷰 방법 1) 인터뷰 대상 선정 - 주요 업무 담당자의 경우 직접적인 인터뷰를 통해서 정확하고 핵심적인 요구사항을 파악한다.   2) 질문 유형 구분 ① 열린 질문 :  응답자가 자유롭게 답할 수 있는 질문으로  요구 분석자가 질문에 대해 가능한 응답을 모두 예측하기 어려운 경우에 주로 사용한다.  예) 현 시스템에서 가장 많이 사용하는 기능은 무엇입니까? 예) 업무와 관련해서 현 시스템이 제공하지 않는 기능은 무엇입니까?  ② 닫힌 질문 :  응답자가 예/아니오 또는 단답형으로 답할 수 있는 질문으로  요구 분석자가 질문에 대한 가능한 응답을 모두 예측할 수 있는 경우에 주로 사용한다. 예) 이 보고서 양식이 편리하다고 생각합니까?  예) 현 시스템에는 출장을 신청하는 기능이 있습니까?  ③ 추가 질문 : 이전 질문과 연관된 질문이나 미흡한 응답에 대한 보충 질문 등이 해당되며  보다 구체적인 요구사항을 수집하기 위해서 사용한다.  예) 무엇 때문에 이 기능이 불편하다고 생각하십니까? 예) 이 보고서 양식이 불편한 이유는 무엇입니까?  	1
0000	요구 수집 및 분석 단계 7 요구 수집 방법 3) 인터뷰 할 때 주의사항 ① 효율적인 인터뷰 진행을 위해서 미리 해당 업무를 충분히 파악한다.  - 상세히 파악할수록 좋지만 전체 개발 시간이 한정되어 있으므로 제한된 시간 안에 최대한 업무를 파악하도록 노력한다. ② 닫힌 질문과 열린 질문을 적절한 혼합해서 인터뷰 할 내용을 사전에 충실히 준비한다.  - 인터뷰 할 내용을 작성해서 인터뷰 대상자에게 사전에 전달하여 미리 준비하도록 하는 것도 좋은 방법이다.  ③ 애매모호한 부분 없이 정확한 요구사항을 수집할 때까지 인터뷰를 반복한다.  - 무한정 인터뷰를 반복하기 어려우므로 항상 효율적인 진행을 염두에 두고 인터뷰한다.  ④ 이해가 되지 않으면 솔직하게 말하고  추가 질문을 통해서 정확한 요구사항을 수집한다. - 충분히 이해되지 않은 요구사항을 아는 채 하고 넘어가면 다음 단계에서 반드시 문제를 유발 하게 되므로  이해되지 않는 내용은 반드시 추가 질문을 해야 한다.  ⑤ 인터뷰의 시작 및 종료 시간을 사전에 정하고  반드시 정해진 시간 안에 인터뷰를 마치도록 한다. - 인터뷰 대상은 대개 고유한 업무가 따로 있으므로  한 번의 인터뷰에 너무 많은 시간을 사용하게 만들면 지속적으로 협조를 얻기가 어렵게 된다.  ⑥ 인터뷰 대상의 기분을 상하는 일이 없도록 언행에 유의한다.  - “이 업무에 대해 잘 모르시는 것 같군요.”와 같이 상대방의 기분을 상하게 하는 언사를 하게 되면  추후 원활한 협조를 기대하기 어렵게 된다.  	1
0000	요구 수집 및 분석 단계 8 요구 수집 방법 (4) 설문조사 할 때 유의사항 ① 응답자가 설문 내용이나 의도를 쉽게 파악할 수 있도록 설문 문항을 충분히 검토한다.  - 설문 문항이 잘못 개발되면 무성의한 답변을 얻게 되어 요구사항 수집에 큰 도움이 되지 않는다.  ② 요구 분석자가 질문에 대한 모든 응답을 예상할 수 있으면  가능한 닫힌 질문을 사용한다. - 예상 가능한 모든 응답을 예시로 제공해서 응답자가 쉽게 선택하도록 만든다.  ③ 응답자의 호기심과 기대를 자극할 수 있는 설문 문항을 개발하도록 노력한다.  - 보다 성의 있는 답변을 얻게 되어 요구사항 수집이 원활해진다. ④ 설문지는 온라인 또는 우편이나 직접 방문을 통해서 배포할 수 있다.   - 가능한 직접 방문해서 배포하고  기다렸다가 현장에서 설문지를 회수하는 것이 좋다.  	1
0000	요구 수집 및 분석 단계 9 요구 수집 산출물 요구 수집을 어떤 정해진 기한 내에 완벽하게 수행한다는 것은 매우 어려운 일이며  그렇다고 필요한 요구사항을 완벽하게 수집할 때까지 무한정 계속할 수도 없는 일이다. 따라서 정해진 기간 동안 요구사항을 수집한 다음  요구 분석 및 개념적 설계 단계를 진행하면서 빠졌거 나 불충분한 요구사항을 계속 수집해서 반영해야 합니다.  2. 요구 수집 산출물 - 요구 수집 단계의 산출물로는 다음과 같은 것들이 있으며  이 밖에 조직이나 업무 특성에 따라 다양한 산출물이 포함될 수 있다.  ① 인터뷰 내용 ② 설문조사 내용 ③ 업무 흐름도 ④ 현재 사용 중인 시스템 분석도 ⑤ 범 기관적인 제약조건 ⑥ 기존 문서 조사 결과 ⑦ 기존 보고서 양식 ⑧ 컴퓨터 및 업무 환경 분석 결과 ⑨ 환경 변화에 따라 예상되는 새로운 요구사항 등 	1
0000	요구 수집 및 분석 단계 10 요구 분석 방법 3. 요구 분석 방법 (1) 요구 분석 단계의 핵심 업무 ① 업무 영역 분할 - 다양한 요구 수집 산출물을 기초로 업무 영역을 분할해서 업무 영역 분할도를 작성한다. ② 요구 분석 명세서 작성 (상세 업무 분석) - 요구 수집 산출물을 기초로 업무 영역별로 공식적인 요구 분석 명세서를 작성한다.  요구 분석 명세서는 데이터 중심 DB 설계 관점에서의 데이터 요구 분석 명세서와 처리 중심 DB 설계 관점에서의 트랜잭션 요구 분석 명세서를 구분해서 작성한다. ③ 요구사항 수용 범위 결정 - 요구 분석을 통해서 사용자의 모든 요구사항을 수용하기 보다는  고객과의 협상을 통해서 우선순위가 높고 제한된 기한 내에 구현 가능한 요구사항만 수용해야 한다. 	1
0000	요구 수집 및 분석 단계 11 요구 분석 방법 [요구 분석 단계의 핵심 업무] 	1
0000	요구 수집 및 분석 단계 12 요구 분석 방법 (2) 요구 분석이 중요한 이유 - 설계 오류는 유지보수에 많은 시간과 비용을 초래하고  구현 및 테스트 오류는 디버깅하는데 많은 시간과 노력을 초래하게 되지만  요구 분석에 오류가 발생하면 아무리 많은 시간과 노력을 투자해도 원하는 시스템을 구축하기 어려운 경우가 많기 때문에 DB 구축의 전 단계에 걸쳐서 요구 분석 단계가 가장 중요하다.  보충 학습 	1
0000	요구 수집 및 분석 단계 13 [보충 학습] [보충 학습]  소프트웨어 개발 시 발생하는 오류의 원인 분석 - 요구 분석과 관련된 오류가 48%를 차지하며  오류 수정 비용으로 환산하면 전체 비용의 약 75%를 차지한다.    많은 오류가 분석 단계에서 발생하므로 오류를 줄이기 위해서는 보다 철저하고 정확한 요구 분석이 요구된다.  부정확한 요구 요구 분석 오류 오류를 포함한 설계 한 요소의 설계 또는 구현 오류 운영 실수 오류 수정의 오류 기타 다음과 같이 수정:  	1
0000	요구 수집 및 분석 단계 14 요구 분석 방법 (3) 요구 분석이 어려운 이유 1) 의사소통(Communication)의 어려움 - 개발자(요구 분석자)와 사용자(고객) 간의 원활하지 못한 의사소통이 효율적인 요구 분석을 방해한다. a) 개발자 : DB 시스템에 대한 이해도는 높지만  대개 해당 업무에 대한 이해도가 낮다. b) 사용자 : 업무에 대한 이해도는 높지만  대개 DB 시스템에 대한 이해도가 낮다. 2) 요구사항의 변경 - 사용자의 요구사항이 변경되는 경우가 빈번히 발생한다.  사용자의 소속 부서나 직위에 따라 요구사항이 상반되는 경우가 발생한다.  특정 업무에 대해서 사용자가 일관성 있는 프로세스를 제시하지 못하는 경우도 있다. 3) 문서화의 어려움 - 요구사항의 명세화 자체가 어려운 일이고  개발자도 문서화에 익숙하지 않은 경우가 많다.  특히 애매모호한 요구사항은 문서화하는데 많은 시간이 소요된다.  문서화 이후에도 요구사항이 변경될 수 있으므로 문서화에 오류가 포함될 가능성이 많다. 	1
0000	요구 수집 및 분석 단계 15 요구 분석 결과물 4.  요구 분석 결과물 - 요구 수집의 결과물을 기초로 업무 영역을 분할 (필요한 경우 업무 영역 분할도 작성)한 다음  각 업무 영역별로 요구 분석 명세서를 작성한다.  - 요구 분석 명세서는 데이터 중심 설계에 초점을 맞춘 데이터 요구 분석 명세서와 처리 중심 설계에 초점을 맞춘 트랜잭션 요구 분석 명세서로 구분해서 작성한다. . 인터뷰 내용 . 설문조사 내용 . 업무 분장표 . 업무흐름도 . 현 시스템 분석도 . 범 기관적 제약조건 . 기존 문서 조사 결과 . 기존 보고서 양식 등 Input 요구 분석 Output 업무 영역 분할도  요구 분석 명세서 (데이터 및 트랜잭션) 	1
0000	요구 수집 및 분석 단계 16 Lesson.   요구 분석 명세서 작성 방법 1. 업무 영역 분할도 2. 데이터 요구 분석 명세서 3. 트랜잭션 요구 분석 명세서 4. 요구 분석 시 유의사항 5. 요구 분석 명세서 검토 방법 요구 분석 명세서 작성 방법 	1
0000	요구 수집 및 분석 단계 17 업무 영역 분할도 #1: 실제로 DB(디비)를 구축한다면 훨씬 많은 업무 영역으로 분할되며  또 각 업무 영역이 여러 개의 하위 영역으로 분할될 수 있겠지만   여기에서는 그 가운데 일부분만 제시한 것입니다.  1. 업무 영역 분할도 (1) 업무 영역 분할도란?   - 전체 업무를 요구 분석의 기본 단위가 되는 소단위의 업무 영역으로 분할해서 계층구조 형태로 표현한 것이다.  조직의 업무 영역 분할이 명확한 경우  이 과정을 생략하고 기존에 분할된 업무 영역 단위로 요구사항을 분석해도 된다.  (2)  업무 영역 분할도 작성 사례 - 어떤 회사의 직원 및 교육코스 관리용 DB 구축을 위한 업무 영역 분할도 #1 [직원 및 교육코스 관리의 업무 영역 분할도] 직원 및 교육코스 관리 종업원 관리 부서 관리 교과코스 관리 수강 관리 강사 관리 정규직 관리 계약직 관리 내부 강사 관리 외부 강사 관리 	1
0000	요구 수집 및 분석 단계 18 데이터 요구 분석 명세서 * 추상화 – 불필요한 부분을 생 략하고 가장 중요한 부 분만 추출하는 것을 의 미한다.  2. 데이터 요구 분석 명세서 (1) 데이터 요구 분석 명세서란?   - 요구 분석 단계의 중요한 산출물로서  데이터 중심 DB 설계에 근거해서 업무별로 요구되는 데이터를 분석한 결과를 문서화한 것으로  일종의 업무처리 규정문이라고 볼 수 있다. (2) 데이터 요구 분석 명세서 작성 시 유의사항 ① 단순한 표준 문체를 사용한다.  - 구어체의 자유로운 표현은 자제하고  의미를 정확히 전달할 수 있도록 단순하고 명확하게 작성 한다.  ② 애매모호한 표현은 피하도록 한다.  - ‘교무처에서 수강신청 업무를 담당한다’라는 표현보다는  ‘교무처 학사팀의 수업지원 담당자가 수강신청 업무를 담당한다’라고 표현하는 것이 더 명확하다.  ③ 추상화 수준에 맞는 적절한 표현을 사용한다.  - 어떤 은행의 지점 위치를 구분해야 하는 경우  ‘천안’  ‘서울’ 등으로 표현하거나 상세한 주소 전체를 표현하기 보다는  ‘쌍용2동”  ‘종로2가’와 같이 지점의 위치를 구분할 수 있는 수준으로 표현하는 것이 적절하다.  	1
0000	요구 수집 및 분석 단계 19 데이터 요구 분석 명세서 ④ 지나치게 전문적인 용어보다는 일반적인 용어를 사용한다. - 일반 사용자도 이해할 수 있어야 하므로 가능한 일반적인 용어로 표현한다.   ⑤ 용어 간의 참조가 명확하도록 작성한다.  - ‘전화로 합격 여부를 통보한다’라고 표현하면 집전화인지 휴대폰인지 명확하지 않으므로 ‘휴대폰으로 합격 여부를 통보한다.’라고 작성하는 것이 명확하다.  ⑥ 가능한 주어  목적어  동사가 분명하도록 작성한다. - 개념적 설계 단계에서 주어나 목적어는 주로 ‘개체’가 되고  동사는 주로 ‘관계’가 된다. ⑦ 이음동의어와 동음이의어의 표현을 점검한다. - 여러 사용자로부터 요구사항을 수집하므로 동일한 의미로 다른 용어를 사용하거나  같은 내용을 다르게 표현하는 경우가 흔히 발생하므로  점검해서 일관성 있게 수정해야 한다. ⑧ 프로젝트(DB 구축)와 관련된 용어 사전 또는 자료 사전을 만들어서 사용한다.  - 특수한 용어나 애매모호한 용어  이음동의어나 동음이의어 등은 용어 사전을 만들어서 기록해 두면  전체적으로 용어의 일관성을 유지할 수 있으므로 오류를 예방할 수 있다.  	1
0000	요구 수집 및 분석 단계 20 데이터 요구 분석 명세서 데이터 요구 분석 명세서의 양식은 프로젝트를 수행하는 업체마다 다르지만  가능한 요구사항을 제안한 담당자 이름과 부서  필요한 경우 수집한 날짜 등을 명시하는 것이 좋습니다.  제목 :  종업원 관리 관련 데이터 요구 분석 명세서 No. 요구 분석 내용 담당 부서 담당자 1 각 종업원은 유일한 사원번호를 가지며  이름과 급여  입사일   근무부서   부양가족 정보가 필요하다.  총무팀 김영수 2 종업원은 정규직과 계약직으로 구분된다. 인사팀 이영호 3 종업원은 각자 한 부서에서만 근무한다. 인사팀 이영호 4 종업원은 신규 채용되거나 퇴직할 수 있다. 인사팀 이영호 5 종업원이 근무하는 부서이름 및 부서장 이름을 알 수 있어야 한다. 총무팀 김영수 6 종업원은 자신이 수강한 특정 교육코스의 성적 및 강사 이름을 알 수 있어야 한다.  교육팀 박준민 . . .  (4) 데이터 요구 분석 명세서 작성 사례 - 어떤 회사의 직원 및 교육코스 관리용 DB 구축을 위한 데이터 요구 분석 명세서 작성하기 	1
0000	요구 수집 및 분석 단계 21 데이터 요구 분석 명세서 제목 :  부서 관리 관련 데이터 요구 분석 명세서 No. 요구 분석 내용 담당 부서 담당자 1 각 부서에는 유일한 부서번호와 부서 이름이 부여되며  그 밖에 사무실 위치와 전화번호 등의 정보가 필요하다.  기획팀 민효진 2 모든 부서에는 한 명의 부서장이 있다.  기획팀 민효진 3 일시적으로 부서장이 없는 부서도 있을 수 있다.  기획팀 안수영 5 한 부서의 최소 급여 및 최대 급여를 받는 종업원을 알 수 있어야 한다. 총무팀 김영수 6 어떤 부서의 평균 급여를 알 수 있어야 한다. 총무팀 김영수 . . .  	1
0000	요구 수집 및 분석 단계 22 데이터 요구 분석 명세서 제목 :  교육코스 관리 관련 데이터 요구 분석 명세서 No. 요구 분석 내용 담당 부서 담당자 1 각 교육코스에는 유일한 코스번호가 부여되고  코스 이름  강사 이름 및 총 강의 시간 등을 관리한다.  교육팀 박준민 2 동일한 교육코스는 한 번에 한 반씩만 개설된다.  교육팀 박준민 3 동일한 교육코스라도 개설 일자에 따라 다른 강사가 강의할 수 있다.     교육팀 박준민 4 동일한 교육코스가 여러 번 개설될 수 있으므로 종업원이 수강한 날짜를 기록해야 한다.  교육팀 박준민 5 월별로 개설된 교육코스 및 수강 현황을 파악할 수 있어야 한다.  교육팀 박준민 . . .  	1
0000	요구 수집 및 분석 단계 23 데이터 요구 분석 명세서 제목 :  수강 관리 관련 데이터 요구 분석 명세서 No. 요구 분석 내용 담당 부서 담당자 1 한 종업원은 여러 교육 코스를 수강할 수 있으나   동일한 코스는 한 번만 수강 할 수 있다. 기획팀 민효진 2 종업원은 자신이 수강한 교육코스 내역을 확인할 수 있어야 한다.  교육팀 박준민 3 종업원이 수강한 교육코스와 수강 날짜  수료여부를 기록해야 한다.   교육팀 박준민 4 새로운 교육코스가 개설될 수 있다.  교육팀 박준민 5 기존 교육코스가 더 이상 개설되지 않을 수 있다.  교육팀 박준민 . . .  	1
0000	요구 수집 및 분석 단계 24 데이터 요구 분석 명세서 제목 :  강사 관리 관련 데이터 요구 분석 명세서 No. 요구 분석 내용 담당 부서 담당자 1 강사는 외부 강사와 내부 강사로 구분한다.  기획팀 민효진 2 외부 강사인 경우 별도의 강사번호를 부여하고  강사이름과 강사 등급  강의한 교육코스 등을 관리한다.  기획팀 민효진 3 한 명의 강사가 여러 교육코스를 강의할 수 있다. 교육팀 박준민 4 강사 등급은 1  2  3 등급으로 구분된다.  기획팀 민효진 5 강사 등급에 따라 강사료를 차등 지급한다.  총무팀 김영수 6 시간당 강사료는 1등급은 20만원  2등급은 15만원  3등급은 10만원이다. 총무팀 김영수 7 강사 등급은 경력에 따라 결정된다.  총무팀 김영수 8 10년 이상 경력은 1등급  5년 이상은 2등급  나머지는 3등급으로 구분한다.  총무팀 김영수 . . .  	1
0000	요구 수집 및 분석 단계 25 트랜잭션 요구 분석 명세서 3. 트랜잭션 요구 분석 명세서 (1) 트랜잭션 요구 분석 명세서란?   - 요구 분석 단계의 중요한 산출물로서  처리 중심 DB 설계에 근거해서 업무별로 요구되는 트랜잭션 즉  데이터 조작 작업을 문서화한 것이다. (2) 트랜잭션 요구 분석 명세서 작성 시 유의사항 ① 분할된 업무 영역별로 요구되는 데이터 조작 작업을 간단히 표현한다. ② 한번에 하나의 데이터 조작만 포함하도록 작성한다.  ③ 데이터 조작을 가능한 검색  삽입  삭제  변경이라는 용어를 사용해서 표현한다.  ④ 추후 트랜잭션 처리용 응용 프로그램을 작성할 때 참조가 되도록 작성한다.  	1
0000	요구 수집 및 분석 단계 26 트랜잭션 요구 분석 명세서 트랜잭션 요구 분석 명세서의 양식도 프로젝트를 수행하는 업체마다 다르지만  여기에서는 담당자와 담당 부서만을 포함해서 간단히 작성했 습니다. 그리고 트랜잭션 요구 분석 내용 가운데 데이터 요구 분석 내용과 유사한 것도 있는데  전자는 추후 개체와 관계를 식별하는데 기 초가 되어야 하고  후자는 추후 응용 프로그램을 작성할 때 기초가 되어야 한다는 것을 기억하세요.  (3) 트랜잭션 요구 분석 명세서 작성 사례 - 어떤 회사의 직원 및 교육코스 관리용 DB 구축을 위한 트랜잭션 요구 분석 명세서 작성하기 제목 :  종업원 관리 관련 트랜잭션 요구 분석 명세서 No. 요구 분석 내용 담당 부서 담당자 1 새로운 종업원 정보를 삽입한다.  인사팀 이영호 2 기존 종업원의 급여를 변경한다.  인사팀 이영호 3 기존 종업원의 부서 정보를 변경한다.  인사팀 이영호 4 퇴직한 종업원 정보는 삭제한다.  인사팀 이영호 5 회사 전체 종업원의 평균 급여와 최소 및 최대 급여를 받는 종업원을 검색한다. 인사팀 이영호 6 종업원이 자신의 급여를 검색한다. 인사팀 이영호 7 종업원이 근무하는 부서장의 이름을 검색한다. 총무팀 김영수 . . .  	1
0000	요구 수집 및 분석 단계 27 트랜잭션 요구 분석 명세서 제목 :  부서 관리 관련 트랜잭션 요구 분석 명세서 No. 요구 분석 내용 담당 부서 담당자 1 부서장이 자신의 부서에 근무하는 모든 종업원의 명단을 검색한다. 총무팀 김영수 2 어떤 부서의 최소 급여 및 최대 급여를 받는 종업원을 검색한다. 총무팀 김영수 3 어떤 부서의 평균 급여를 확인한다. 총무팀 김영수 4 새로 만든 부서 정보를 삽입한다.  총무팀 김영수 5 기존 부서의 정보를 수정한다.  총무팀 김영수 . . .  	1
0000	요구 수집 및 분석 단계 28 트랜잭션 요구 분석 명세서 제목 :  교육코스 관리 관련 트랜잭션 요구 분석 명세서 No. 요구 분석 내용 담당 부서 담당자 1 지금까지 개설한 모든 교육코스를 검색한다. 교육팀 박준민 2 월별로 개설된 교육코스를 파악한다.  교육팀 박준민 3 교육코스의 교육기간을 변경한다. 교육팀 박준민 4 새로 개설할 교육코스를 삽입한다. 교육팀 박준민 5 부서장이 종업원의 교육코스 수강 현황을 검색한다.  교육팀 박준민 6 월별로 개설된 교육코스 및 수강 현황을 검색한다.  교육팀 박준민 . . .  	1
0000	요구 수집 및 분석 단계 29 트랜잭션 요구 분석 명세서 제목 :  수강 관리 관련 트랜잭션 요구 분석 명세서 No. 요구 분석 내용 담당 부서 담당자 1 종업원이 자신이 지금까지 수강한 모든 교육코스를 검색한다. 기획팀 민효진 2 종업원이 자신이 수강한 특정 교육코스의 강사 이름을 검색한다.  교육팀 박준민 3 부서별로 종업원들이 특정 기간 동안 교육코스를 수강한 현황을 파악한다.  교육팀 박준민 4 월별로 개설된 교육코스 및 수강 현황을 파악한다.  교육팀 박준민 5 새로운 교육코스를 삽입한다.  교육팀 박준민 6 기존 교육코스를 삭제한다.  교육팀 박준민 . . .  	1
0000	요구 수집 및 분석 단계 30 트랜잭션 요구 분석 명세서 제목 :  강사 관리 관련 트랜잭션 요구 분석 명세서 No. 요구 분석 내용 담당 부서 담당자 1 새 강사의 정보를 삽입한다.  총무팀 김영수 2 기존 강사 정보를 변경한다. 총무팀 김영수 3 강사의 시간당 강사료를 검색한다.  총무팀 김영수 4 강사가 강의한 모든 교육코스를 검색한다. 총무팀 김영수 . . .  	1
0000	요구 수집 및 분석 단계 31 요구 분석 시 유의사항 3. 요구 분석 시 유의사항 (1) 요구 사항의 특성 ① 요구사항은 계속 변화한다.  - 동일한 사용자라도 시간이 경과함에 따라 요구사항이 변할 수 있음을 염두에 두고 분석한다.   ② 요구사항은 점차 확장된다.  - 초기에는 사용자가 전산화에 대한 이해가 부족해서 요구사항을 정확히 표현하지 못하지만   시간이 지남에 따라 요구사항이 추가될 수 있음을 염두에 두고 분석한다. ③ 요구사항은 불완전하다. - 요구사항이 다소 애매모호하더라도 분석 과정에서 대화와 협의를 통해서 구체화시켜야 함을 염두에 두고 분석한다.  ④ 요구사항은 생명주기가 있다.  - 요구사항도 생성과 소멸이라는 생명주기를 갖는다. 즉  환경 변화 등의 요인으로 인해 새로운 요구사항이 등장하거나 기존 요구사항이 불필요하게 될 수 있음을 염두에 두고 분석한다.  	1
0000	요구 수집 및 분석 단계 32 요구 분석 시 유의사항 (2)  일반적인 유의 사항 ① 수집된 요구사항을 분석할 뿐만 아니라 빠뜨린 요구사항이 있으면 추가로 수집하고  더 나아가서 가까운 미래를 대비하기 위한 요구사항은 무엇인지 예측하는 것도 필요하다.   ② 사용자마다 동일한 요구사항을 중복해서 제시하거나 서로 상반되는 요구사항을 제시할 수 있으므 로  불필요한 중복은 제거하고 요구사항의 일관성이 보장되도록 조정해야 한다.  ③ 다양한 요구를 체계적으로 분석해서 단일화된 형태의 업무처리 규정을 만들어야 한다.  - 특히 부서별 또는 업무 담당자 별로 요구사항이 상충되는 경우  사전 협의를 통해서 요구사항을 단일화해야 한다.  ④ 업무 담당자가 아닌 전산 담당자가 요구 분석 과정에 참여하는 경우  업무 담당자나 주요 사용자가 요구분석의 최종 산출물을 검토하도록 요청한다.   	1
0000	요구 수집 및 분석 단계 33 데이터 요구 분석 명세서 검토 방법 4. 요구 분석 명세서 검토 방법 - 다음과 같은 질문을 통해서 데이터 요구 분석 명세서(또는 업무처리 규정문)가 제대로 작성되었는지 검토한다. ① 요구사항이 이해하기 쉽게 작성되었는가?  ② 요구사항이 정확히 표현되었는가?  ③ 요구사항이 애매모호하지는 않는가?  ④ 요구사항이 사용자의 필요를 충족시키는가?  ⑤ 반드시 필요한 요구사항인가?  ⑥ 제한된 기한을 고려할 때 수용할 수 있는 요구사항인가?  - 요구 분석자와 업무 담당자 또는 사용자가 함께 검토하는 것이 좋다. - 검토를 통해서 불필요한 요구사항이나 기한 내 수용할 수 없는 요구사항은 고객과 협의해서 제외시키는 것이 바람직하다.  	1
0000	요구 수집 및 분석 단계 34 한 개인이 운영하는 온라인 쇼핑몰에서 판매 상품과 고객 정보를 관리하는 DB를 구 축하려고 한다. 이 쇼핑몰에서는 주로 오프라인 매장에서 구입한 여성복을 온라인에 서 판매하고 있다.  이런 유형의 소규모 온라인 쇼핑몰을 가정하여  먼저 업무 영역 을 분할한 다음  요구 수집 및 분석을 통해서 데이터 및 트랜잭션 요구 분석 명세서 를 작성해 보시오.    1) 업무 영역 분할도 작성 - 업무 영역 분할은 요구 수집에 따라 달라질 수 있지만  여기서는 4개 영역으로 분할해 보시오.  적용하기 적용하기 온라인 쇼핑몰 	1
0000	요구 수집 및 분석 단계 35 적용하기 제목 :  소규모 온라인 쇼핑몰을 위한 데이터 요구 분석 명세서 No. 요구 분석 내용 관련 업무 1 2 3 4 5 6 7 8 9 10 2) 데이터 요구 분석 명세서 작성 - 업무 별로 구분해서 데이터 요구 분석 명세서를 작성해도 되지만  다음 테이블에 한꺼번에 작성하고 관련 업무를 표시한다.  	1
0000	요구 수집 및 분석 단계 36 적용하기 제목 :  소규모 온라인 쇼핑몰을 위한 트랜잭션 요구 분석 명세서 No. 요구 분석 내용 관련 업무 1 2 3 4 5 6 7 8 9 10 2) 트랜잭션 요구 분석 명세서 작성 - 업무 별로 구분해서 트랜잭션 요구 분석 명세서를 작성해도 되지만  다음 테이블에 한꺼번에 작성하고 관련 업무를 표시한다.  	1
0000	요구 수집 및 분석 단계 37 쉼터 쉼터 모든 것은 자신과의 경쟁이다!  누구에게나 본질적으로 중요한 것은 자신의 마음 속에서 결정된다. 모든 것은 자신과의 경쟁이다. 가장 수준이 낮은 경쟁은 타인과 대상을 제압하고 정복하려는 경쟁이다. 가장 수준 높은 경쟁은 자신과의 경쟁이다. 자신의 내면에서 울려 퍼지는 영혼의 목소리를 듣고 그 목소리에 화답하려는 치열한 싸움이 자신과의 경쟁이다. 진정한 승리자는 자신과의 싸움에게 이긴 사람이다.  	1
0000	데이터베이스 데이터베이스 10 회차 : 개념적 설계 단계 김은경 - Story board - 	1
0000	개념적 설계 단계 2 학습목표 동기유발 & 학습목표 학습내용 1. 개념적 모델링 학습목표 2.  ERD 작성 1. 개체 식별 방법에 대해 설명할 수 있다.  2. 관계 식별 방법에 대해 설명할 수 있다. 3. 속성 식별 방법에 대해 설명할 수 있다. 1. ER 모델 표현 방법에 대해 설명할 수 있다.  2. ERD 작성 단계를 순서대로 나열할 수 있다.  	1
0000	개념적 설계 단계 3 Lesson.  개념적 모델링 1. 개념적 설계 개요 2. ER 모델 도출 방법 3. 개체 식별 4. 관계 식별 5. 속성 식별 개념적 모델링 방법 	1
0000	개념적 설계 단계 4 개념적 설계 개요 1. 개념적 설계 개요 (1) 개념적 설계(Conceptual Design)란?   - 요구분석 명세서를 토대로 DBMS와는 무관한 추상적인 형태로 사용자 요구사항을 표현하는 것이다. (2) 개념적 설계의 주요 업무 ① 개념적 모델링  데이터 중심의 DB 설계에 해당하며  데이터 요구분석 명세서를 기초로 ER 모델을 도출하고   ER 다이어그램(ERD)으로 표현한다.  ② 트랜잭션 모델링  처리(프로세스) 중심의 DB 설계에 해당하며  트랜잭션 요구분석 명세서를 기초로 업무 단위의 유형별 트랜잭션을 설계한다.  (3) 개념적 모델링의 입출력 데이터 요구 분석 명세서 Input 개념적 모델링 Output ER 모델 (ER 다이어그램) 	1
0000	개념적 설계 단계 5 ER 모델 도출 방법 2. ER 모델 도출 방법 (1) ER 모델 도출의 핵심 업무 - 요구분석 단계의 산출물인 데이터 요구분석 명세서를 기초로 주요 개체와 관계를 식별한다.    (2) ER 모델 도출 순서 ① 데이터 요구 분석 명세서를 기초로 핵심 개체 타입을 식별한다. ② 개체 타입들 간의 관계 타입을 식별한다.  ③ 관계 타입의 유형과 카디널리티(옵션)를 결정한다.  ④ 개체 타입의 속성을 식별한다. ⑤ 개체 타입의 식별자(후보 키)를 결정한다.  ⑥ 관계 타입의 속성을 식별한다. ⑦ 개체 타입과 관계 타입  그리고 속성을 모두 ERD로 표현한다.  ⑧ ERD가 요구 분석 명세서에 포함된 모든 요구사항을 반영하고 있는지 검증한다.  관련 학습 – 5회차  1. ER 모델이란?   	1
0000	개념적 설계 단계 6 ER 모델 도출 방법 (3)  ER  모델 도출 시 유의사항 ① ER 모델은 논리적 설계 단계에서 관계 데이터 모델로 변환되어야 하므로  논리적 설계와 무관하지 않다는 것을 명심해야 한다.  ② ER 모델에 포함된 개체는 논리적 데이터 모델과 물리적 데이터 모델에도 그대로 존재해야 한다.  - 논리적 또는 물리적 설계 단계에서 핵심 개체가 사라지거나 새로 생긴다면 ER 모델이 잘못 도출된 것이다.  ③ 주요 개체 식별이 DB 설계의 성패를 좌우하게 되므로 핵심적인 개체를 식별하는데 집중한다.  - 상대적으로 덜 중요한 개체를 식별하는데 너무 많은 시간을 사용하지 않아야 한다.  	1
0000	개념적 설계 단계 7 개체 식별 3. 개체 식별 (1) 개체(Entity)란?  - DB가 표현하려고 하는 유형  무형의 정보 대상으로  존재하면서 서로 구별될 수 있는 요소이다. (2) 개체 식별의 중요성 - 설계 단계에서 개체를 식별하는 것은 가장 중요하면서도 가장 어려운 일이며  어떤 개체가 식별되느냐 에 따라 속성과 관계가 달라질 수 있다.  - 개체 하나에 평균 5개 정도의 응용 프로그램이 개발되므로 개체 식별이 DB 구축의 성패를 좌우한다고 해도 과언이 아니다.  (3) 개체 식별 방법 ① 개체 후보 식별 - 데이터 요구 분석 명세서에서 주로 주어나 목적어로 표현된 것이 개체 후보에 해당한다. ② 개체 후보 검토 - 각 개체 후보의 실제 데이터 수와 대표 속성을 파악한다.  - 동음이의어나 이음동의어 등도 검토한다. - 동사로 표현된 것이 개체로 잘못 추출된 것이 있는지 검토하고  필요한 경우 개체 이름도 변경한다. ③ 최종 개체 선정 - 실제 데이터(개체 인스턴스)가 2개 이상 존재하고  2개 이상의 속성을 갖고 있는 개체 후보를 최종 개체로 선정한다.  - 동일한 의미를 갖는 개체가 있으면 제외시킨다.  관련 학습 – 5회차  2. 개체 	1
0000	개념적 설계 단계 8 개체 식별 (4) 개체 표현 방법 1) 피터 첸 표기법 - 하나 이상의 속성과 연결된 직사각형으로 표현하고  식별자(기본 키)는 밑줄로 표시한다.  예)  2) IE(Information Engineering: 정보공학) 표기법 - 개체를 사각형으로 표현하고   사각형 위에 개체 이름을 표시한다.  [학생 개체 표현]  학생 학번 이름 전공 연락처 식별자 (기본 키) [학생 개체 표현]  학번 이름 전공 연락처 개체이름 학생 식별자(기본 키) 	1
0000	개념적 설계 단계 9 개체 식별 (5) 개체 이름 부여 시 유의사항 ① 개체 이름은 반드시 DB 내에서 유일해야 한다.  ② 현업에서 익숙한 표준 용어를 사용한다.  ③ 단수 명사를 사용한다.   ④ 가능한 약어는 사용하지 않는다.  ⑤ 개체의 성격을 쉽게 알 수 있는 이름을 부여한다.  ⑥ 이름의 일관성을 위해 이름 부여 규칙을 미리 정하는 것이 좋다.  ⑦ 프로젝트(DB 구축)와 관련된 자료 사전 또는 용어 사전을 만들어서 참조하는 것이 좋다.    - 사전에 각 개체에 대한 명확한 정의를 포함시키는 것이 좋음 	1
0000	개념적 설계 단계 10 개체 식별 (5) 개체 식별 시 유의사항 ① 개체가 될 가능성이 있는 모든 대상을 추출한다. - 데이터 요구 분석 명세서에서 주로 주어나 목적어가 개체에 해당한다.     ② 유사한 개체(예: 이음동의어)도 무시하지 말고 모두 추출한다. - 일단 추출한 다음 업무 담당자와 협의를 통해서 정확한 의미를 파악하여 다른 개체와 합치거나 별도의 개체로 분리한다.   ③ 어떤 대상이 해당 개체에 속하는 지가 분명하도록 각 개체를 정의한다. 즉  대상의 동질성 유무를 쉽게 파악할 수 있도록 정의한다.  예) ‘학생’ 개체 1) 학생을 ‘우리 대학에 재학 중인 사람’으로 정의하는 경우  수시 합격생이나 졸업생  수료생은 학생 개체에 속하지 않는다. 2) 학생을 ‘우리 대학에 재학 중이거나 재학할 예정 또는 재학한 적이 있는 사람’으로 확대해서 정의하면  수시 합격생  졸업생  수료생도 학생 개체에 속하게 된다.  ④ 업무 처리 과정을 지나치게 고려하지 않는다. - 업무 처리 과정에 기초해서 개체를 추출하면  추후 업무 처리 과정이 달라지는 경우 데이터 모델이 달라질 수 있으므로  데이터 중심 설계에 초점을 맞추어 추출한다.  ⑤ 개념이 명확하지 않은 대상은 업무 담당자에게 다시 확인한다. - 유사한 프로젝트에 참여한 경험을 기초로 분석자가 임의로 유추하지 않아야 한다.  ⑥ 예외 상황은 무시하고 넘어간다. - 예외 처리가 중요하지만  개념적 설계 단계에서는 핵심 개체를 추출하는데 더 집중한다.   ⑦ 개체 후보 가운데 최종적으로 선정된 개체는 핵심적인 특징을 파악해 본다. - 개체의 특징을 설명하는 속성이 2개 이상 존재해야 하므로  그렇지 않은 경우 개체에서 제외되어야 한다.   	1
0000	개념적 설계 단계 11 개체 식별 (6) 개체 식별 사례 - 소규모 온라인 쇼핑몰의 데이터 요구 분석 명세서를 기초로 핵심적인 개체 후보 추출하기 개체 후보 식별 제목 :  소규모 온라인 쇼핑몰을 위한 데이터 요구 분석 명세서 No. 요구 분석 내용 관련 업무 1 쇼핑몰 운영자는 한 명이다.  전체 2 주요 판매 상품은 여성복이다. 상품 관리 3 여성복은 상의와 하의로 구분하고  이름  사이즈  구매가격  판매가격을 관리한다.  상품 관리 4 각 상품을 구매한 오프라인 상점과 구매 금액을 관리한다. 거래처 관리 5 거래처 이름과 사업자등록번호  연락처  주소  대표자이름  대표자연락처 정보를 관리한다.  거래처 관리 6 고객이 구매하려면 실명 확인을 통해서 회원 가입을 해야 한다.  고객 관리 7 고객의 id  pw이름  주민등록번호  휴대폰번호  주소 정보를 저장한다.  고객 관리 8 판매 시 주문 일자와 배송 일자를 기록해야 한다.  판매 관리 9 고객에서 여성복을 판매한다.  판매 관리 10 일별 또는 월별로 판매된 상품과 금액을 관리한다.  판매 관리 	1
0000	개념적 설계 단계 12 개체 식별 개체 후보 목록은 데이터 요구 분석 명세서에 포함된 주어나 목적어를 중심으로 개체 후보를 모두 추출한 것으로  이 가운데 일부는 개념적 설 계 단계에서 제외될 수 있습니다. 또한 이름  판매 금액  연락처와 같은 목적어는 개체 후보 목록에 빠져있는데 왜 그럴까요? 그 이유는 개체가 아 닌  개체의 속성임이 분명하기 때문에 제외시킨 것입니다. 만약 요구 분석이 처음이어서 개체인지 또는 속성인지를 판단하기 어렵다면 일단 모두 개체 후보로 추출해도 됩니다.   1) 개체 후보 식별 - 데이터 요구 분석 명세서에서 주어나 목적어로 표현된 것 가운데 식별한다.    [개체 후보 목록] ① 쇼핑몰운영자 ② 판매상품 ③ 여성복 ④ 상의 ⑤ 하의 ⑥ 사이즈 ⑦ 상품구매 ⑧ 오프라인상점 ⑨ 거래처 ⑩ 고객 ⑪ 고객구매 ⑫ 회원 ⑬ 판매 개체 후보 검토 이름이나 판매 금액  연락처 등 과 같이 주어나 목적어로 표현되 어 있지만 개체가 아닌 개체의 속성임이 분명한 것은 처음부터 개체 후보에서 제외시킬 수 있다.  	1
0000	개념적 설계 단계 13 개체 식별 2) 개체 후보 검토 - 각 개체 후보의 실제 데이터 수와 대표 속성을 파악하고  동음이의어나 이음동의어 등도 검토한다. - ‘동사’로 표현된 것이 개체로 잘못 추출된 경우 제외시키고   필요한 경우 개체 이름도 변경한다.  No. 개체 후보 데이 터 수 대표 속성 비고 최종 개체 선정 여부 1 쇼핑몰운영자 1개 X 2 판매상품 N개 구분(상의  하의)  이름   사이즈  가격 등 개체이름을 ‘상품’으로 변경 O 3 여성복 N개 판매상품과 동일 X 4 상의 N개 여성복의 구분 X 5 하의 N개 여성복의 구분 X 6 사이즈 3개 구분 1개 속성만 존재 X 7 상품구매 N개 상품명  거래처이름  금액  구매일자   수량 등 개체이름을 ‘구매’로 변경 O 8 오프라인상점 N개 거래처와 동일 X 9 거래처 N개 이름  연락처  주소 등 O 10 고객 N개 Id  pw  이름  휴대폰번호  주소 등 O 11 고객구매 N개 판매와 동일 X 12 회원 N개 고객과 동일 X 13 판매 N개 고객id  상품명  판매일자  수량   배송일자 등 동사(판매한다)로 표현됨 X 최종 개체 선정 	1
0000	개념적 설계 단계 14 개체 식별 최종 선정된 개체 가운데 일부는 ‘관계’로 표현하는 것이 더 바람직할 수 있습니다. 따라서 이 목록은 개체 식별 단계에서의 최종 개체 목록이며  관계를 분석한 다음에는 변경될 수 있습니다.  3) 최종 개체 선정 - 실제 데이터 수가 1개 밖에 없거나  2개 이상의 속성이 없는 것  그리고 동일한 의미의 개체가 있으면 제외시킨다.  No. 개체 후보 대표 속성 1 상품 구분(상의  하의)  이름   사이즈  가격 등 2 구매 상품명  거래처이름  금액  구매일자  수량 등 3 거래처 이름  연락처  주소 등 4 고객 Id  pw  이름  휴대폰번호  주소 등 [최종 선정된 개체 목록]  이 목록은 개체 식별 단계 에서의 최종 개체 목록이며   관계를 분석한 다음에는 변 경될 수 있음 	1
0000	개념적 설계 단계 15 관계 식별 4. 관계 식별 (1) 관계(Relationship)란?  - 개체들 간의 의미 있는 연결 또는 연관성을 의미하는 요소이다. (2) 관계 식별의 중요성 - 관계를 제대로 식별하지 못하면 동일한 속성이 많은 개체에 중복되어 관리되므로 데이터의 일관성을 보장하기 어렵게 된다.  (3)  관계 식별 방법 ① 데이터 요구 분석 명세서에서 동사로 표현된 부분이 개체들 간의 관련성을 표현하는 경우 관계로 식별한다.  ② 식별된 개체 가운데 ‘관계’로 표현하는 것이 더 적합한 것은 관계로 전환한다.  ③ 관계 이름을 부여한다.  ④ 관계 유형을 결정한다.  (필요한 경우 카디널리티도 결정함)  ⑤ 관계를 설명하는 속성을 파악한다.  관련 학습 – 5회차  4. 관계 	1
0000	개념적 설계 단계 16 관계 식별 (4)  관계 식별 시 유의사항 - 관계란 개체들 간의 상호연관성으로서  개체와 관련된 업무를 수행하는 일종의 업무규칙에 해당한다.  데이터 요구 분석 명세서에서 주로 동사로 표현된다.  - 업무를 충분히 파악한 다음  전체 업무를 고려해서 넓은 시각으로 분석해야 한다.  - 업무 규칙이 변경됨에 따라 관계도 변경될 수 있음을 염두에 둔다. - 식별된 개체 가운데 ‘관계’로 표현하는 것이 적합한 것이 있는지 검토한다.   관계 데이터 모델에서 관계도 개체와 마찬가지로 하나의 릴레이션(테이블)으로 변환되며   초보자가 개체와 관계를 명확히 구분하는 것은 쉽지 않다.    	1
0000	개념적 설계 단계 17 관계 식별 (5) 관계 표현 방법 1) 피터 첸 표기법 - 두 개의 개체를 실선으로 연결하는 마름모로 표현하고  관계 유형을 실선 위에 표시한다.  예)  교수 학생 사번 지도하다 이름 소속 학번 이름 전공 1 n 연락처 	1
0000	개념적 설계 단계 18 관계 식별 • 비식별 관계 타입 – 식별 관계 타입이 아닌 일반 관계를 의 미한다.  • 식별 관계 타입 - 약한 개체 타입을 강한 개체 타입과 연 관시켜서  약한 개체를 유일 하게 식별하도록 하는 관계를 의미한다. 2) IE 표기법 - 개체를 선(비식별 관계 타입은 점선  식별 관계 타입은 실선)으로 연결하고  선 위에 관계 이름을 표시한다. - 개체 간의 관계를 나타내는 외래 키(FK: Foreign Key)를 두 개체 가운데 하나에 포함시킨다.    - 관계의 유형을 다음과 같은 까마귀발(crow’s foot) 모양으로 표현함 ① : 0 혹은 1을 의미함 (부분 참여) ② | :   1을 의미함 (전체 참여)  ③ : N(>= 0)을 의미함 (부분 참여) ④ : N(>= 1)을 의미함 (전체 참여) IE(아이이) 표기법에서 관계를 표현하는 또 다른 방법도 있는데  그 방법에 대해서는 11회차에서 설명하도록 하겠습니다.  학번 이름 전공 연락처 지도교수사번(FK) 학생 사번 이름 소속 교수 지도하다 1:N 관계에서 1측의 부분 참여 표현 1:N 관계에서 N측의 전체 참여 표현 외래 키 O 	1
0000	개념적 설계 단계 19 관계 식별 (6) 관계 이름 부여 시 유의 사항 ① 가능한 두 개체의 연관성을 나타내는 동사로 표현한다.   예) 지도하다. 수강하다  근무하다 ② 현재 시제로 표현한다.  ③ 개체들 간의 관련성이 명확하도록 표현한다.  ④ 관계 이름은 DB 내에서 유일해야 한다.  - 관계 데이터 모델에서 관계도 하나의 릴레이션(테이블)에 해당하므로 유일한 이름을 가져야 함 ⑤ 부연 설명이 필요 없는 일반적인 용어로 표현한다.  	1
0000	개념적 설계 단계 20 관계 식별 (7) 관계 식별 사례 - 소규모 온라인 쇼핑몰의 데이터 요구 분석 명세서와 앞에서 식별된 최종 개체 목록을 기초로 주요 관계 추출하기 관계 분석 제목 :  소규모 온라인 쇼핑몰을 위한 데이터 요구 분석 명세서 No. 요구 분석 내용 관련 업무 1 쇼핑몰 운영자는 한 명이다.  전체 2 주요 판매 상품은 여성복이다. 상품 관리 3 여성복은 상의와 하의로 구분하고  이름  사이즈  구매가격  판매가격을 관 리한다.  상품 관리 4 각 상품을 구매한 오프라인 상점과 구매 금액을 관리한다. 거래처 관리 5 거래처 이름과 사업자등록번호  연락처  주소  대표자이름  대표자연락처 정 보를 관리한다.  거래처 관리 6 고객이 구매하려면 실명 확인을 통해서 회원 가입을 해야 한다.  고객 관리 7 고객의 id  pw이름  주민등록번호  휴대폰번호  주소 정보를 저장한다.  고객 관리 8 판매 시 주문 일자와 배송 일자를 기록해야 한다.  판매 관리 9 고객에서 여성복을 판매한다.  판매 관리 10 일별 또는 월별로 판매된 상품과 금액을 관리한다.  판매 관리 No. 개체 후보 대표 속성 1 상품 구분(상의  하의)  이름   사이즈  가격 등 2 구매 상품명  거래처이름  금액  구매일자  수량 등 3 거래처 이름  연락처  주소 등 4 고객 Id  pw  이름  휴대폰번호  주소 등 	1
0000	개념적 설계 단계 21 관계 식별 1) 데이터 요구 분석 명세서에서 동사 부분 검토 No. 요구 분석 검토 항목 관련성 분석 1 여성복은 상의와 하의로 구분하고  이름  사이즈  구매 가격  판매가격을 관리한다.  2 각 상품을 구매한 오프라인 상점과 구매 금액을 관리한다. ‘상품’ 개체와 ‘거래처(오프라인 상점)’ 개체 간에 관련성이 있음 3 고객이 구매하려면 실명 확인을 통해서 회원 가입을 해야 한다.  4 판매 시 주문일자와 배송일자를 기록해야 한다.  5 고객에게 여성복을 판매한다.  ‘고객’ 개체와 ‘상품(여성복)’ 개체 간에 관련성이 있음 	1
0000	개념적 설계 단계 22 관계 식별 2) 식별된 개체의 관계로의 전환 여부 검토 - ‘구매’ 개체는 ‘상품’ 개체와 ‘거래처’ 개체 간의 관계로 보는 것이 타당하므로 ‘구매’ 관계로 전환한다.  [참고] 변경된 개체 식별 목록 No. 개체 후보 대표 속성 1 상품 구분(상의  하의)  이름   사이즈  가격 등 2 거래처 이름  연락처  주소 등 3 고객 Id  pw  이름  휴대폰번호  주소 등 	1
0000	개념적 설계 단계 23 관계 식별 3) 관계 이름 부여 No. 관계 이름 관련된 개체 목록 관계 유형 관계 설명 속성 비고 1 구매하다 ‘상품’ 개체  ‘거래처’ 개체 2 판매하다 ‘상품’ 개체  ‘고객’ 개체  상품 개체를 기준으로 관계 이름을 부여한 것으로  상품을 거래처에서 ‘구매한다’는 의미로 부여한 이름이다.  - 쇼핑몰에서 ‘상품’ 개체가 가장 중요하다고 판단한 것으로  설계자에 따라 다르게 판단할 수 있음 - 만약 거래처 개체를 중심으로 해석한다면  거래처가 상품을 ‘공급하다’라는 관계 이름을 부여할 수 있음  상품 개체를 기준으로  상품을 고객에게 ‘판매한다’는 의미로 부여한 이름이다. - 만약 고객 개체를 중심으로 해석한다면  고객이 상품을 ‘구매하다’라는 이름을 부여할 수 있는데  이때 다른 관계 이름과 중복되지 않아야 함 	1
0000	개념적 설계 단계 24 관계 식별 4) 관계 유형 결정 No. 관계 이름 관련된 개체 목록 관계 유형 관계 속성 비고 1 구매하다 ‘상품’ 개체  ‘거래처’ 개체 M : N 2 판매하다 ‘상품’ 개체  ‘고객’ 개체 M : N  한 상품은 어떤 거래처에서 한 번 이상 구매한 것이고   한 거래처는 여러 상품을 공급하므로 상품 개체와 거래처의 관계 유형은 M:N이 된다.  한 상품을 여러 고객에게 판매할 수 있고  한 고객에게 여러 상품을 판매할 수 있으므로 상품 개체와 고객 개체의 관계 유형은 M : N이 된다. (만약 모든 상품을 단 하나만 판매하는 경우라면   한 상품을 한 고객에게만 판매할 수 있으므로 상품 개체와 고객 개체의 관계 유형은 N : 1이 됨)  	1
0000	개념적 설계 단계 25 관계 식별 5) 관계 속성 결정  최종 관계 식별 목록 No. 관계 이름 관련된 개체 목록 관계 유형 관계 속성 비고 1 구매하다 ‘상품’ 개체  ‘거래처’ 개체 M : N 구매일자  수량 등 2 판매하다 ‘상품’ 개체  ‘고객’ 개체 M : N 판매일자  수량   배송일자 등 No. 관계 이름 관련된 개체 목록 관계 유형 관계 속성 비고 1 구매하다 ‘상품’ 개체  ‘거래처’ 개체 M : N 구매일자  수량 등 구매 개체가 관계로 전환된 것임 2 판매하다 ‘상품’ 개체  ‘고객’ 개체 M : N 판매일자  수량   배송일자 등 최종 관계 목록 	1
0000	개념적 설계 단계 26 속성 식별 5. 속성 식별 (1) 속성(Attribute)이란?  - 개체나 관계의 특성을 나타내는 요소로  이름을 가진 정보의 가장 작은 논리적 단위이다. - 더 이상 분리할 수 없는 데이터 값을 저장하는 일종의 저장소이다.  (2) 속성 식별 방법 ① 데이터 요구 분석 명세서에서 개체를 설명하는 명사를 개체의 속성으로 식별한다.  ② 데이터 요구 분석 명세서에서 관계를 설명하는 명사를 관계의 속성으로 식별한다.  ③ 데이터 요구 분석 명세서에서 개체의 식별자(후보키)를 식별할 수 없을 때는 식별자 역할을 할 속성을 추가한다.  ④ 데이터 요구 분석 명세서에는 포함되어 있지 않지만 개체나 관계의 특성을 설명하는데 필요한 속성을 추가로 식별한다.  	1
0000	개념적 설계 단계 27 속성 식별 * 설명자(Descriptor) – 개체의 특성을 표현하는데 필 요한 속성 (3) 속성 식별 시 유의사항 - 식별자(후보키)와 설명자(Descriptor)  즉 일반 속성을 구분해서 식별한다.  - 개체와 관계가 식별되면 큰 틀에서의 개념적 모델이 완성되지만   속성이 식별되어야 개체의 특성이 분명해지므로 가능한 모든 속성을 식별한다.  - 개체 및 관계 식별 시에 주요 속성이 식별되었지만  모든 속성이 정의되어야 개체와 관계가 완성 되므로  가능한 개념적 설계 단계에서 모든 속성을 식별하도록 한다.  - 개체 및 관계 식별 시에 함께 식별된 주요 속성의 이름은 요구 분석 명세서를 기준으로 부여되었 으므로 필요한 경우 속성 이름을 변경할 수 있다.  (4) 식별자 관련 유의사항 ① 모든 개체는 반드시 하나 이상의 식별자(후보키)를 포함해야 한다.  ② 식별자는 반드시 유일한 값을 가져야 한다.  ③ 식별자는 개체가 존재하는 동안 값이 변경되지 않아야 한다.    ④ 최종 식별자 즉  기본키는 논리적 모델링 단계에서 결정될 수 있다.  	1
0000	개념적 설계 단계 28 속성 식별 (5) 속성 표현 방법 1) 피터 첸 표기법 - 각 속성은 타원형으로 표현하고  개체나 관계와 연결하며  식별자(기본 키)는 밑줄로 표시한다.   예)  2) IE 표기법 - 개체를 표현하는 사각형 내부에 식별자(기본키)와 설명자(일반 속성)를 구분해서 표현한다.  [학생 개체의 속성 표현]  학생 학번 이름 전공 연락처 학번 이름 전공 연락처 설명자(일반 속성) 식별자(기본 키) 학생 식별자(기본 키) 	1
0000	개념적 설계 단계 29 속성 식별 (6) 속성 이름 부여 시 유의사항 ① 한 개체 내에서는 유일한 이름을 부여해야 하고  소속된 개체가 다르면 동일한 이름을 부여할 수 있다.  ② 유지보수 시에 불편하므로 개체 이름을 속성 이름의 접두어로 사용하지 않는다.   예) 직원 개체의 속성으로 ‘직원이름’은 ‘이름’으로  ‘직원급여’는 ‘급여’로 명명하는 것이 좋다.  ③ 현업에서 익숙한 표준 용어를 사용한다.  ④ 약어 보다는 전체 이름을 사용한다.  ⑤ 속성의 성격이 분명히 인식될 수 있도록 구체적으로 부여한다.  ⑥ 일관성을 위해 미리 이름 부여 규칙을 정해두는 것이 좋다.  예) 단어와 단어는 ‘_’으로 연결한다.    제품_코드   분류_코드 ⑦ 프로젝트(DB 구축)와 관련된 자료 사전을 만들어서 참조하는 것이 좋다.     	1
0000	개념적 설계 단계 30 속성 식별 (7) 속성 식별 사례 - 소규모 온라인 쇼핑몰의 데이터 요구 분석 명세서를 기초로 개체 및 관계의 모든 속성 추출하기 1) 개체 식별 시에 식별된 속성 검토 (필요한 경우 이름 변경)  No. 개체 속성 목록 1 상품 상품명  상하의구분  사이즈  가격 2 거래처 상호  연락처  주소 3 고객 Id  pw  이름  휴대폰번호  주소 등 2) 개체의 속성 추가 식별(필요한 경우 식별자 및 일반 속성 추가) No. 개체 속성 목록 식별자 1 상품 상품번호  상품명  상하의구분  사이즈  판매가격  구매가격 상품번호 2 거래처 거래처번호  상호  연락처  주소  대표자명  주요취급품목 거래처번호 3 고객 Id  pw  이름  휴대폰번호  주소  배송지  구매횟수   주민등록번호 id 주소와 배송지가 다를 수 있으므 로 추가함 판매가격과 구매 가격이 다르므로 가격을 분리함 	1
0000	개념적 설계 단계 31 속성 식별 3) 관계 식별 시에 식별된 속성 검토 (필요한 경우 이름 변경)  No. 관계 관련된 개체 목록 속성 목록 1 구매하다 ‘상품’ 개체  ‘거래처’ 개체 구매일자  수량 2 판매하다 ‘상품’ 개체  ‘고객’ 개체 판매일자  수량  배송일자 4) 관계의 속성 추가 식별(필요한 경우 설명 속성 추가) No. 관계 관련된 개체 목록 속성 목록 식별자 1 구매하다 ‘상품’ 개체  ‘거래처’ 개체 구매일자  수량  구매가격 (상품번호   거래처번호) 2 판매하다 ‘상품’ 개체  ‘고객’ 개체 번호  판매일자  수량  배 송일자  판매가격 (번호  고객id  상품번호)  번호: 같은 날 동일한 상품 을 여러 번 구매할 수 있으 므로 식별 번호를 추가함 판매가격과 구매가격은 판매 또는 구매 시 점마다 달라질 수 있으므로  상품 개체에 포함시키지 않고 구매한다 및 판매한다 관계의 속성으로 포함시키는 것이 타당함 고객이 사이즈를 선택 한다면  ‘사이즈’ 속성 이 추가될 수도 있음 	1
0000	개념적 설계 단계 32 속성 식별  최종 식별된 개체와 관계:  1) 개체 No. 관계 관련된 개체 목록 속성 목록 식별자 1 구매하다 ‘상품’ 개체  ‘거래처’ 개체 구매일자  수량  구매가격 (상품번호  거래처번호) 2 판매하다 ‘상품’ 개체  ‘고객’ 개체 번호  판매일자  수량   배송일자  판매가격 (번호  고객id  상품번호)  No. 개체 속성 목록 식별자 1 상품 상품번호  상품명  상하의구분  사이즈 상품번호 2 거래처 거래처번호  상호  연락처  주소  대표자명  주요취급품목 거래처번호 3 고객 Id  pw  이름  휴대폰번호  주소  배송지  구매횟수   주민등록번호 id 4) 관계 	1
0000	개념적 설계 단계 33 Lesson. ERD 작성 1. ER 모델 표현 방법 2. ERD 작성 방법 ERD 작성 	1
0000	개념적 설계 단계 34 ER 모델 표현 방법 1. ER 모델 표현 방법 (1) 피터 첸(Peter Chen) 표기법 - ER 다이어그램은 1976년 피터 첸(Peter Chen)이 처음 제안한 것으로  개념적 데이터 모델인 ER 모델을 표현하는 전통적인 그래픽 방식의 표현 방법이다.  예) 학생 개체와 교과목 개체 사이의 M:N 유형의 수강한다 관계 표현 학생 교과목 학번 수강하다 이름 전공 과목번호 과목명 학점 m n 	1
0000	개념적 설계 단계 35 ER 모델 표현 방법 (2) 까마귀발(Crow-feet) 표기법 - 새발 표기법이라고도 칭하며  ERWin 등 여러 CASE(Computer Aided Software Engineering)  도구에서 ER 모델을 표현하기 위해 주로 사용하는 방법이다.  - IE(Information Engineering: 정보공학) 표기법  Idef1x(Integration DEFinition for Information  Modeling) 표기법  바커(Barker) 표기법 등 약간씩 변형된 여러 가지 표기법이 있다. 예)  부서 개체와 사원 개체 사이의 1:N 유형의 근무한다 관계 표현 사번 이름 업무 급여 부서번호(FK) 사원 부서번호 부서명 사무실 전화번호 부서 근무하다 1:N 관계에서 1측의 전체 참여 표현 1:N 관계에서 N측의 부분 참여 표현 	1
0000	개념적 설계 단계 36 ERD 작성 방법 2. ERD 작성 방법 (1) ERD 작성 단계 단계 주요 내용 주의사항 1 개체 타입 표시 식별한 모든 개체 타입을 왼쪽에서 오른쪽으로  위에서 아래로  개체의 중요도와 업무 흐름에 따라 배치한다. 2 개체 타입들 간의 관계 표시 개체 타입들 사이의 관계를 결정해서 연결하고  관계 이름은 가능한 ‘동사’로 표현한다. 3 관계 타입의 유형 표시 개체 타입들 간의 관계 유형(1:1  1:n  m:n)을 표시한다. 4 관계 타입의 카디널리티 표시 관계 타입의 유형 대신  또는 유형에 추가해서 카디널리티를 표시한다. (옵션) 5 개체 타입의 속성 표시 개체 타입은 반드시 2개 이상의 속성이 있어야 하고  최소 한 개의 후보 키(식별자)가 있어야 하며  후보 키는 이름 아래 밑줄을 표시해서 구분한다. 6 관계 타입의 속성 표시 관계에 속하는 속성이 있는 경우에만 속성을 결정 해서 연결한다. ERD는 앞에서 식별 한 개체와 관계 그 리고 속성 목록을 기초로 작성하는 것 이므로 반드시 이 순서대로 작성해야 하는 것은 아니지만  가능한 이 순서대로 작성할 것을 권장함 	1
0000	개념적 설계 단계 37 ERD 작성 방법 (2) ERD 작성 사례 - 소규모 온라인 쇼핑몰의 DB 구축을 위한 개념적 모델 표현하기 1) 개체 타입 표시 2) 개체 타입들 간의 관계 표시 상품 고객 거래처 상품 고객 거래처 판매 하다 구매 하다 	1
0000	개념적 설계 단계 38 ERD 작성 방법 3) 관계 타입의 유형 표시 4) 관계 타입의 카디널리티 표시 상품 고객 거래처 판매 하다 구매 하다 M N M N 상품 고객 거래처 판매 하다 구매 하다 (0  M) (0  N) M (1  N) M N (1  M)  N 모든 상품은 어 떤 거래처에서 최소 한 번 이상 은 구매된 것임 을 나타냄 모든 거래처는 하나 이상의 상품을 공급함을 나타냄 고객은 어떤 상 품도 구매하지 않거나 여러 번 구매할 수 있음 을 나타냄 상품은 한 번도 판매되지 않거나 여러 번 판매될 수 있음을 나타 냄 보충 설명 	1
0000	개념적 설계 단계 39 보충 설명 [보충 설명] 관계 타입의 카디널리티를 표시하는 대신  부분 참여는 실선  전체 참여는 이중 실선으로 표시할 수 있다.  상품 고객 거래처 판매 하다 구매 하다 M N M N 	1
0000	개념적 설계 단계 40 ERD 작성 방법 5) 개체 타입의 속성 표시 상품 고객 거래처 판매 하다 구매 하다 (0  M) (0  N) M (1  N) M N (1  M)  N 상품번호 상품명 상하의 구분 사이즈 id 이름 휴대폰 주소 배송지 pw 구매 횟수 거래처번호 상호 연락 처 주소 주요취급 품목 대표자명 주민등 록번호 	1
0000	개념적 설계 단계 41 ERD 작성 방법 6) 관계 타입의 속성 표시 상품 고객 거래처 판매 하다 구매 하다 (0  M) (0  N) M (1  N) M N (1  M)  N 상품번호 상품명 상하의 구분 사이즈 id 이름 휴대폰 주소 배송지 pw 구매 횟수 거래처번호 상호 연락처 주소 주요취급 품목 대표자명 구매 일자 수량 수량 판매일자 배송일자 번호 주민등 록번호 판매 가격 구매 가격 	1
0000	개념적 설계 단계 42 쉼터 쉼터 마음의 주인이 되라!  마음이 가는 데로 따라가서는 안 된다. 항상 마음을 잘 다스려서 부드럽고 순하게 가져라. 마음이 하늘도 만들고  사람도 만들고  지옥도 만들고  극락도 만든다. 그러니 마음을 쫓아가지 말고 마음의 주인이 되라.  - 장아함 반니원경 중에서 	1
0000	데이터베이스 데이터베이스 - Story Board - 11 회차 : 개념적 설계 단계 심화 김 은 경 	1
0000	개념적 설계 단계 심화 2 학습목표 동기유발 & 학습목표 학습내용 1. ER 모델 세분화 방법 학습목표 2. ER 모델 정제 방법 1. 개체의 심화 요소를 나열할 수 있다.  2. 관계의 심화 요소를 나열할 수 있다.  3. 속성의 심화 요소를 나열할 수 있다.  1. 슈퍼-서브 타입의 3가지 정제 방법을 설명할 수 있다.  2. 속성을 개체로 전환하는 경우를 설명할 수 있다.  	1
0000	개념적 설계 단계 심화 3 Lesson. ER 모델 세분화 방법 1. 개체의 심화 요소 2. 관계의 심화 요소 3. 속성의 심화 요소 4. 관계 행렬 활용 개념적 모델링 방법 	1
0000	개념적 설계 단계 심화 4 개체의 심화 요소 1) 부모 개체 – 다른 개체가 파생 되는 근원이 되는 개체로서  다 른 개체와는 무관하게 독립적으 로 존재하는 개체 2) 자식 개체 – 부모 개체로부터 파생된 개체로서  반드시 부모 개체가 존재해야 생성되는 개체 1. 개체의 심화 요소 - 보다 세분화된 개념적 모델링을 위해서 개체를 다음과 같이 6가지로 세분할 수 있다.  (1) 키 개체(Key Entity) - 해당 업무에서 원래부터 존재하는 개체로서  다른 개체와의 관계에 의해 생성된 개체가 아닌  원래 독립적으로 존재하는 개체이다. - 다른 개체의 부모 개체가 되므로 가장 우선해서 추출한다. - 예: 사원  부서  고객  상품 등 (2) 메인 개체(Main Entity) - 키 개체들 간의 업무적인 관련성 때문에 생성되는 것으로  해당 업무에서 핵심적으로 관리되는 데이터로부터 추출된다. - 부모 개체를 갖는 파생 개체이지만  업무의 중심이 되며  다른 개체들을 파생시킨다. - 메인 개체는 기초적인 ER 모델에서는 대개 ‘관계’에 해당한다. - 예: 주문(고객과 상품 개체가 부모 개체)  사고청구(고객과 사고 개체가 부모 개체)   보험계약(고객과 보험상품이 부모 개체)   출하지시(부서와 제품이 부모 개체) 등 	1
0000	개념적 설계 단계 심화 5 개체의 심화 요소 (3) 액션 개체(Action Entity) - 메인 개체로부터 파생되고 내용이 자주 바뀌는 개체 - 초기 분석 단계에서는 잘 드러나지 않지만 모델링을 세분화하는 단계에서 도출된다. (4) 약한 개체(Weak Entity) - 독립적으로 존재하지 못하고 소유 개체(Owner Entity)가 있어야 존재할 수 있으며  고유한 식별자가 없기 때문에 자신의 구분자(부분 키)를 소유 개체의 식별자와 결합해서 복합 식별자를 지정해야 한다. - 예: 부양가족 ß 소유 개체는 사원 개체 접속기록 개체 ß 소유 개체는 고객 개체 키 개체 메인 개체 액션 개체 교수  학생 지도 지도내역 학생  교과목 수강 수강내역 사원  부서 근무 근무평가 고객  상품 주문 배송상태이력 	1
0000	개념적 설계 단계 심화 6 개체의 심화 요소 (5) 코드 개체(Code Entity) - 정보를 간단히 표현하기 위한 기호를 나타내는 개체로서  실제 업무에서 사용하는 코드도 있지 만 데이터를 효율적으로 표현하기 위해서 생성하는 경우도 있다. 예) 전공 코드 개체 – 1: 컴퓨터  2: 전자  3: 전기  4: 기계  … - 너무 많은 코드 개체를 식별하면 개념적 모델링이 너무 복잡해지므로 반드시 개념적 설계 단계에서 식별할 필요는 없다. 전공코드 전공이름 1 컴퓨터 2 전자 3 전기 4 기계 . . .  . . .  	1
0000	개념적 설계 단계 심화 7 개체의 심화 요소 (6) 관계 개체(Association Entity) - 두 개체 간의 M : N 관계로 인해 생성되는 개체로서  교차 개체라고도 칭한다. - ER 모델을 피터 첸 표기법으로 표현할 때는 M : N 관계도 마름모로 표현할 수 있지만  IE 표기법으로 표현할 때 M : N 관계를 정확히 표현하기 위해서 관계 개체를 생성해서 표현해야 한다. - 관계 개체의 식별자는 양쪽 개체의 식별자를 합친 복합 식별자로 지정한다. - 메인 개체가 관계 개체인 경우가 많다. 예) ‘주문하다’ 관계 개체 표현 a) 피터 첸 표기법 고객 상품 주문하다 고객번호 이름 연락처 주소 상품번호 상품명 가격 세부사양 M N 일자 수량 결재여부 	1
0000	개념적 설계 단계 심화 8 개체의 세부 분류 b) IE 표기법 ① 기본 표현 - M : N 관계 유형을 까마귀 발로 표현하고  관계 이름만 표현한다. ② 관계 개체 추가 표현 - 관계 개체를 추가해서 관계의 모든 속성을 표현하고  기존 기체와는 1 : N 관계로 표현할 수 있다. 상품번호 상품명 가격 세부사양 상품 고객번호 이름 연락처 주소 고객 주문하다 상품번호 상품명 가격 세부사양 상품 고객번호 이름 연락처 주소 고객 고객번호 (FK) 상품번호 (FK) 일자 수량 결재여부 주문하다 	1
0000	개념적 설계 단계 심화 9 관계의 심화 요소 2. 관계의 심화 요소 - 보다 세분화된 개념적 모델링을 위해서 관계를 다음과 같이 3가지로 세분할 수 있다.  (1)  병렬 관계(Parallel Relationship)  - 두 개체 사이에 두 개 이상의 관계가 존재하는 것으로  다중 관계라고도 칭한다. [예제 1] 사원과 부서 개체 사이의 ‘근무하다’라는 관계와 ‘관리하다’라는 2개 관계 존재 - ‘근무하다’라는 관계에는 모든 사원 개체가 참여하는 전체 참여이지만   ‘관리하다’라는 관계에는 일부 사원  즉 부서장에 해당하는 사원만 참여하는 부분 참여이다.  사원 부서 근무하다 사원번호 이름 업무 급여 부서번호 부서명 사무실 전화번호 1 N 관리하다 1 1 	1
0000	개념적 설계 단계 심화 10 관계의 심화 요소 [예제 2] 부서 개체와 공사 개체 사이의 관계를 분석하면  어떤 부서는 공사를 발주하고  어떤 부서는 감독하고  어떤 부서는 정산을 담당하므로  이를 각각 표현하는 대신 3개의 병렬 관계로 표현 할 수 있다.  à 하나의 공사는 하나의 발주부서에서 발주하고  한 관리부서에서 감독하고  또 한 정산부서 에서 정산하며  각 부서는 하나 이상의 공사를 발주  감독  정산하므로  부서와 공사 간의 관계 유형은 모두 1 : N이다.  ü 각각 표현하는 경우:  발주부서 공사 부서번호 부서명 연락처 사무실 공사번호 공사명 시작일 종료일 1 N 발주하다 감독부서 공사 부서번호 부서명 연락처 사무실 공사번호 공사명 시작일 종료일 1 N 감독하다 	1
0000	개념적 설계 단계 심화 11 관계의 심화 요소 è 병렬 관계로 표현하는 경우:  부서 공사 정산하다 부서번호 부서명 연락처 사무실 공사번호 공사명 시작일 종료일 1 N 감독하다 발주하다 1 1 N N 정산부서 공사 부서번호 부서명 연락처 사무실 공사번호 공사명 시작일 종료일 1 N 정산하다 심화 학습 	1
0000	개념적 설계 단계 심화 12 관계의 심화 요소 è 릴레이션 스키마로 변환 : 심화 학습 부서(부서번호  부서명   연락처  사무실) 공사(공사번호  공사명   시작일  종료일) 발주하다(공사번호  발주부서번호)  감독하다(공사번호  감독부서번호)  정산하다(공사번호  정산부서번호)  외래 키 단순화 :  공사(공사번호  공사명   시작일  종료일  발주부서번호  감독부서번호  정산부서번호)  외래 키 	1
0000	개념적 설계 단계 심화 13 관계의 심화 요소 (2) 직렬 관계(Serial Relationship)  - 병렬 관계로 나열한 여러 관계를 하나의 상위 개념으로 통합해서 M : N 관계로 바꾸어서 표현한 것 을 의미한다. 예) 앞의 예제에서 발주하다  감독하다  정산하다 라는 3개의 병렬 관계를 상위 개념인 ‘관리하다’ 라는 관계로 통합해서 표현한다.  à 한 공사에 대해 여러 부서가 발주  감독  정산을 나누어서 하므로  관계 유형은 M : N이 된다.  부서 공사 부서번호 부서명 연락처 사무실 공사번호 공사명 시작일 종료일 M N 관리하다 심화 학습 심화 학습 è 릴레이션 스키마로 변환 : 부서(부서번호  부서명   연락처  사무실) 공사(공사번호  공사명   시작일  종료일) 관리하다(공사번호  부서번호)  혹은 관리하다(공사번호  부서번호  관리유형)  발주  감독  정산 등 	1
0000	개념적 설계 단계 심화 14 관계의 심화 요소 (3)  병렬 관계와 직렬 관계의 특징 비교 - 모델링 할 때 병렬 관계와 직렬 관계의 특징을 잘 비교해서 선택해야 한다.  병렬 관계의 특징 직렬 관계의 특징 관계를 표현하기 위해 별도의 테이블(릴레이 션)이 불필요하다.  관계를 표현하기 위해 별도의 테이블(릴레이션)이 필요하다.  하나의 관계가 하나의 속성으로 표현된다.  하나의 관계가 하나의 개체로 표현된다.  새로운 관계가 추가되거나 변경될 때 유연하 게 대처하기 어렵다. 새로운 관계가 추가되거나 변경될 때 유연하게 대처할 수 있다. 관계 내용별로 상세 정보를 관리할 수 없다.  관계 내용별로 상세 정보를 관리할 수 있다.  상세 정보를 관 리할 자식 개체 를 할 수 없으 므로 새로운 관계(예: 감리 하다)가 추가되면  새 로운 데이터를 추가해 서 대응할 수 있으므 로 새로운 관계(예: 감리 하다)가 추가되면  새 로운 열(속성)을 추가 해야 하므로 자식 개체를 생 성해서 상세 정 보를 관리할 수 있으므로 	1
0000	개념적 설계 단계 심화 15 관계의 심화 요소 (4)  순환 관계(Self Relationship)  1) 순환 관계란?  - 하나의 개체가 다른 개체가 아닌 자기 자신과 관계를 맺는 것을 의미한다.  2) 1 : N 순환 관계 - 기관의 조직도  관리자 정보 등과 같이 계층 구조를 표현할 때 발생한다.  예) 사원의 관리자 관계 표현 김장수 이영희 박문숙 민경호 장경수 김만호 최영민 박영미 오지민 이숙자 김은주 나민아 1 N 사원 사원번호 이름 업무 급여 관리하다 	1
0000	개념적 설계 단계 심화 16 관계의 심화 요소 3) M : N 순환 관계 - 선수 과목이나  구성부품 정보 등과 같이 네트워크 구조를 표현할 때 발생한다.  예) 선수과목 관계 표현 C 언어 C++ 언어 자료구조 파일구조 전산개론 알고리즘 M N 교과목 교과목번호 교과명 학점 필수여부 선수하다 	1
0000	개념적 설계 단계 심화 17 관계의 심화 요소 예) 구성 부품 관계 표현 M N 부품 부품번호 부품명 제조사 가격 구성하다 D E G K B K C A F H I L 	1
0000	개념적 설계 단계 심화 18 속성의 심화 요소 * 저장 속성(Stored Attribute) – 유도 속성을 결정하기 위해 사용된 속성 3. 속성의 심화 요소 - 보다 세분화된 개념적 모델링을 위해서 속성의 유형을 다음과 같이 3가지로 세분할 수 있다.  (1)  기초 속성(Basic Attribute)  - 업무로부터 추출된 일반적인 속성이다.  - 데이터 요구 분석 명세서에 포함되어 있으며  현업에서 제공해야 속성이 유지될 수 있다.    - 예: 상품명  가격  주문수량 등 (2)  설계 속성(Designed Attribute)  - 원래 존재하지는 않지만 필요에 따라 설계자가 추가한 속성이다.  - 데이터 요구 분석 명세서에 포함되어 있지는 않지만  설계를 진행하면서 새로 생성된 것이다. - 대부분의 코드 속성이나 일련번호처럼 식별자 역할을 하도록 추가된 속성이 해당한다.  - 예: 주문번호  예약번호  고객번호  상품코드 등 (3)  유도 속성(Derived Attribute)  - 추출 속성이라고도 칭하며  기본 속성으로부터 계산 등의 가공 처리를 통해서 생성된 속성이다. - 저장 속성의 영향을 받으므로  저장 속성의 값이 변경되면 함께 변경된다.  - 중복의 의미가 있으므로 대개 개념적 모델링 단계에서 식별하지 않는다.  (반드시 필요한 경우라면 별도로 정리해서 구현 단계에서 참조한다.)  - 예: 나이(생년월일 속성에서 유도됨)  근무기간(입사일 속성에서 유도됨) 등 	1
0000	개념적 설계 단계 심화 19 관계 행렬 활용 4. 관계 행렬 활용 (1)  관계 행렬(Relationship Matrix)이란?  - 개체들 간의 관계를 정의하기 위해서 사용하는 보조 도구이다.  (2)  관계 행렬 작성 방법 ① 개체를 가장 상위 행과 가장 좌측 열에 모두 표시한다. ② 개체들 간의 관계 유무를 셀(Cell)에 표시한다. ③ 1차적으로 조금이라도 관련성이 있으면 모두 표시한다. ④ 식별된 관계의 구체적인 이름을 부여한다. ⑤ 상관 관계가 없으면 셀에 ‘-’을 표시한다. ⑥ 1열의 개체가 주어에 해당한다.  ⑦ 순환 관계는 대각선 셀에 표시한다.  ⑧ 관계 행렬의 내용을 참조해서 최종 관계를 판단한다.  	1
0000	개념적 설계 단계 심화 20 관계의 여러 유형 (3)  관계 행렬 작성 예제 고객 부품 주문 창고 고객 - 주문하다 - - 부품 - 구성하다 포함되다 - 주문 - 발주하다 - - 창고 - 보관하다 - - 	1
0000	개념적 설계 단계 심화 21 Lesson. ER 모델 정제 방법 1. 슈퍼-서브 타입 정제 2. 카테고리 정제 3. 속성을 개체로 전환하기 4. 개체·관계·속성 검증 ER 모델 정제 방법 	1
0000	개념적 설계 단계 심화 22 슈퍼-서브 타입 정제 (1) 슈퍼-서브 타입 정제 기준 ① 서브타입 개체에 독자적으로 고유한 속성이 없거나 독자적인 관계가 없는 경우 속성으로 표현한다.  ② 서브타입으로 분할했을 때 개념적 모델링이 너무 복잡해지면 분할하지 않는다.  ③ 서브 타입으로 분할된 수가 너무 많은 경우  각각을 독립된 개체로 분리할 것을 고려한다.    (2) 슈퍼-서브 타입 정제 방법 ① 슈퍼타입 개체를 기준으로 통합하는 방법 ② 서브타입 개체를 기준으로 통합하는 방법 ③ 슈퍼타입과 서브타입 개체를 각각 분리하는 방법 1. 슈퍼-서브 타입 정제 	1
0000	개념적 설계 단계 심화 23 슈퍼-서브 타입 정제 (3) 슈퍼타입 개체 기준 통합 방법 ① 서브타입 개체에 있던 속성을 모두 슈퍼타입 개체에 포함시킨다.   ② 서브타입 개체와 연결된 관계를 모두 슈퍼타입 개체와 연결시킨다.  ③ 서브타입 개체를 모두 삭제한다.  ü 슈퍼타입 개체를 기준으로 통합하는 경우 ① 응용 프로그램에서 서브타입을 구분해서 처리하지 않는 경우 ② 서브타입 개체에 속하는 데이터를 명확하게 구분하기 어려운 경우 ③ 서브타입 개체에 사용되는 속성 수가 매우 적은(1-2개) 경우 	1
0000	개념적 설계 단계 심화 24 슈퍼-서브 타입 정제 직원 정규직 계약직 직원번호 이름 급여 입사일 직급 호봉 슈퍼타입 개체 서브타입 개체 통합 직원 직원번호 이름 급여 입사일 직급 호봉 계약기간 ü 예제 : 정규직과 계약직이라는 2개의 서브타입 개체를 직원이라는 슈퍼타입 개체에 통합하기 (대부분의 응용 프로그램에서 정규직과 계약직을 구분해서 처리하지 않는 경우)  계약기간 계약유형 계약유형 	1
0000	개념적 설계 단계 심화 25 슈퍼-서브 타입 정제 (4) 서브타입 개체 기준 통합 방법 ① 슈퍼타입 개체에 있던 모든 속성을 각각의 서브타입 개체로 이동시킨다.   ② 슈퍼타입 개체에 연결된 관계를 각각의 서브타입 개체에 연결시킨다.  ③ 슈퍼타입 개체를 삭제한다.  ü 서브타입 개체를 기준으로 통합하는 경우 ① 슈퍼타입 개체에 속하는 속성의 수가 많지 않은 경우 ② 슈퍼타입 개체의 관계가 적은 경우 ③ 슈퍼타입 개체에 접근하는 응용 프로그램의 수가 적은 경우 	1
0000	개념적 설계 단계 심화 26 슈퍼-서브 타입 정제 직원 정규직 계약직 직원번호 이름 급여 입사일 직급 호봉 슈퍼타입 개체 서브타입 개체 통합 정규직 직원번호 이름 급여 입사일 직급 호봉 ü 예제 : 직원이라는 슈퍼타입 개체를 정규직과 계약직이라는 2개의 서브타입 개체와 통합하기 (대부분의 응용 프로그램에서 정규직과 계약직을 확실히 구분해서 처리하는 경우)  계약직 직원번호 이름 급여 입사일 계약기간 계약기간 계약유형 계약유형 	1
0000	개념적 설계 단계 심화 27 슈퍼-서브 타입 정제 (5)  슈퍼타입과 서브타입 개체를 각각 분리하는 방법 ① 슈퍼타입  서브타입 개체를 각각 개별 개체로 분리한다.    ② 분리된 슈퍼타입 개체와 서브타입 개체를 1 : 1 관계로 연결한다.  (즉  슈퍼타입 개체의 기본 키를 서브타입 개체의 기본 키로 추가함) ü 슈퍼타입  서브타입 개체를 각각 분리하는 경우 - 데이터 모델의 유연성을 보장해야 하는 경우 	1
0000	개념적 설계 단계 심화 28 슈퍼-서브 타입 정제 ü 예제 : 슈퍼 타입인 직원 개체와 서브 타입인 정규직 및 계약직 개체를 각각 분리시키기 (정규직과 계약직을 확실히 구분해서 처리하는 응용 프로그램과 구분 없이 처리하는 응용 프로그램의 수가 비슷하고  추후 다양한 응용 프로그램이 추가될 예정인 경우)  계약직 계약기간 직원 직원번호 이름 급여 입사일 정규직 직급 호봉 근무하다 계약하다 1 1 1 1 직원 정규직 계약직 직원번호 이름 급여 입사일 직급 호봉 계약기간 슈퍼타입 개체 서브타입 개체 계약유형 계약유형 	1
0000	개념적 설계 단계 심화 29 슈퍼-서브 타입 정제 직원 직원번호 이름 급여 입사일 정규직 직급 호봉 직원번호 계약직 계약 기간 계약 유형 직원번호 	1
0000	개념적 설계 단계 심화 30 카테고리 정제 2. 카테고리 정제 (1) 카테고리 정제 기준 ① 카테고리(서브 타입 개체)를 독립된 개체로 만들고  기본 키를 포함시킨다.  ② 카테고리에 속하는 모든 개체 타입(슈퍼 타입 개체)을 카테고리 개체와 각각 1: N 관계로 연결한다.  (2) 예제 차량 소유주 개인 회사 U 등록일 주민등 록번호 이름 주소 회사명 주소 맴버(슈퍼타입 개체) 카테고리(서브타입 개체) 실제로 DB에 등록되는 차량 소유주는 개인과 회사의 합 집합의 부분집합에 해당함 	1
0000	개념적 설계 단계 심화 31 카테고리 정제 차량 소유주 개인 회사 등록일 주민등 록번호 이름 주소 회사명 주소 등록번호 등록되다 지정되다 1 1 n n 	1
0000	개념적 설계 단계 심화 32 속성을 개체로 전환하는 경우 3. 속성을 개체로 전환하는 경우 1)  속성 값이 없는 경우 - 많은 개체가 널(NULL) 값을 갖는 속성은 별도의 개체로 분리하고  원래 개체와 1 : 1 관계로 연결한다.  - 예: 병력 관련 속성을 포함하는 대학생 개체 à 군 미필이거나 여학생인 경우  해당 속성들은 모두 널 값을 갖게 됨 à 병력 관련 속성들을 모아서 별도의 군필자 개체를 생성하고  해당 대학생과 1 : 1 관계를 표시함 대학생 학번 이름 성별 연락처 군번 최종계급 최종근무지 병과 주소 군필자 군번 최종계급 최종근무지 병과 대학생 학번 이름 성별 연락처 주소 제대하다 1 1 	1
0000	개념적 설계 단계 심화 33 속성을 개체로 전환하는 경우 2) 속성 값이 여러 부분으로 구성된 경우 - 속성의 수가 많으면서 특징을 구분할 수 있는 여러 부분으로 구성된 경우   특징 별로 별도의 개체로 분리한다.   - 예:  개인신상정보  급여정보  학력정보 등으로 구분되면서 수십 개의 속성을 갖는 사원 개체 à 개인신상정보  급여정보  학력정보 등을 각각 별도의 개체로 분리함 사원 사번 주민등 록번호 이름 연락처 호봉 상여금 최종학력 급여 주소 . . .  사원 사번 주민등 록번호 이름 연락처 주소 급여정보 사번 호봉 급여 상여금 학력정보 사번 최종학력 출신고교 출신대학 전공 	1
0000	개념적 설계 단계 심화 34 개체·관계·속성 검증 4. 개체·관계·속성 검증 (1) 개체 검증 방법 - 다음과 같은 질문을 통해서 개념적 모델링 단계에서 식별한 개체가 적절한지 검증한다.  ① 유용한 정보를 제공하는가?  - 업무에 활용되지 않고 값이 변하지 없는 개체는 삭제한다.  ② 유일한 식별자(후보 키)를 포함하고 있는가?  - 식별자가 없으면 데이터의 일관성과 무결성을 보장하지 못하므로   필요하다면 설계 속성을 추가한다.   ③ 속성의 수가 2개 이상인가?  - 속성이 하나 밖에 없는 경우  다른 개체의 속성으로 표현하는 것이 바람직하다.   - 식별자가 2개의 속성으로 결합된 경우라도 2개 속성으로 인정한다.  ④ 다른 개체와 관계(Relationship)가 있는가? - 일부 코드 개체나 통계용 개체를 제외하면 모두 다른 개체와 관계가 있어야 한다.  ⑤ 실제 데이터가 2개 이상 존재하는가?  - 데이터가 하나 밖에 없다면 업무적으로 관리할 필요가 없는 개체일 가능성이 크기 때문에 삭제한다.  	1
0000	개념적 설계 단계 심화 35 개체·관계·속성 검증 (2) 관계 검증 방법 - 다음과 같은 질문을 통해서 개념적 모델링 단계에서 식별한 관계가 적절한지 검증한다.  ① 관계가 현재 업무 규칙에 적절한 것인가?  ② 관계명이 두 개체 사이의 업무적 연관성을 표현하는 구체적인 이름인가?  ③ 관계의 유형이 적절한가?  ④ 관계의 카디널리티가 적절한가?  ⑤ 필수/선택 여부  즉 전체 참여와 부분 참여가 적절한가?  	1
0000	개념적 설계 단계 심화 36 개체·관계·속성 검증 (3) 속성 검증 방법 - 다음과 같은 질문을 통해서 개념적 모델링 단계에서 식별한 속성이 적절한지 검증한다.  ① 각기 다른 의미를 갖는 여러 개의 속성을 묶어서 하나의 속성으로 정의한 것은 아닌가? - 그렇다면 각각을 별개의 속성으로 구분해야 한다.   ② 속성이 단 하나의 값만 갖는 것이 아닌가? - 모든 개체가 동일한 하나의 값만을 갖는 속성이 있다면 제거해야 한다.  예) 한국인 개체의 국적 속성 ③ 코드 값을 갖는 속성이 현업에서 통상적으로 사용되는 코드 값을 갖는가? - 그렇지 않다면 코드 사용을 억제해야 한다.  ④ 전산 처리에 필요한 플래그(Flag) 형태의 속성이 아닌가? - 플래그 형태의 속성은 제외시켜야 한다.   	1
0000	데이터베이스 데이터베이스 - Story Board - 12 회차 : 논리적 설계 단계 김 은 경 	1
0000	논리적 설계 단계 2 학습목표 동기유발 & 학습목표 학습내용 1. 릴레이션 스키마 생성 학습목표 2. 릴레이션 단순화 방법과 릴레이션 생성 사례 1. 릴레이션 스키마 생성 단계를 나열하는 할 수 있다.  2. 개체 변환 방법에 대해 설명할 수 있다.  3. 관계 변환 방법에 대해 설명할 수 있다.  1. 릴레이션을 단순화시킬 수 있다.  2. 무결성 제약조건의 정의 기준을 설명할 수 있다.  	1
0000	논리적 설계 단계 3 Lesson.   릴레이션 스키마 생성 1. 논리적 설계 개요 2. 릴레이션 스키마 생성 방법 3. 개체 변환 4. 관계 변환 5. 다중치 속성 변환 개념적 모델링 방법 	1
0000	논리적 설계 단계 4 논리적 설계 개요 * 정규화(Normalization) - 어떤 정보도 잃지 않으면서 주어진 릴레이션들을 보다 바람직한 형태로 변환해가는 과정 1. 논리적 설계 개요 (1) 논리적 설계(Logical Design)란?   - 개념적 데이터 모델을 DBMS가 지원하는 논리적 데이터 모델로 변환하는 것이다. (2) 논리적 설계의 주요 업무 ① 논리적 모델링 - ERD로 표현된 개념적 스키마를 논리적 스키마(릴레이션 스키마)로 변환한 다음   정규화 과정을 통해서 보다 바람직한 모델로 변환하고  요구 분석 명세서를 기초로 무결성 제약조건을 정의한다.  ② 트랜잭션 인터페이스 설계 - 트랜잭션 모델링을 기초로 인터페이스를 설계한다.  ③ 스키마 평가 및 정제 - 논리적 스키마를 정량적 정보와 성능 평가기준에 따라 평가해서 정제한다. 	1
0000	논리적 설계 단계 5 논리적 설계 개요 (3) 논리적 모델링의 입출력 개념적 스키마 (ER 다이어그램) Input 논리적 모델링 Output 릴레이션 스키마  무결성 제약조건 ① 개체와 관계를 모두 릴레이션으로 변환 ② 릴레이션 단순화 ③ 정규화를 통해서 보다 바람직한 형태로 변환 ④ 무결성 제약조건 정의 	1
0000	논리적 설계 단계 6 릴레이션 스키마 생성 2. 릴레이션 스키마 생성 (1) 릴레이션 스키마(Relation Schema)란?  - 가장 대표적인 논리적 데이터 모델인 관계 데이터 모델의 기본이 되는 릴레이션을 구성하는 속성들의 집합을 의미한다.   - 릴레이션 이름과 속성 이름들로 표현한다.  (2) 릴레이션 스키마 생성 단계 ERD의 개체와 관계를 릴레이션 스키마로 변환 : 릴레이션명(속성1  속성2  …) 릴레이션 스키마에 기본 키 표시 : 기본 키 아래 밑줄 표시 릴레이션 스키마의 단순화 : 일 대 일  일 대 다 관계 유형 단순화 정규화(Normalization) : 보다 바람직한 릴레이션 형태로 변환 개체 릴레이션:  개체명(속성1  속성2  …) 관계 릴레이션:  관계명(속성1  속성2  …) 	1
0000	논리적 설계 단계 7 개체 변환 3. 개체 변환 (1) 단순 속성을 갖는 개체 변환 방법 - 변환 방법 : 모든 속성이 릴레이션의 속성이 된다. - 기본 키 : 개체의 후보 키 가운데 하나가 릴레이션의 기본 키가 된다. - 변환 예:  사원 사원번호 이름 급여 사원(사원번호  이름   급여) [제목] 단순 속성을 갖는 개체 변환 릴레이션 스키마 단순 속성을 갖는 개체 사원번호 이름 급여 사원 혹은 개체 변환 리스트 형태 표현 테이블 형태 표현 	1
0000	논리적 설계 단계 8 개체 변환 (2)  복합 속성을 갖는 개체 변환 방법 - 변환 방법 : 복합 속성을 구성하는 모든 속성이 릴레이션의 속성이 된다. - 기본 키 :  복합 속성이 일반 속성인 경우와 후보 키에 대응하는 속성인 경우를 구분해서 판단한다. ① 복합 속성이 일반 속성인 경우 - 기본 키 : 개체의 후보 키 가운데 하나가 릴레이션의 기본 키가 된다. - 변환 예 :  사원 사원번호 이름 급여 상여금 기본급 릴레이션 스키마 일반 속성인 복합 속성을 갖는 개체 사원(사원번호  이름   기본급  상여금) 개체 변환 	1
0000	논리적 설계 단계 9 개체 변환 ② 후보 키 속성이 복합 속성인 경우 - 기본 키 : 복합 속성을 구성하는 모든 속성들이 기본 키가 된다.   - 변환 예 :  사원 사원번호 이름 급여 Num 부서번호 릴레이션 스키마 후보 키가 복합 속성인 개체 사원(부서번호  Num  이름   급여) [비교] 다음 두 릴레이션 스키마는 다른 의미를 갖는다. 사원(부서번호  Num  이름   기본급  상여금) 사원(부서번호  Num  이름   기본급  상여금) - 전자는 부서번호와 Num이라는 2개의 복합 속성이 기본 키임을 의미하고   후자는 부서번호나 Num 가운데 하나가 기본 키가 될 수 있음을 의미한다. 개체 변환 	1
0000	논리적 설계 단계 10 개체 변환 (3)  약한 개체 변환 - 변환 방법 : 소유 개체(주 개체) 타입을 갖는 약한 개체 타입에 대해서 릴레이션을 생성하고   약한 개체 타입에 속한 모든 단순 속성들을 릴레이션에 포함시키고  소유 개체 타입의 기본 키를 약한 개체 타입의 외래 키로 포함시킨다.    - 기본 키 : 약한 개체 타입에 해당하는 릴레이션의 기본 키는 약한 개체 타입의 부분 키(구별자)와 소유 개체 타입에 해당하는 릴레이션을 참조하는 외래 키의 조합이 기본 키가 된다. - 변환 예:  부양가족 사원 관계 사원번호 이름 이름 1  n 급여 부양하다 부분 키(구별자)  식별 관계 타입 소유 개체 타입 (주 개체 타입) 약한 개체 타입 (종속 개체 타입) 릴레이션 스키마 개체 변환 사원(사원번호   이름   급여)  부양가족(사원번호  관계  이름) 소유 개체 타입인 사 원 개체의 기본 키를 외래 키로 포함시킴 부분 키인 관계와 외래 키인 사원번호의 조합이 기본 키가 됨 	1
0000	논리적 설계 단계 11 관계 변환 4. 관계 변환 - 특징 : “관계 자체의 속성” 및 “관계에 속하는 개체들의 기본 키 속성”이 모두 릴레이션의 속성이 된다.  - 기본 키 : 관계의 유형(일 대 일  일 대 다  다 대 다)에 따라 기본 키를 결정하는 방법에 차이가 있다.  (1) 일 대 일(1 : 1) 관계 변환 방법 - 변환 방법 : 관계에 속하는 개체들의 기본 키 속성과 관계 자체의 속성(있는 경우)을 관계 릴레이션의 속성으로 표현한다. (이때 개체의 기본 키는 관계 릴레이션의 외래 키가 됨)         - 기본 키: 관계에 포함된 양쪽 개체의 기본 키 가운데 하나가 기본 키가 될 수 있다. - 주의 사항 : 기본 키의 선택은 업무의 성격에 맞게 결정해야 한다.  - 변환 예 :  관리하다(사원번호(FK)  부서번호(FK)   임명일자)  혹은 관리하다(사원번호(FK)  부서번호(FK)   임명일자) 부서번호 부서 부서명 사원 사원번호 이름 급여 관리하다 1 1 임명일자 릴레이션 스키마 일 대 일 관계 유형 보충 설명 관계 변환 기본 키는 밑줄 로  외래 키는 (FK: Foreign  Key)로 구분해서 표시함 사원번호는 기본 키이면 서 동시에 외 래 키이다.  	1
0000	논리적 설계 단계 12 [보충 설명]  [보충 설명] 일 대 일 관계의 기본 키 설정 기준 - 다음 2가지 형태의 릴레이션 스키마로 변환이 가능한데  어떤 것을 선택하는 것이 좋을까요?  관리하다(사원번호(FK)  부서번호(FK)   임명일자)   --- ① 관리하다(사원번호(FK)  부서번호(FK)   임명일자)     --- ② 릴레이션 스키마 à 업무의 성격을 고려해서 기본 키를 선택한다.  1) 업무를 처리함에 있어서 부서번호로 부서장을 확인하는 경우가 많다면  부서번호를 기본 키로 정의한다. 2) 업무를 처리함에 있어서 어떤 사원이 어느 부서의 부서장을 맡고 있는지 확인하는 경우가 많다면  사원번호를 기본 키로 정의한다. 사원번호와 부서번호 모두 유일한 값을 가지므로 둘 다 기본 키가 될 수 있지만   업무를 처리함에 있어서 부서번호로 부서장을 확인하는 경우가 많다면 사원번호 보다는 부서번호를 기본 키로 정의하는 것이 바람직함 사원번호 부서번호 임명일자 1234 100 03/01/2010 2553 200 03/01/2010 3612 300 09/01/2011 4155 400 01/01/2012 : : : 관리하다 릴레이션 	1
0000	논리적 설계 단계 13 관계 변환 (2) 일 대 다(1 : n) 관계 변환 방법 - 변환 방법 : 관계에 속하는 개체들의 기본 키 속성과 관계 자체의 속성(있는 경우)을 릴레이션의 속성으로 표현한다.  - 기본 키: 관계에 포함된 개체 가운데 n측 개체의 기본 키가 기본 키가 된다. - 주의 사항 : 1측 개체의 기본 키는 관계 릴레이션에서 중복되므로  n 측 개체의 기본 키가 관계 릴레이션의 기본 키가 되어야 한다.   - 변환 예 :  [제목] 일 대 다 관계 변환 근무하다(사원번호(FK)   부서번호(FK)) 근무하다 부서번호 부서 부서명 사원 사원번호 이름 급여 관리자 1 n 릴레이션 스키마 일 대 다 관계 유형 보충 설명 관계 변환 어떤 사원이 어떤 부서에서 근무하 는지를 표현하는 ‘근무하다’라는 관계의 경우  많은 사원이 같은 부 서에 근무하게 되므로 동일한 부서 번호가 중복되게 되고  따라서 부 서번호는 기본 키가 될 수는 없음 	1
0000	논리적 설계 단계 14 [보충설명]  [보충 설명]  - ‘근무한다’ 릴레이션의 데이터(릴레이션 인스턴스)를 확인하면   부서번호가 기본 키가 될 수 없는 이유를 명확히 알 수 있다.  근무하다 릴레이션 사원번호 부서번호 11135 100 11233 100 12336 100 12476 200 : : 사원번호 11135  11233  12336이 모두 100번 부서에 근무하기 때문에 동일한 부서번호가 중복되어 있으므로 부서번호는 기본 키가 될 수 없다. 	1
0000	논리적 설계 단계 15 관계 변환 (3)  다 대 다(m : n) 관계 변환 방법 - 변환 방법 : 관계에 속하는 개체들의 기본 키 속성과 관계 자체의 속성(있는 경우)을 릴레이션의 속성으로 표현한다.  - 기본 키: 관계에 포함된 양쪽 개체의 기본 키들을 구성하는 모든 속성들의 조합(Combination)이 기본 키가 된다. - 주의 사항 : m 측 개체의 기본 키와 n 측 개체의 기본 키는 각각 관계 릴레이션에서 중복될 수 있으므로  이들 기본 키가 조합되어 관계 릴레이션의 기본 키가 되어야 한다.   - 변환 예제 1 : 여러 명의 사원이 여러 교육과정을 수강하는 관계 표현 [제목] 다 대 다 관계 변환 예제(1)  수강하다(사원번호(FK)  과정번호(FK)   수강일자  성적) 수강하다 과정번호 교육과정 과정명 사원 사원번호 이름 급여 교육시간 n m 릴레이션 스키마 다 대 다 관계 유형 성적 수강일자 보충 설명 관계 변환 	1
0000	논리적 설계 단계 16 [보충 설명]  [보충 설명]  - ‘수강하다’ 릴레이션의 데이터(릴레이션 인스턴스)를 확인하면   사원번호나 과정번호 하나 만으로는 기본 키가 될 수 없는 이유를 명확히 알 수 있다.  사원번호 과정번호 수강일자 성적 11135 100 02/10/2013 A 11135 200 03/15/2013 B 11236 100 02/10/2013 B 12476 200 03/15/2013 A : : : : 수강하다 릴레이션 각각이 중복되어 있으므로 사원번호나 과정번호 어느 한 속성만으로는 기본 키가 될 수 없다. 	1
0000	논리적 설계 단계 17 관계 변환 - 변환 예제 2 : 여러 명의 강사가 여러 교육과정을 강의하는 관계 표현 [제목] 다 대 다 관계 변환 예제(2)  강의하다(강사번호(FK)  과정번호(FK)   강의일자) 강의하다 과정번호 교육과정 과정명 강사 강사번호 이름 강사료 교육시간 n m 릴레이션 스키마 다 대 다 관계 유형 강의일자 보충 설명 변환 다 대 다 유형이므로 원래 사원번 호와 과정번호가 조합되어 기본 키 가 되어야 하지만  같은 교육과정을 같은 강사가 다른 날짜에 여러 번 강의할 수 있기 때문에 이 두 가지 속성만으로 기본 키가 정의되면  ‘강의일자’ 속성의 값만 다른 경우 데이터를 삽입할 수 없게 됨. 따라 서  기본 키에 ‘강의일자’ 속성을 기본 키에 포함시켜야 함 	1
0000	논리적 설계 단계 18 관계 변환 [보충 설명]  - ‘강의한다’ 릴레이션의 데이터(릴레이션 인스턴스)를 확인하면   강사번호와 과정번호의 조합 만으로는 기본 키가 될 수 없는 이유를 명확히 알 수 있다.  강사번호 과정번호 강의일자 4572 100 02/10/2013 2523 200 03/15/2013 4572 100 04/10/2013 4572 300 05/15/2013 : : : 강의하다 릴레이션 같은 강사가 같은 강의를 다른 날짜에 여러 번 강의할 수 있는데  만약 (강사번호  과정번호)를 기본 키로 설정하면 두 번째 강의한 데이터는 삽입할 수 없게 됨 	1
0000	논리적 설계 단계 19 관계 변환 (4)  순환 관계 변환 a)  일 대 다 순환 관계 변환 방법 - 변환 방법 : 관계 릴레이션을 별도로 생성하지 않고  개체의 기본 키를 외래 키로 포함시킨다.  만약 관계 자체의 속성이 있으면  그 속성도 개체 릴레이션에 포함시킨다.  - 기본 키: 개체의 기존 기본 키가 그대로 기본 키가 된다. - 변환 예제 : 한 명의 사원(부서장)이 여러 사원을 관리하는 관계 표현 사원(사원번호   이름  업무  급여  관리자사원번호(FK)) 릴레이션 스키마 일 대 다 순환 관계 변환 1 N 사원 사원번호 이름 업무 급여 관리하다 ‘관리하다’라는 순 환 관계를 표현하 기 위해 추가된 외 래 키 	1
0000	논리적 설계 단계 20 관계 변환 b)  다 대 다 순환 관계 변환 방법 - 변환 방법 : 관계 릴레이션을 별도로 생성하고  개체의 기본 키를 2개의 외래 키로 포함시킨다. 만약 관계 자체의 속성이 있으면  그 속성은 관계 릴레이션에 포함된다. - 기본 키 : 2개의 외래 키가 조합되어 관계 릴레이션의 기본 키가 된다. - 주의 사항 : 동일한 기본 키가 2개 추가되므로  2개의 속성 이름이 서로 달라야 한다. - 변환 예제 : 많은 교과목이 여러 다른 교과목의 선수 과목이 되는 관계 표현 교과목(교과목번호   교과명  학점  필수여부) 선수하다(교과목번호(FK)  선수교과목번호(FK)) 릴레이션 스키마 다 대 다 순환 관계 변환 M N 교과목 교과목번호 교과명 학점 필수여부 선수하다 어떤 교과목의 선수과목을 표현하기 위 해서  교과목 개체의 기본 키(교과목번 호)가 관계 릴레이션에 2개의 외래 키 (교과목번호  선수교과목번호)로 포함 되고  이 2개의 외래 키가 조합되어 기본 키가 됨 	1
0000	논리적 설계 단계 21 관계 변환 (5)  3진 이상 관계 변환 - 변환 방법 :  ① 3진 이상의 관계 타입에 대해서 별도의 릴레이션을 생성한다.  ② 관계 타입에 참여하는 모든 개체 타입의 기본 키를 관계 릴레이션에 외래 키로 포함시킨다. ③ 관계 타입이 갖고 있는 모든 단순 속성(복합 속성을 갖고 있는 경우  복합 속성을 구성하는 단순 속성들)을 릴레이션에 포함시킨다. - 기본 키 : 일반적으로 외래 키들의 조합이 관계 릴레이션의 기본 키가 된다. - 변환 예제 : 하나의 과제(프로젝트)에 많은 사원과 부서  그리고 많은 장비가 연관됨을 표현 변환 릴레이션 스키마 과제수행(사원번호(FK)  부서번호(FK)  장비번호(FK)   시작일자  종료일자) 부서번호 참여부서 부서명 사원 사원번호 이름 담당업무 과제수행 N N 시작일자 장비 장비번호 장비명 N 종료일자 	1
0000	논리적 설계 단계 22 다중치 속성 변환 5. 다중치 속성 변환 - 변환 방법 :  ① 다중치 속성을 위한 별도의 릴레이션을 생성한다.  ② 다중치 속성을 갖는 개체 타입이나 관계 타입에 해당하는 릴레이션의 기본 키를 외래 키로 포함시킨다. - 기본 키: 외래 키와 다중치 속성의 조합이 기본 키가 된다. - 변환 예제 :  하나 이상 여러 개의 취미 정보를 포함하는 회원 개체 표현 릴레이션 스키마 변환 회원(회원번호   이름  주소  연락처) 취미(회원번호(FK)  취미종류) 회원 회원번호 이름 주소 연락처 취미 다중치 속성 	1
0000	논리적 설계 단계 23 Lesson.   릴레이션 단순화 방법과 릴레이션 생성 사례 1. 릴레이션 단순화 2. 릴레이션 생성 사례 3. 무결성 제약조건 정의 릴레이션 단순화 방법과 릴레이션 생성 사례 	1
0000	논리적 설계 단계 24 릴레이션 단순화 1. 릴레이션 단순화 (1) 일 대 일(1 : 1) 관계 단순화 - 관계를 표현하는 릴레이션을 따로 생성하지 않고  관계에 포함된 개체 가운데 한 개체에 관계의 속성을 모두 포함시켜서 전체 릴레이션을 단순화시킬 수 있다.  ① 단순화 방법 a) 관계에 포함된 두 개체 릴레이션 가운데 하나에 다음을 추가한다. ⓐ 관계에 포함된 다른 개체의 기본 키에 대응하는 속성 ⓑ 관계 자체의 속성 (있는 경우) b) 기존의 관계 릴레이션은 삭제한다. 	1
0000	논리적 설계 단계 25 릴레이션 단순화 ② 단순화 예:  부서번호 부서 부서명 사원 사원번호 이름 급여 관리하다 1 1 임명일자 릴레이션 단순화 1) 부서 개체 릴레이션에 사원 개체의 기본 키(사원 번호)와 관계 자체의 속성을 추가함 2) 관리하다 릴레이션은 삭제함 부서(부서번호  부서명  부서장번호(FK)  임명일자) 사원(사원번호  이름  급여) 사원(사원번호  이름  급여) 부서(부서번호  부서명) 관리하다(부서번호(FK)  사원번호(FK)   임명일자)  혹은 관리하다(사원번호(FK)  부서번호(FK)   임명일자) 혹은 1) 사원 개체 릴레이션에 부서 개체의 기본 키(부서 번호)와 관계 자체의 속성을 추가함 2) 관리하다 릴레이션은 삭제함 사원(사원번호  이름  관리부서번호(FK)  임명일자) 부서(부서번호  부서명) 보충 설명 릴레이션 변환 	1
0000	논리적 설계 단계 26 보충 설명 [보충 설명] - ‘관리하다’ 릴레이션을 단순화시킨 아래 2가지 가운데 어떤 것을 선택하는 것이 좋을까요? 부서(부서번호  부서명  부서장번호(FK)  임명일자) 사원(사원번호  이름  급여) 혹은 사원(사원번호  이름  급여  관리부서번호(FK)  임명일자) 부서(부서번호  부서명) a) 부서 개체 릴레이션에 관계를 포함시킴 b) 사원 개체 릴레이션에 관계를 포함시킴 - b)의 경우  사원 가운데 몇 명만이 부서장이지만 모든 사원 개체에 ‘관리부서번호’라는 속성(부서 개체의 기본 키인 부서번호에 해당함)이 포함되어 대부분 널(Null) 값을 갖게 되므로 기억장소가 낭비됨 - a)의 경우  모든 부서에 부서장이 있으므로 부서 개체 릴레이션에 부서장번호(사원 개체의 기본 키인 사원번호에 해당함)를 포함시키는 것이 타당함 계속 보기 X 	1
0000	논리적 설계 단계 27 보충 설명 è 두 가지 경우 각각 릴레이션에 포함된 데이터(릴레이션 인스턴스)를 확인하면 어떤 개체에 관계를 포함시키는 것이 좋은지 명확히 알 수 있다.  a) 부서 개체에 관계를 포함시킨 경우 사원번호 이름 급여 관리부서번호 임명일자 1234 박동희 4500000 사원 릴레이션 1326 김철수 2750000 1524 이영희 1700000 100 03/01/2010 2553 김창수 4700000 200 03/01/2010 3612 민동규 6500000 : : : : : 부서번호 부서명 부서장번호 임명일자 부서 릴레이션 100 관리부 1234 03/01/2010 200 경리부 2553 03/01/2010 300 개발부 3612 09/01/2011 : : : : b) 사원 개체에 관계를 포함시킨 경우 부서장이 아닌 사원은 모두 관리부서번호와 임명일자 속성이 널 값을 갖게 되므로 기억장소가 낭비됨 부서장번호와 일명일자 속성이 널 값을 갖는 데이터가 없음 300 09/01/2011 	1
0000	논리적 설계 단계 28 릴레이션 단순화 (2) 일 대 다(1 : n) 관계 단순화 - 관계를 표현하는 릴레이션을 따로 생성하지 않고  관계에 포함된 개체 가운데 N측 개체에 관계의 속성을 모두 포함시켜서 전체 릴레이션을 단순화시킬 수 있다.  ① 단순화 방법 a) 관계의 n측에 있는 개체 릴레이션에 다음을 추가한다. ⓐ 관계의 1측에 있는 개체의 기본 키에 대응하는 속성 ⓑ 관계 자체의 속성 (있는 경우) b) 기존의 관계 릴레이션은 삭제한다. 	1
0000	논리적 설계 단계 29 릴레이션 단순화 ② 단순화 예:  릴레이션 변환 릴레이션 단순화 사원(사원번호  이름  급여) 부서(부서번호  부서명) 근무하다(사원번호(FK)   부서번호(FK)) 사원(사원번호  이름  부서번호(FK)) 부서(부서번호  부서명  관리자) 근무하다 부서번호 부서 부서명 사원 사원번호 이름 급여 관리자 1 n n측 개체인 사원 개체에 1측 개체인 부서 개체의 기본 키 를 외래 키로 포함시킴 	1
0000	논리적 설계 단계 30 릴레이션 단순화 (3) 일 대 다(1 : n)  병렬 관계 변환 및 단순화 부서 공사 정산하다 부서번호 부서명 연락처 사무실 공사번호 공사명 시작일 종료일 1 N 감독하다 발주하다 1 1 N N 1) 부서 개체와 공사 개체 간의 병렬 관계 ERD  2) 릴레이션 스키마 변환 부서(부서번호  부서명   연락처  사무실) 공사(공사번호  공사명   시작일  종료일) 발주하다(공사번호(FK)  발주부서번호(FK))  감독하다(공사번호(FK)  감독부서번호(FK))  정산하다(공사번호(FK)  정산부서번호(FK))  3) 릴레이션 단순화 부서(부서번호  부서명   연락처  사무실) 공사(공사번호  공사명   시작일  종료일  발주부서번호(FK)  감독부서번호(FK)  정산부서번호(FK))  	1
0000	논리적 설계 단계 31 릴레이션 생성 사례 2. 릴레이션 생성 사례 (1) 온라인 쇼핑몰의 릴레이션 스키마 작성 - 소규모 온라인 쇼핑몰의 DB 구축 단계에서 작성된 다음 ERD를 릴레이션 스키마로 변환하기 [온라인 쇼핑몰 DB 구축을 위한 ERD]  상품 고객 거래처 판매 하다 구매 하다 M M N N 상품번호 상품명 상하의 구분 사이즈 id 이름 휴대폰 주소 배송지 pw 구매 횟수 거래처번호 상호 연락처 주소 주요취급 품목 대표자명 구매 일자 수량 수량 판매일자 배송일자 번호 주민등 록번호 판매 가격 구매 가격 	1
0000	논리적 설계 단계 32 릴레이션 생성 사례 ① 개체 릴레이션 생성 및 기본 키 설정 ② 관계 릴레이션 생성 및 기본 키 설정 ③ 릴레이션 스키마 단순화 - 2개의 관계 릴레이션이 모두 다 대 다(M : N) 유형이므로 단순화시킬 수 없다.   상품(상품번호  상품명  상하의구분  사이즈) 고객(id  pw  주민등록번호  이름  휴대폰  주소  배송지  구매횟수) 거래처(거래처번호   상호  연락처  주소  대표자명  주요취급품목)  판매하다(상품번호(FK)  고객id(FK)  번호  판매가격  수량  판매일자  배송일자) 구매하다(상품번호(FK)  거래처번호(FK)  구매가격  수량  구매일자)  	1
0000	논리적 설계 단계 33 릴레이션 생성 사례 è 최종 릴레이션 스키마: 상품(상품번호  상품명  상하의구분  사이즈) 고객(id  pw  주민등록번호  이름  휴대폰  주소  배송지  구매횟수) 거래처(거래처번호   상호  연락처  주소  대표자명  주요취급품목) 판매하다(상품번호(FK)  고객id(FK)  번호  판매가격  수량  판매일자  배송일자) 구매하다(상품번호(FK)  거래처번호(FK)  구매가격  수량  구매일자)  	1
0000	논리적 설계 단계 34 릴레이션 생성 사례 (2) 학사 관리 DB의 릴레이션 스키마 작성 - 학사 관리 DB 구축 단계에서 작성된 다음 ERD를 릴레이션 스키마로 변환하기 [학사 관리 DB 구축을 위한 ERD]  교 수 학 생 교과목 전공 성적 교과목 번호 교과목 명 학점 지도하다 강의하다 수강하다 교수 번호 교수 이름 학과 학번 이름 주소 학년 n n m n 1 1 시간 장소 교수 개체가 ‘강의하다’ 관계에 부분 참여인 것은 연구년 등의 사유로 강의 를 하나도 하지 않는 교수 가 있을 수 있기 때문임 	1
0000	논리적 설계 단계 35 릴레이션 생성 사례 ① 개체 릴레이션 생성 및 기본 키 설정 ② 관계 릴레이션 생성 및 기본 키 설정 교수(교수번호  교수이름  전공  학과) 학생(학번  이름  주소  학년) 교과목(교과목번호   교과목명  학점) 지도하다(학번(FK)  교수번호(FK)) 강의하다(교과목번호(FK)  교수번호(FK)  시간  장소) 수강하다(학번(FK)  교과목번호(FK)  성적)    	1
0000	논리적 설계 단계 36 릴레이션 생성 사례 ③ 릴레이션 스키마 단순화 a) ‘지도하다’ 관계 릴레이션의 단순화 - 1:N 유형이므로 N측 개체인 학생 개체 릴레이션에 1측 개체인 교수 개체 릴레이션의 기본 키인 ‘교수번호’를 외래 키로 포함시키고   ‘지도하다’ 관계 릴레이션은 삭제한다. b) ‘강의하다’ 관계 릴레이션의 단순화 - 1:N 유형이므로 N측 개체인 교과목 개체 릴레이션에 1측 개체인 교수 개체 릴레이션의 기본 키인 ‘교수번호’를 외래 키로 포함시키고   ‘강의하다’ 관계의 자체 속성인 ‘시간’과 ‘장소’ 속성도 포함시킨 다음  ‘강의하다’ 관계 릴레이션은 삭제한다. c) ‘수강하다’ 관계 릴레이션의 단순화 - M : N 유형이므로 단순화시킬 수 없다.  학생(학번  이름  주소  학년  교수번호(FK)) 교과목(교과목번호   교과목명  학점   교수번호(FK)  시간  장소) 	1
0000	논리적 설계 단계 37 릴레이션 생성 사례 è 최종 릴레이션 스키마: 교수(교수번호  교수이름  전공  학과) 학생(학번  이름  주소  학년  교수번호(FK)) 교과목(교과목번호   교과목명  학점   교수번호(FK)  시간  장소) 수강하다(학번(FK)  교과목번호(FK)  성적)    릴레이션 변환 초기에는 여섯 개의 릴 레이션이 생성되었는데  단순화 과정을 통해서 네 개의 릴레이션으로 줄어든 것을 알 수 있음 	1
0000	논리적 설계 단계 38 무결성 제약조건 정의 3. 무결성 제약조건 정의 (1) 무결성 제약조건(Integrity Constraints) 이란?  - DB에 저장된 데이터의 정확성과 일관성 유지를 위해서 DB가 항상 만족해야 하는 조건을 의미한다.  (2) 관계 데이터 모델의 무결성 제약조건 구분 내용 개체 무결성 (Entity Integrity) 기본 키는 튜플들을 유일하게 식별하기 위해서 널 값을 가질 수 없다는 제약조건 참조 무결성 (Referential Integrity) 외래 키는 반드시 피참조 릴레이션의 기본 키 값이나 널 값을 가 져야 한다는 제약조건 의미 무결성 (Semantic Integrity) 특정 속성이 반드시 미리 정해진 값을 가져야 한다는 제약조건 	1
0000	논리적 설계 단계 39 무결성 제약조건 정의 (3) 무결성 제약조건 정의 방법 구분 (4) 무결성 제약조건 정의 기준 ① ERD를 릴레이션 스키마로 변환하면서 기본 키와 외래 키가 식별되면 개체 무결성과 참조 무결성은 묵시적으로 정의되므로  논리적 모델링 단계에서 별도로 정의할 필요는 없다.  ② 널 값 허용 여부(NOT NULL 제약조건)  고유 값 여부(UNIQUE 제약조건)  속성 값이 만족해야 하는 특정 조건(CHECK 제약조건) 등의 제약조건은 논리적 모델링 단계에서 명시적으로 정의한다. 구분 내용 묵시적 정의 릴레이션을 정의할 때 기본 키와 외래 키를 정의하면  개체 무결성과 참조 무결성이 묵시적으로 정의된다. 명시적 정의 개체 무결성과 참조 무결성 이외에  데이터의 정확성과 일관성 유지를 위해서 특정 속성이 만족해야 하는 무결성 제약조건(NOT NULL  UNIQUE  CHECK 등)은 명시적으로 정의해야 한다. 	1
0000	논리적 설계 단계 40 무결성 제약조건 정의 (5) 온라인 쇼핑몰 DB의 무결성 제약조건 정의 사례 No. 제약조건 제약 유형 관련 릴레이션 1 상품명과 사이즈는 널 값을 가질 수 없다.  NOT NULL 상품 2 상품명은 유일한 값을 가져야 한다.  UNIQUE 상품 3 pw와 주민등록번호  이름  휴대폰  주소는 널 값을 가질 수 없다.  NOT NULL 고객 4 주민등록번호와 휴대폰은 유일한 값을 가져야 한다.  UNIQUE 고객 5 상호와 연락처는 널 값을 가질 수 없다.  NOT NULL 거래처 6 상호는 유일한 값을 가져야 한다.  UNIQUE 거래처 7 번호  수량  판매일자는 널 값을 가질 수 없다.  NOT NULL 판매하다 8 번호는 유일한 값을 가져야 한다.  UNIQUE 판매하다 9 수량  구매일자는 널 값을 가질 수 없다.  NOT NULL 구매하다 	1
0000	논리적 설계 단계 41 무결성 제약조건 정의 (6) 학사 관리 DB의 무결성 제약조건 정의 사례 No. 제약조건 제약 유형 관련 릴레이션 1 교수이름  전공  학과는 널 값을 가질 수 없다.  NOT NULL 교수 2 이름과 학년은 널 값을 가질 수 없다 NOT NULL 학생 3 주민등록번호와 휴대폰은 유일한 값을 가져야 한다. UNIQUE 학생 4 교과목명  학점   교수번호는 널 값을 가질 수 없다.  NOT NULL 교과목 5 교과목명은 유일한 값을 가져야 한다.  UNIQUE 교과목 	1
0000	논리적 설계 단계 42 쉼터 쉼터 꿈은 살아있는 사람의 의무이자 권리이다! 아들아! 죽는 날까지 꿈꾸기를 포기하지 마라.  매일 꿈을 꾸어라. 꿈꾸지 않는 사람은 아무것도 얻을 수 없으며  오직 꿈꾸는 자만이 비상할 수 있다. 꿈에는 한계가 없다. 마음껏 꿈꿔라. 꿈을 꾼다는 것은 살아 있다는 증거이고 사람이 살아 있는 동안에 반드시 해야 할 의무이자 권리이다. -송길원  ‘나를 딛고 세상을 향해 뛰어올라라’ 중에서 저작권 검토!  꿈을 꾸면 목표가 생기고  목표를 잘게 나누면 계획이 되고  계획을 하나씩 실행하면 꿈은 이루어집니다.     - 토지의 작가  박경리 	1
0000	데이터베이스 데이터베이스 - Story Board - 13 회차 : 릴레이션 정규화 김 은 경 	1
0000	릴레이션 정규화 2 학습목표 동기유발 & 학습목표 학습내용 1. 갱신 이상과 함수적 종속 학습목표 2. 단계별 정규화와 역정규화 1. 갱신 이상이 무엇인지 설명할 수 있다.  2. 함수적 종속이 무엇인지 설명할 수 있다.  1. 정규화가 무엇인지 설명할 수 있다.  2. 정규화의 단계를 설명할 수 있다.  2. 역정규화가 필요한 이유를 설명할 수 있다.  	1
0000	릴레이션 정규화 3 Lesson.   갱신 이상과 함수적 종속 1. 갱신 이상 2. 함수적 종속 3. 완전 함수적 종속과 부분 함수적 종속 4. 이행적 함수적 종속 갱신 이상과 함수적 종속 	1
0000	릴레이션 정규화 4 갱신 이상 1. 갱신 이상 (1) 갱신 이상(Update Anomaly)이란?   - 관계 DB를 조작할 때 데이터의 중복으로 인해 발생하는 문제점을 의미한다.  (2)  갱신 이상의 종류 ① 삽입 이상(Insertion Anomaly)  - 불필요한 데이터를 함께 삽입하지 않으면 어떤 데이터를 삽입하는 것이 불가능한 문제점 - 즉  데이터를 삽입할 때 원하지 않는 불필요한 데이터를 같이 삽입해야 하는 것 ② 수정 이상(Modification Anomaly) - 중복된 데이터 가운데 일부만 수정되어 데이터의 불일치가 발생하는 문제점 ③ 삭제 이상(Deletion Anomaly) - 어떤 데이터를 삭제하면 유용한 데이터도 함께 삭제되는 문제점 	1
0000	릴레이션 정규화 5 갱신 이상 (3) 갱신 이상 사례 1) 사례 1: 수강 릴레이션 - 학생이 수강한 교과목 정보와 성적 및 학년 정보 저장 - 기본 키 : {학번  교과목번호}  학번 교과목번호 성적 학년 100 C413 A 4 100 E412 A 4 200 C123 B 3 300 C312 A 1 300 C324 C 1 300 C413 A 1 400 C312 A 4 400 C324 A 4 400 C413 B 4 400 E412 C 4 500 C312 B 2 수강 수강 릴레이션에 서 여러 가지 갱신 이상이 발생 하는 이유는? 같은 학번에 대 해 학년 정보가 중복되어 있기 때문이다.  	1
0000	릴레이션 정규화 6 갱신 이상 ① 삽입 이상 - 600번 학생이 2학년이라는 사실을 삽입하려는데  교과목번호에 대한 정보가 없어서 불가능함  기본 키를 구성하는 ‘교과목번호’에 임의의 값을 지정해서 삽입해야 함 - 원하지 않는(불필요한) 정보를 강제로 삽입해야 함 ② 수정 이상 - C312 교과목을 수강한 400번 학생의 학년을 4에서 3으로 변경하면   나머지 3개 데이터의 학년 정보와 불일치가 발생함  학번이 400번인 데이터를 모두 찾아서 전부 변경해야 함 - 중복된 데이터의 일부 갱신으로 인해 정보의 모순이 발생함 ③ 삭제 이상 - 200번 학생이 C123의 수강을 취소해서 삭제시키면  200번 학생이 3학년이라는 정보도 함께 삭제됨  유용한 정보가 사라짐 - 연쇄 삭제(Triggered deletion)로 인해 유용한 정보가 손실됨 	1
0000	릴레이션 정규화 7 갱신 이상 2) 사례 2: 사원정보 릴레이션 - 사원과 부서 정보를 함께 저장함 (기본 키는 사원번호와 부서번호의 조합) - 단  한 사원이 여러 부서에 근무할 수 있는 상황임 사원이름 사원번호 주소 전화번호 부서번호 부서이름 김길동 1001 서울시 강남구 02-485-3949 1 영업 박영숙 1002 서울시 동작구 02-683-5542 2 개발 박영숙 1002 서울시 동작구 02-683-5542 3 기획 이창민 1003 천안시 성정동 041-756-4857 2 개발 최수민 1004 서울시 강북구 02-339-4957 1 영업 	1
0000	릴레이션 정규화 8 갱신 이상 ① 정보 중복 - 각 사원이 속한 부서 수만큼 동일한 사원의 정보가 존재해야 하므로 사원이름  사원번호  주소  전화번호 등이 중복 저장되어 저장 공간이 낭비된다.  ② 수정 이상 - 만일 어떤 부서의 이름이 바뀔 때 이 부서에 근무하는 일부 사원 정보의 부서이름만 변경하면 데이터의 불일치가 발생한다.  ③ 삽입 이상 - 만일 어떤 부서를 신설했는데 아직 사원이 한 명도 배정되지 않았다면   이 부서에 관한 정보를 입력할 수 없다.  ④ 삭제 이상 – 만일 단 한 명만 근무하는 부서가 있는 경우  그 사원 정보를 삭제하면 그 사원이 속한 부서에 관한 정보도 함께 삭제된다.  	1
0000	릴레이션 정규화 9 갱신 이상 (4) 갱신 이상의 원인 - 릴레이션 스키마를 생성할 때 속성들 간의 종속성을 충분히 고려하지 않아서 불필요한 데이터가 중복되었기 때문이다.  - 즉  한 개체의 속성들 간에 존재하는 여러 개의 종속 관계를 하나의 릴레이션으로 표현했기 때문이다.  (5) 갱신 이상 해결 방법 - 릴레이션 스키마를 변환해서 속성들 간의 여러 종속 관계를 분해(Decomposition)한다.  즉  릴레이션을 분해해서 하나의 종속 관계는 하나의 릴레이션으로 표현한다.  이 과정을 릴레이션 정규화(Relation Normalization)라고 칭함 	1
0000	릴레이션 정규화 10 함수적 종속 2. 함수적 종속 (1) 함수적 종속(Functional Dependency: FD) 이해 1) 함수적 종속이란?  - 속성들 간의 대응 관계를 보다 수학적으로 규명하기 위해 E. F. Codd가 제안한 이론으로   정규화의 핵심적인 개념이다.   - 릴레이션이 갖고 있는 갱신 이상을 발견하기 위한 하나의 수단이다.  - 속성들 간의 관계(Relationship)에 대한 제약 조건에 해당한다.   2) 함수적 종속의 정의 및 표현 방법 - 속성 X의 값이 속성 Y의 값을 결정지으면  즉 속성 X의 각각의 값에 대해 속성 Y의 값이 오직 하나만 연관되면  속성 Y는 속성 X에 함수적으로 종속된다고 하고  다음과 같이 표현한다.  X → Y . X: 결정자(Determinant) . Y: 종속자(Dependent)   결정자 - 주어진 릴레이션에서 다른 속성(또는 속성의 집합)을 고유하게 결정하는 하나 이상의 속성들  종속자 - 결정자에 의해서 값이 결정되는 하나 이상의 속성들 	1
0000	릴레이션 정규화 11 함수적 종속 3) 예제 1 : 학생 릴레이션의 함수적 종속 관계 분석 ① 이름이 같은 학생이 여러 명 있을 수 있으므로  이름을 알아도 학번이나 학년  학과를 알 수 없다.  -> 이름이 학번이나 학년  학과를 함수적으로 결정하지 않는다. ② 모든 학생의 학번이 서로 다르므로  학번을 알면 이름과 학년  학과를 알 수 있다.  -> 학번이 알면 이름과 학년  학과를 함수적으로 결정한다.  학생(학번  이름  학년  학과)  학번 이름 학년 학과 20113910 김철수 2 컴퓨터 20123929 이영희 1 전기 20103932 민동규 3 전자 20113934 장영주 2 컴퓨터 20123900 김철수 1 정통 학생 	1
0000	릴레이션 정규화 12 함수적 종속  학생 릴레이션의 함수적 종속 관계 표현: 학번 → 이름 학번 → 학년 학번 → 학과 학번 → (이름  학년  학과) 또는 학번 → 이름 | 학년 | 학과 또는  릴레이션 R에서 속성 X가 기본 키이면   R의 모든 속성 Y에 대해 X  → Y가 성립한다.   	1
0000	릴레이션 정규화 13 함수적 종속 4) 예제 2 : 사원 릴레이션의 함수적 종속 관계 분석 ① 사원번호만 알면 사원이름과 주소  연락처를 알 수 있다.  -> 사원번호가 사원이름과 주소  연락처를 함수적으로 결정한다.   함수적 종속 표현 :  사원번호 → (사원이름  주소  연락처)  ② 부서번호를 알면 부서이름을 알 수 있다.           -> 부서번호가 부서이름을 함수적으로 결정한다.   함수적 종속 표현 :  부서번호 →  부서이름 사원(사원번호   부서번호  부서이름  이름  직책  주소  연락처)  단  한 사원이 2개 이상의 부서에 소속되어 근무할 수 있고  각 부서에서의 직책이 다를 수 있다.  사원번호 부서번호 부서이름 이름 직책 주소 연락처 3214 100 기획팀 김철수 팀장 서울 010-2300-1232 2456 200 개발팀 이영호 프로그래머 천안 010-9932-3234 2456 300 연구팀 이영호 설계자 천안 010-9932-3234 4602 100 기획팀 박민희 사원 서울 010-3329-0032 3722 300 연구팀 김철수 팀장 천안 010-3398-2136 사원 	1
0000	릴레이션 정규화 14 함수적 종속 ③ 부서이름을 알면 부서번호를 알 수 있다.   (사람 이름과는 달리 일반적으로 동일한 이름을 갖는 부서가 없으므로)  -> 부서이름이 부서번호를 함수적으로 결정한다.   함수적 종속 표현 :  부서이름 →  부서번호 ④ 사원번호와 부서번호를 모두 알아야 직책을 알 수 있다 -> {사원번호  부서번호}가 직책을 함수적으로 결정한다.  함수적 종속 표현 :  {사원번호  부서번호} → 직책 ⑤ 사원이름을 알아도 사원번호나 부서번호  주소 등을 알 수 없다.  -> 사원이름은 나머지 속성들을 함수적으로 결정하지 않는다.   사원 릴레이션의 함수적 종속 관계 표현: 사원번호 → (사원이름  주소  연락처)  부서번호 → 부서이름 부서이름 → 부서번호 {사원번호  부서번호} → 직책 {사원번호  부서번호}가 기본 키이므로 나머지 모든 속성의 결정자를 역할을 하지만  여기에서는 뒤에서 설명할 완전 함수 종속 관계만을 표현한 것임 	1
0000	릴레이션 정규화 15 함수적 종속 3) 예제 3 : 회원관리 릴레이션의 함수적 종속 관계 분석 회원관리 (회원번호  회원명  연락처  가입일자  담당트레이너  트레이너이름  트레이너연락처)  회원 회원번호 회원명 연락처 가입일자 담당 트레이너 트레이너 이름 트레이너 연락처 1001 김길동 010-3485-3949 2014/3/1 1 장영민 041-575-1231 1002 박영숙 010-6383-5542 2014/3/1 2 민동진 041-575-1232 1003 이창민 010-2683-5542 2014/3/15 1 장영민 041-575-1231 1004 이민수 041-840-1234 2014/4/10 2 민동진 041-575-1232 1005 김영미 041-840-1234 2014/4/10 1 장영민 041-575-1231 1006 박민이 001-6333-5212 2014/4/25 2 민동진 041-575-1232 1007 최영민 010-2793-1242 2014/4/30 1 장영민 041-575-1231 1008 김동수 010-3025-0249 2014/5/2 2 민동진 041-575-1232 1009 박영숙 010-6243-1042 2014/5/8 1 장영민 041-575-1231 1010 박장수 010-2083-5302 2014/5/8 2 민동진 041-575-1232 1011 이정이 010-3756-2957 2014/5/10 3 김은미 041-575-1231 	1
0000	릴레이션 정규화 16 함수적 종속 ① 회원이름은 현재 동명이인이 존재하므로 결정자가 될 수 없음 ▶ 회원이름이 회원번호나 연락처  담당 트레이너 등을 함수적으로 결정하지 않음 ② 트레이너 이름은 현재는 동명이인이 존재하지 않으나 추후 동명이인의 가능성을 배제할 수 있으 므로 결정자가 될 수 없음 ③ 회원번호를 몰라도 담당트레이너의 번호만 알면 트레이너의 이름이나 연락처를 알 수 있음 ▶ 담당트레이너 속성이 트레이너이름과 트레이너연락처를 함수적으로 결정함 ④ 트레이너 연락처는 사무실 번호로  여러 명의 트레이너가 동일한 번호를 공유하므로 결정자가 될 수 없음 ⑤ 회원번호는 기본 키이므로 나머지 모든 속성을 함수적으로 결정함  회원관리 릴레이션의 함수적 종속 관계 표현: 회원번호 → (회원명  연락처  가입일자  담당트레이너  트레이너이름  트레이너연락처)  담당트레이너 → (트레이너이름  트레이너연락처) 	1
0000	릴레이션 정규화 17 함수적 종속 (2) 함수적 종속 다이어그램 1) 함수적 종속 다이어그램(Functional Dependency Diagram : FDD)이란?  - 함수적 종속 관계를 그림으로 표현하는 방법이다.   - 결정자와 종속자를 모두 직사각형으로 표시하고  화살표로 연결해서 표시한다.  2) 예제 1 :  교과목 릴레이션의 FDD 작성 교과목(교과목번호  교과목명  학점  학과  담당교수)  교과목번호 교과목명 학점 학과 담당교수 C123 컴퓨터개론 3 컴퓨터 1102 C234 프로그래밍 3 전자 1200 C257 자료구조 3 컴퓨터 1322 C156 프로그래밍 2 전기 1565 C198 데이터베이스 3 컴퓨터 1422 	1
0000	릴레이션 정규화 18 함수적 종속 ② FDD 작성 교과목번호 교과목명 학점 학과 담당교수 ① 함수적 종속 관계 분석 a) 결정자 역할을 하는 속성은 기본 키인 교과목번호 밖에 없다.  -> 교과목번호가 나머지 모든 속성들을 함수적으로 결정한다.  함수적 종속 표현 :  교과목번호 → (교과목명  학점  학과  담당교수) b) 교과목명을 알아도 교과목번호나 학점  학과  담당교수를 알 수 없으므로 교과목명은 어떤 속성도 함수적으로 결정하지 않는다.  (동일한 교과목명을 갖는 강의가 서로 다른 학과에서 개설되어  다른 교과목번호와 학점 등으로 표현될 수 있기 때문)  	1
0000	릴레이션 정규화 19 함수적 종속 3) 예제 2 :  사원 릴레이션의 FDD 작성 사원(사원번호   부서번호  사원이름  주소  전화번호  직책  부서이름)  단  한 사원이 2개 이상의 부서에 소속되어 근무할 수 있고  각 부서에서의 직책이 다를 수 있다.  사원번호 → (사원이름  주소  전화번호)  부서번호 → 부서이름 부서이름 → 부서번호 {사원번호  부서번호} → 직책 ① 함수적 종속 관계 표현 사원번호 부서번호 부서이름 이름 직책 주소 연락처 3214 100 기획팀 김철수 팀장 서울 010-2300-1232 2456 200 개발팀 이영호 프로그래머 천안 010-9932-3234 2456 300 연구팀 이영호 설계자 천안 010-9932-3234 4602 100 기획팀 박민희 사원 서울 010-3329-0032 3722 300 연구팀 김철수 팀장 천안 010-3398-2136 사원 	1
0000	릴레이션 정규화 20 함수적 종속 ② FDD 작성 사원번호 사원이름 주소 전화번호 부서번호 부서이름 직책 	1
0000	릴레이션 정규화 21 함수적 종속 3. 완전 함수적 종속과 부분 함수적 종속 - 결정자가 복합 속성인 경우  종속자를 완전 또는 부분 함수적 종속으로 구분할 수 있다.  (1) 완전 함수적 종속(Full Functional Dependency)이란?  - 복합 속성 X에 대해서 X → Y가 성립할 때  X⊂X 이고 X→ Y 를 만족하는 속성 X’ 이 존재하지 않으면  속성 Y는 복합 속성 X에 완전 함수적 종속이라 칭한다.  - 즉  결정자인 복합 속성에 포함되는 속성 가운데 단독으로 결정자 역할을 하는 속성이 없으면   종속자가 결정자에 완전 함수적 종속이라고 칭한다. A B C [완전 함수적 종속 다이어그램] 복합 속성인 {A  B}가 C의 결정자이며  A나 B만으로는 C를 결정 할 수 없다. 	1
0000	릴레이션 정규화 22 함수적 종속 (2) 부분 함수적 종속(Partial Functional Dependency)이란?  - 복합 속성 X에 대하여 X → Y가 성립할 때  X⊂X 이고 X→ Y 를 만족하는 속성 X’ 이 존재하면   속성 Y는 복합 속성 X에 부분 함수적 종속이라 칭한다.  - 즉  결정자인 복합 속성에 포함되는 속성 가운데 단독으로 결정자 역할을 하는 속성이 있으면   종속자가 결정자에 부분 함수적 종속이라고 칭한다. A B C [부분 함수적 종속 다이어그램] 복합 속성인 {A  B}가 C의 결정자이지만  B 만으로도 C를 결정할 수 있다. 	1
0000	릴레이션 정규화 23 함수적 종속 (3) 예제 : 사원 릴레이션의 완전 및 부분 함수적 종속 관계 분석 - 복합속성 X = {사원번호  부서번호}에 대해 {사원번호  부서번호} → (직책  사원이름  주소   전화번호  부서이름)가 성립하며    ① 직책의 결정자는 복합속성 X이고  사원번호나 부서번호만으로는 직책을 결정하지 못하므로 직책은 결정자 X에 완전 함수적 종속이다.  ② 사원이름  주소  전화번호의 결정자는 사원번호이고  사원번호는 복합속성 X에 포함되므로 사원이름  주소  전화번호는 결정자 X에 부분 함수적 종속이다.  ③ 부서이름의 결정자는 부서번호이고  부서번호는 복합속성 X에 포함되므로 부서이름은 결정자 X에 부분 함수적 종속이다.  사원번호 사원이름 주소 전화번호 부서번호 부서이름 직책 	1
0000	릴레이션 정규화 24 함수적 종속 4) 예제 : 수강 릴레이션의 완전 및 부분 함수적 종속 관계 분석  ① 성적 : {학번  교과목번호}에 완전 함수적 종속이다.  ② 학년 : {학번  교과목번호}에 부분 함수적 종속이다 수강(학번  교과목번호  성적  학년)  FD:  {학번  교과목번호}  → 성적 학번 → 학년 FDD:  학번 교과목번호 성적 학년 	1
0000	릴레이션 정규화 25 함수적 종속 4.  이행적 함수적 종속 (1) 이행적 함수적 종속(Transitive Functional Dependency)이란?  - 한 릴레이션의 속성 A  B  C가 있을 때 다음과 같은 필요 충분 조건을 만족하는 경우   속성 C가 속성 A에 이행적(또는 추이적) 함수적 종속이라고 한다.  (2) 예제 : 학생 릴레이션의 이행적 함수적 종속 관계 분석 A → B  ∧  B → C 학생(학번  교과목번호  성적  학과이름  학과전화번호)  FD:  {학번  교과목번호}  → 성적 학번 → (학과이름  학과전화번호)  학과이름 → 학과전화번호 FDD:  학번 교과목번호 성적 학과이름 학과전화번호  “학번 → 학과이름  학과이름 → 학과전화번호”라는 2개의 필요 충분 조건을 만족하므로 학과전화번호는 학번에 이행적 함수적 종속 관계이다.  	1
0000	릴레이션 정규화 26 Lesson.  단계별 정규화와 역정규화 1. 정규화 개념 2. 정규형 구분 3. 단계별 정규화 4. 역정규화 단계별 정규화와 역정규화 	1
0000	릴레이션 정규화 27 정규화 개념 1. 정규화 개념 (1) 정규화(Normalization)란?  - 정규화는 다음과 같이 여러 가지 관점에서 정의할 수 있다. ① 스키마 변환을 통해서 일련의 제약 조건을 만족하는 릴레이션을 만드는 과정이다.    ② 속성들 간의 종속성을 분석해서 하나의 릴레이션에는 하나의 종속성만 갖도록 릴레이션을 분해하는 과정이다. ③ 갱신 이상의 발생 요인인 데이터 중복을 최소화하기 위해서 일종의 제약조건을 기초로 릴레이션을 분해하는 과정이다.  ④ 불필요한 데이터 중복을 제거해서 논리적 데이터 모델을 단순화시키는 과정이다.  (2) 정규화의 원칙 ① 데이터의 중복을 최소화한다. ② 정보가 사라지지 않아야 한다. (정보의 무손실)  - 같은 의미의 정보를 유지하면서 더 바람직한 구조로 변환해야 한다.   ③ 다음과 같은 원칙에 따라 분해한다. a) 독립적인 관계는 별개의 릴레이션으로 표현한다. b) 릴레이션 각각에 대해 독립적인 조작이 가능해야 한다. 	1
0000	릴레이션 정규화 28 정규화 개념 조인(Join) - 두 릴레이션과 관 련된 튜플을 하나의 튜 플로 결합하는 연산 (3) 정규화되지 않은 릴레이션의 문제점 ① 데이터 중복으로 인해 갱신 이상 현상이 발생한다.  ② 특정 정보를 표현하는 것이 불가능할 수 있다.  ③ 널(NULL) 값을 많이 포함하게 된다.  ④ 저장된 정보가 부정확할 수 있다.  (4) 정규화의 효과 ① 중복된 데이터가 제거되어 갱신 이상이 감소한다.  ② 데이터의 일관성 유지가 가능하다.  ③ 데이터 모델이 단순해진다.  ④ 무결성 제약조건을 만족시키기 위해서 필요한 프로그램 코드 양이 감소한다.  즉  DBMS가 자동 으로 처리해 주므로 응용 프로그램에서 처리해야 할 일의 양이 감소한다.  (5) 정규화의 문제점 - 릴레이션(테이블) 분해로 인해 많은 조인(Join) 연산이 발생하므로 질의에 대한 응답 시간이 느려질 수 있다.  보충 학습 	1
0000	릴레이션 정규화 29 [보충 학습] [보충 학습] 조인(Join) 연산 (1) 조인 연산이란?   - 두 릴레이션과 관련된 튜플을 하나의 튜플로 결합하는 연산으로  두 릴레이션의 각 튜플들을 1:1로 대응시킨 다음  조건에 맞는 튜플들만 구하는 연산이다.  - 세타 조인  동일 조인  자연 조인 등 여러 가지 유형의 조인 연산이 있다. - 관계 대수에서는 조인 연산자로 ⋈ 기호를 사용한다.   (2) 조인 연산 예제 - 학생 릴레이션과 교수 릴레이션의 조인 (조건: 학생.지도교수 = 교수.교수번호)  학생 릴레이션 학번 주민등록번호 이름 주소 휴대폰 지도교수 98201002 99202012 98201025 800321 811123 810923 김정욱 이기원 박문구 천안 서울 대전 010-2233-0495 010-2200-0045 010-2341-2312 01223 02355 01223  학생 ⋈ 지도교수=교수번호 교수 :  학생과 교수 릴레이션을 조인한 릴레이션 학번 주민등록번호 이름 주소 휴대폰 지도교수 98201002 99202012 98201025 800321 811123 810923 김정욱 이기원 박문구 천안 서울 대전 010-2233-0495 010-2200-0045 010-2341-2312 01223 02355 01223 교수번호 이름 연구실 휴대폰 01223 02355 05378 장경구 김민숙 이장수 A112 B344 A322 010-9876-2121 010-1234-5678 010-2266-9988 교수 릴레이션 교수번호 이름 연구실 휴대폰 01223 02355 05378 장경구 김민숙 이장수 A112 B344 A322 010-9876-2121 010-1234-5678 010-2266-9988 학생 릴레이션의 지도교수 속 성의 값과 교수 릴레이션의 교 수번호 속성의 값이 같은 것끼 리 조인하라는 의미 	1
0000	릴레이션 정규화 30 정규형 구분  정규형(Normal Form) - 어 떤 제약 조건을 만족하는 형 태 2. 정규형 구분 데이터 중복 감소 응답시간 단축 (1) 정규형(Normal Form)의 구분 - ‘데이터의 불필요한 중복 감소’와 ‘응답시간 단축’이라는 상반된 목표를 달성하기 위해서  릴레이션이 만족해야 하는 제약 조건을 구분하고  제약 조건에 따라 제1정규형 ~ 제5정규형 그리고 보이스코드 정규형으로 구분한다.   (2) 정규형의 포함 관계 정규화 정도가 높을수록 릴레이션이 더 많이 분 해되어 중복된 데이터가 감소하게 됨 정규화 정도가 낮을수록 하나 의 릴레이션에 많은 정보가 포 함되어 있어서 조인 연산이 불 필요하게 되므로  응답 시간이 단축됨 	1
0000	릴레이션 정규화 31 정규형 구분 (3) 단계별 정규형과 제약 조건 - 각 단계별로 정규형이 만족해야 하는 제약 조건과 정규화 방법에 차이가 있다.  정규형 단계 제약 조건 정규화 방법 제 1 정규형 (1NF) 모든 속성의 도메인이 원자 값이어야 한다.  다중치 속성 및 중복 속성을 분리한다. (다중치와 반복 그룹 제거) 제 2 정규형 (2NF) 모든 속성이 기본 키에 완전 함수적 종속이어야 한다.    기본 키에 부분 함수적 종속인 속성을 분리한다. (부분 함수적 종속 제거)  제 3 정규형 (3NF) 속성들 간에 이행적 함수적 종속이 없어야 한다.  이행적 함수적 종속인 속성을 분리 한다. (이행적 함수적 종속 제거)  보이스/코드 정규형 (BCNF) 후보 키가 아닌 결정자가 없어야 한다.  후보 키가 아니면서 결정자 역할을 하는 속성과 그 종속자를 분리한다.  (모든 결정자가 후보 키)  제 4 정규형 (4NF) 다치 종속(Multi-valued Dependency) 인 속성이 없어야 한다.  다치 종속인 속성을 분리한다. 제 5 정규형 (5NF) 조인 종속(Join Dependency)인 속성이 없어야 한다.  조인 종속인 속성을 분리한다. 	1
0000	릴레이션 정규화 32 정규형 구분 (4) 제 3 정규형이 가장 좋은 이유 - 실무에서의 효율성을 고려해서 정규화의 최종 목표를 3NF나 BCNF로 정하는 것이 좋은데  그 이유는 1  2  4  5 정규형이 다음 표와 같은 문제점을 내포하기 때문이다.  구분 문제점 1NF  2NF ① 3NF와 비교하면 불필요한 중복이 많다. ② 불필요한 중복으로 인해 기억공간의 낭비가 크다.  4NF  5NF ① 3NF와 비교하면 릴레이션 수가 지나치게 많아질 가능성이 있다.   DB를 생성하면 테이블이 과다하게 세분화되어  조인(Join) 횟수가 늘어나서 질의에 대한 응답시간이 늦어지게 된다.  ② 다치 종속과 조인 종속이라는 복잡한 형태의 종속성까지 고려해야 한다. 	1
0000	릴레이션 정규화 33 단계별 정규화 (1) 정규화 단계 - 일반적으로 제 1 정규형부터 보이스/코드(BCNF) 정규형까지 단계별로 진행한다. - 실제 정규화 과정은 정규형 순서와 다를 수 있다. 즉  어떤 정규형은 건너뛸 수 있다.   - 정규화는 실제 데이터 값이 아닌 개념적 측면에서 수행되어야 한다.    조인 종속성 제거 [정규화 단계}  3. 단계별 정규화 	1
0000	릴레이션 정규화 34 단계별 정규화 (2) 비정규형 1) 다중치 속성을 포함하고 있는 비정규형  복수 개의 값 각각에 대해 하나씩의 튜플을 생성해서 새로운 릴레이션(제 1 정규형)을 만든다. 예) ‘동아리’라는 다중치 속성을 포함하고 있는 비정규형 테이블인 학생1 테이블 (기본 키: 학번)  학번 이름 학과 동아리 20013426 박하늘 컴퓨터학과 {영어회화반  검도부}  20025714 홍길동 영문학과 {수화반  합창반} 20038540 김동아 음악학과 미술반 99570264 이몽룡 사회복지학과 검도부 97456123 최푸름 국어국문과 축구부 학생1  동아리라는 다중치 속성이 존재하므로 제1정규형을 만족하지 않는다.  	1
0000	릴레이션 정규화 35 단계별 정규화 학번 이름 학과 동아리 20013426 박하늘 컴퓨터학과 영어회화반 20013426 박하늘 컴퓨터학과 검도부 20025714 홍길동 영문학과 수화반 20025714 홍길동 영문학과 합창반 20038540 김동아 음악학과 미술반 99570264 이몽룡 사회복지학과 검도부 97456123 최푸름 국어국문과 축구부 -> 릴레이션의 모든 속성은 원자 값만을 가져야 하므로  동아리 속성의 복수 개의 값 각각에 대해 하나씩의 튜플을 생성해서 학생2라는 새로운 릴레이션(기본 키: {학번  동아리})을 만든다.  학생2  학생2 릴레이션은 제 1  정규형의 제약 조건(모든 속성의 도메인이 원자 값 이어야 함)을 만족한다.  학생2 릴레이션의 기본 키는 {학번   동아리}이다. 만약 학번만 기본 키 로 정의하는 경우  2번째  4번째 튜 플은 개체 무결성에 위반되므로 삽 입될 수 없다. 	1
0000	릴레이션 정규화 36 단계별 정규화 학번 이름 학과 동아리 20013426 박하늘 컴퓨터학과 영어회화반 20013426 박하늘 컴퓨터학과 검도부 20025714 홍길동 영문학과 수화반 20025714 홍길동 영문학과 합창반 20038540 홍길순 음악학과 미술반 99570264 이몽룡 사회복지학과 검도부 97456123 최푸름 국어국문과 축구부 2) 중복된 속성을 포함하고 있는 비정규형  동일한 값이 중복되어 나타나는 반복 그룹을 분리해서 2개의 새로운 릴레이션(제 1 정규형)을 만든다. 예) 동일한 {학번  이름  학과} 값이 반복되는 학생2 릴레이션 (기본 키: {학번  동아리}) 학생2  학번  이름  학과 속성 의 동일한 값이 반복됨 	1
0000	릴레이션 정규화 37 단계별 정규화 -> 반복 그룹 {학번  이름  학과} 속성을 분리해서 학생3(기본 키: 학번) 릴레이션을 만들고    나머지 속성인 동아리 속성과 기본 키인 학번을 분리해서 학생4(기본 키 : {학번  동아리})라는 릴레이션을 만든다.  학번 이름 학과 20013426 박하늘 컴퓨터학과 20025714 홍길동 영문학과 20038540 홍길순 음악학과 99570264 이몽룡 사회복지학과 97456123 최푸름 국어국문과 학번 동아리 20013426 영어회화반 20013426 검도부 20025714 수화반 20025714 합창반 20038540 미술반 99570264 검도부 97456123 축구부 학생4  학생3  학생3  학생4 릴레이션 은 모두 제 1 정규형의 제약 조건 (모든 속성 의 도메인이 원자 값이 어야 함)을 만족한다.  	1
0000	릴레이션 정규화 38 단계별 정규화 (3) 제 1 정규형 (1st  Normal Form: 1NF) 1) 제 1 정규형의 제약 조건 - 모든 속성의 도메인이 원자 값을 가져야 한다.  2) 제 1 정규형의 갱신 이상의 원인 - 기본 키에 부분 함수적 종속 관계가 존재할 때 갱신 이상 현상이 발생한다.  기본 키로 식별되는 개체와는 무관한 속성이 존재한다는 의미이다. 즉  두 가지 독립적인 정보가 하나의 릴레이션에 표현된 것이다.  3) 제 1 정규형의 갱신 이상 해결 방법 - 릴레이션을 분해해서 부분 함수적 종속을 제거하여 제 2 정규형을 만든다.  	1
0000	릴레이션 정규화 39 단계별 정규화 4) 제 1 정규형의 갱신 이상 해결 예제 : 수강지도 릴레이션의 분해 • 수강지도(학번  교과목번호  지도교수  학과  성적) • 기본 키 : {학번  교과목번호} • 함수적 종속 : {학번  교과목번호}  → 성적 학번 → 지도교수 학번 → 학과 지도교수 → 학과 • FDD :  학번 과목번호 성적 학과 지도교수 릴레이션 확인 	1
0000	릴레이션 정규화 40 단계별 정규화 수강지도 학번 교과목번호 성적 학과 100 C413 A 컴퓨터 100 E412 A 컴퓨터 200 C123 B 전기 300 C312 A 컴퓨터 300 C324 C 컴퓨터 300 C413 A 컴퓨터 400 C312 A 컴퓨터 400 C324 A 컴퓨터 400 C413 B 컴퓨터 400 E412 C 컴퓨터 지도교수 P1 P1 P2 P3 P3 P3 P1 P1 P1 P1 릴레이션 확인 	1
0000	릴레이션 정규화 41 단계별 정규화 ① 제 1 정규형인 수강지도 릴레이션에 존재하는 갱신 이상 분석 ⓐ 삽입 이상 - 500번 학생의 지도교수가 P4라는 사실을 삽입하려 할 때  어떤 과목을 수강하지 않는 한 삽입하는 것이 불가능하다.  ⓑ 삭제 이상 - 200번 학생이 C123의 수강을 취소해서 이 데이터가 삭제되는 경우  지도교수가 P2라는 유용한 정보까지 삭제된다.  ⓒ 수정 이상 - 400번 학생의 지도교수를 P1에서 P3로 변경하는 경우  학번이 400인 4개 튜플의 지도교수를 모두 P3로 변경하지 않으면 데이터 불일치가 발생한다.  ② 수강지도 릴레이션에 존재하는 갱신 이상의 원인 분석 - 지도교수와 학과 속성이 기본 키인 {학번  교과목번호}에 부분 함수적 종속 관계가 존재한다.  	1
0000	릴레이션 정규화 42 단계별 정규화 ③ 릴레이션 분해 - 부분 함수적 종속이 존재하지 않도록 다음과 같이 2개의 릴레이션으로 분해한다.   지도(학번  지도교수  학과) 수강(학번(FK)  교과목번호  성적) 학번 교과목번호 성적 100 C413 A 100 E412 A 200 C123 B 300 C312 A 300 C324 C 300 C413 A 400 C312 A 400 C324 A 400 C413 B 400 E412 C 수강 학번 학과 100 컴퓨터 200 전기 300 컴퓨터 400 컴퓨터 지도교수 P1 P2 P3 P1 지도 지도와 수강 릴레이션은 각 각 제 2 정규형의 제약조건 (모든 속성이 기본 키에 완 전 함수적 종속이어야 함) 을 만족한다.  	1
0000	릴레이션 정규화 43 단계별 정규화 프로젝션(Projection)  - 릴레이션의 특정 속성만으로 구성된 새로운 릴레이션을 구하는 연산 5) 무손실 분해(Nonloss Decomposition)  - 프로젝션(Projection)으로 분해된 릴레이션들은 조인(Join)을 통해 원래의 릴레이션으로 복귀될 수 있어야 한다.  - 원래의 릴레이션에서 얻을 수 있는 정보는 분해된 릴레이션들로부터도 얻을 수 있으나   그 역은 성립하지 않는다.  예)  앞의 예에서  500번 학생의 지도교수가 P4라는 정보는 2NF으로 분해된 지도 릴레이션에는 삽입할 수 있지만  1NF인 수강지도 릴레이션에는 삽입할 수 없음 1NF 2NF 프로잭션 조인 보충 학습 	1
0000	릴레이션 정규화 44 [보충 학습] [보충 학습] 프로젝션(Projection) 연산 (1) 프로젝션 연산이란?   - 릴레이션의 특정 속성만으로 구성된 새로운 릴레이션을 구하는 연산이다.  - 즉  릴레이션의 수직적 부분 집합을 구하는 연산이다. - 관계 대수에서는 프로젝션 연산자로  기호를 사용한다.   (2) 프로젝션 연산 예제 - 학생 릴레이션에서 학번  이름  휴대폰 속성만 프로젝션 한다.  학생 릴레이션 학번 주민등록번호 이름 주소 휴대폰 지도교수 98201002 99202012 98201025 800321 811123 810923 김정욱 이기원 박문구 천안 서울 대전 010-2233-0495 010-2200-0045 010-2341-2312 01223 02355 01223  학생 (학번  이름  휴대폰) :  학번 이름 휴대폰 98201002 99202012 98201025 김정욱 이기원 박문구 010-2233-0495 010-2200-0045 010-2341-2312 학생 릴레이션에서 학번  이름   휴대폰 속성만 프로젝션 하라 는 의미 	1
0000	릴레이션 정규화 45 단계별 정규화 (4) 제 2 정규형 (2nd  Normal Form: 1NF) 1) 제 2 정규형의 제약 조건 - 모든 속성이 기본 키에 완전 함수적 종속이어야 한다.    2) 제 2 정규형의 갱신 이상의 원인 - 이행적 함수적 종속 관계가 존재할 때 갱신 이상이 발생한다. 3) 제 2 정규형의 갱신 이상 해결 방법 - 릴레이션을 분해해서 이행적 함수적 종속을 제거하여 제 3 정규형을 만든다.  	1
0000	릴레이션 정규화 46 단계별 정규화 4) 제 2 정규형의 갱신 이상 해결 예제 : 지도 릴레이션의 분해 • 지도(학번  지도교수  학과) • 기본 키 : 학번 • 함수적 종속 :   학번 → 지도교수 학번 → 학과 지도교수 → 학과 • FDD :  학번 학과 지도교수 학번 학과 100 컴퓨터 200 전기 300 컴퓨터 400 컴퓨터 지도교수 P1 P2 P3 P1 지도 릴레이션 확인 	1
0000	릴레이션 정규화 47 단계별 정규화 a) 제 2 정규형인 지도 릴레이션에 존재하는 갱신 이상 분석 ① 삽입 이상 - 지도 학생 없이는 어떤 교수가 특정 학과에 속한다는 정보를 삽입하는 것이 불가능하다.  ② 삭제 이상 - 300번 학생의 정보를 삭제하면  지도교수 P3가 컴퓨터학과에 속한다는 유용한 정보까지 삭제된다.  ③ 수정 이상 - 지도교수 P1의 소속을 컴퓨터에서 전기로 변경하는 경우  학번이 100과 400인 2개 튜플의 학과를 모두 전기로 변경하지 않으면 데이터 불일치가 발생한다.  (실제 상황이라면 100과 200의 지도교수를 변경해야 함)  b) 지도 릴레이션에 존재하는 갱신 이상의 원인 분석 - 학번  지도교수  학과라는 3개 속성 사이에 이행적 함수적 종속 관계가 존재한다.  	1
0000	릴레이션 정규화 48 단계별 정규화 c)  릴레이션 분해 - 이행적 함수적 종속이 존재하지 않도록 다음과 같이 2개의 릴레이션으로 분해한다.   학생지도(학번  지도교수) 교수소속(교수  학과) 학과 컴퓨터 전기 컴퓨터 교수 P1 P2 P3 교수소속 학생지도 학번 100 200 300 400 지도교수 P1 P2 P3 P1 학생지도와 교수소속 릴레 이션은 모두 제 3 정규형의 제약조건(속성들 간에 이행 적 함수적 종속이 없어야 함)을 만족한다.  	1
0000	릴레이션 정규화 49 단계별 정규화 5) 무손실 분해 - 원래의 릴레이션에서 얻을 수 있는 정보는 분해된 릴레이션들로부터도 얻을 수 있다. 그러나  그 역은 성립하지 않는다.  예)  지도교수 P4가 전자에 속한다는 정보는 3NF으로 분해된 교수소속 릴레이션에는 삽입할 수 있지만   2NF인 지도 릴레이션에는 삽입할 수 없음 2NF 3NF 프로잭션 조인 	1
0000	릴레이션 정규화 50 단계별 정규화 (5) 제 3 정규형 (3rd  Normal Form: 1NF) 1) 제 3 정규형의 제약 조건 - 속성들 간에 이행적 함수적 종속이 없어야 한다.  2) 제 3 정규형의 갱신 이상의 원인 - 후보 키가 아닌 결정자가 존재할 때 갱신 이상 현상이 발생한다. 3) 제 3 정규형의 갱신 이상 해결 방법 - 후보 키가 아니면서 결정자 역할을 하는 속성과 그 종속자를 분리해서  모든 결정자가 후보 키가 되는 보이스/코드 정규형(BCNF)을 만든다.  4) 3NF의 약점 ① 복수개의 후보 키를 갖고 있고  ② 후보 키들이 복합 속성들로 구성되고  ③ 후보 키들이 서로 중첩되는 경우에는  3NF로는 불충분하므로 보다 일반적인 BCNF로 변환해야 한다. 	1
0000	릴레이션 정규화 51 단계별 정규화 5) 제 3 정규형의 갱신 이상 해결 예제 : 수강과목 릴레이션의 분해 • 수강과목(학번  교과목  교수) • 제약 조건 ① 한 학생은 각 과목에 대해 오직 한 교수의 강의만 수강한다.  ② 각 교수는 한 과목만 담당한다.  ③ 같은 과목을 여러 교수가 담당할 수 있다.   • 후보 키 : {학번  교과목}   {학번  교수} • 기본 키 : {학번  교과목}  • 함수적 종속 : {학번  교과목} → 교수 교수 → 교과목 • FDD  수강과목 학번 교과목 100 프로그래밍 100 자료구조 200 프로그래밍 200 자료구조 교수 P1 P2 P1 P3 300 자료구조 300 프로그래밍 P3 P4 릴레이션 확인 	1
0000	릴레이션 정규화 52 단계별 정규화 a) 제 3 정규형인 수강과목 릴레이션에 존재하는 갱신 이상 분석 ① 삽입 이상 - 교수 P5가 자료구조 교과목을 담당한다는 정보의 삽입은 학번(수강 학생)이 없으면 불가능하다.  ② 삭제 이상 - 100번 학생이 자료구조를 취소해서 데이터를 삭제하면  P2가 담당교수라는 유용한 정보 까지 삭제된다.  ③ 수정 이상 - 지도교수 P1이 프로그래밍 과목 대신 자료구조를 담당하게 되면  P1이 포함된 모든 튜플 을 변경하지 않으면 데이터 불일치가 발생한다.  b) 수강과목 릴레이션에 존재하는 갱신 이상의 원인 분석 - 교수 속성이 후보 키가 아닌데 결정자 역할을 한다.  	1
0000	릴레이션 정규화 53 단계별 정규화 c)  릴레이션 분해 (ㄱ)  후보 키가 아니면서 결정자 역할을 하는 ‘교수’ 속성과 그 결정자에 함수적으로 종속하는 속성인 ‘교과목’을 별도의 릴레이션(교수과목)으로 분해하고  결정자인 교수 속성을 기본 키로 정의한다. (ㄴ) 기존 릴레이션에 결정자(교수 속성)를 남겨서 기본 키의 구성 요소가 되도록 하고  이 결정자가 새로운 릴레이션(교수과목)에 대한 외래 키 역할도 하도록 한다. 교수과목(교수  교과목)                 ------ (ㄱ)  수강교수(학번  교수(FK)) ------ (ㄴ)  수강교수 학번 100 100 200 200 교수 P1 P2 P1 P3 300 300 P3 P4 교과목 프로그래밍 자료구조 자료구조 프로그래밍 교수 P1 P2 P3 P4 교수과목 교수과목과 수강교수 릴레이션 은 모두 BCNF의 제약조건(후 보 키가 아닌 결정자가 없어야 함)을 만족한다.  	1
0000	릴레이션 정규화 54 단계별 정규화 (6) 보이스/코드 정규형 (Boy ce/Codd Normal Form: BCNF) 1) BCNF의 제약 조건 - 후보 키가 아닌 결정자가 없어야 한다.  2) BCNF가 고안된 이유 - 기본 키가 둘 이상의 속성으로 구성된 복합 키이고  복합 키가 둘 이상 존재할 경우에 발생되는 갱신 이상 현상을 방지하기 위해서 고안되었다.  3) BCNF의 특징 - 하나의 후보 키만 가진 릴레이션이 3NF이면 동시에 BCNF도 만족하며  이를 강한 3NF(Strong 3NF)이라고도 칭한다.   	1
0000	릴레이션 정규화 55 역정규화 (1) 정규화의 문제점 - 정규화 단계가 진행될수록 릴레이션이 분해되므로 원하는 정보를 얻기 위해서 조인의 필요성이 증가되어 성능이 저하될 수 있다.  - 즉  불필요한 데이터의 중복은 감소하지만 질의에 대한 응답 시간은 증가할 수 있다.  불필요한 데이터의 중복 감소 응답 시간 증가 (성능 저하) 릴레이션 분해 4. 역정규화 	1
0000	릴레이션 정규화 56 역정규화 (2) 역정규화(Denormalization)란?  - 성능에 대한 요구를 만족시키기 위해 데이터 중복과 갱신 이상을 대가로 치르면서 보다 낮은 정규형으로 되돌아가는 것을 의미한다. - 즉  빈번하게 수행되는 검색 질의의 수행 속도를 높이기 위해서 이미 분해된 두 개 이상의 릴레이션을 합쳐서 하나의 릴레이션으로 만드는 작업이다.  - 예:   역정규화 해도 중복된 데이터는 관리해야 하므로  응용 프로그램에서 별도로 데이터 무결성을 보장하기 위한 비용이 발생될 수 있음 	1
0000	릴레이션 정규화 57 쉼터 쉼터 저작권 검토!!  	1
0000	데이터베이스 데이터베이스 - Story Board - 14 회차 : 논리적 설계 단계 심화 집필교수 : 김 은 경 교수설계 : 이 러 닝 	1
0000	논리적 설계 단계 심화 2 Lesson.   개체 통합과 이력 및 코드 데이터 모델링 1. 개체 타입 통합 2. 이력 데이터 모델링 3. 코드 데이터 모델링 갱신 이상과 함수적 종속 	1
0000	논리적 설계 단계 심화 3 개체 통합 1. 개체 타입 통합 (1) 개체 타입 통합의 장단점 1) 장점 ① 종합적으로 정보를 조회하기 용이하다. ② 불필요한 조인이 제거되어 성능이 향상된다. ③ 비슷한 속성이 통합되므로 중복이 제거된다.  ④ ERD가 간결해진다.  ⑤ 물리적으로 관리해야 하는 테이블 수가 감소한다.   2) 단점 ① 업무 확장에 따른 데이터 모델의 변경이 유연하지 않다. ② 데이터 모델만으로 업무 흐름을 파악하기 어렵다. ③ 많은 양의 데이터가 한군데 집약되므로 성능이 저하될 수 있다.  ④ SQL문에서 체크해야 할 조건이 증가한다.  	1
0000	논리적 설계 단계 심화 4 개체 통합 (2) 개체 타입 통합 원칙 ① 논리적 설계 단계에서 가능한 모든 개체를 상세하게 표현한다.  ② 물리적 설계 단계에서는 가능한 개체 통합을 유도해서 표현한다.   ③ 트랜잭션이 통합해서 발생하는지 분리해서 발생하는지 사전에 조사한다.  ④ 데이터와 트랜잭션 양이 많지 않은 경우 개체 통합을 유도한다.  ⑤ 데이터와 트랜잭션 양이 많은 경우 트랜잭션의 유형에 따라 개체 통합을 결정한다.  	1
0000	논리적 설계 단계 심화 5 개체 통합 (3) 개체 타입 통합 사례 1) 동일한 기본 키를 갖는 개체 타입의 통합 - 통합된 개체는 이전 개체의 모든 속성을 포함한다.  - 예: 부동산소유자와 부동산전세자 개체 타입을 통합해서 부동산관계자 개체 타입을 만든다. 부동산소유자(주민등록번호  소유자명  주소  연락처) 부동산전세자(주민등록번호  전세자명  주소  연락처) 통합 부동산관계자(주민등록번호  관계자구분  소유자명  주소  연락처) 소유자인지 전세 자인지 구분하기 위한 속성 추가 	1
0000	논리적 설계 단계 심화 6 개체 통합 2) 기본 키가 상호 식별자가 될 수 있는 개체 타입의 통합 - 기본 키가 비슷한 개체를 통합하고  통합된 개체는 이전 개체의 모든 속성을 포함한다. - 예: 할인대상고객과 특별고객 개체 타입을 고객 개체 타입에 통합시킨다.  할인대상고객(주민등록번호  고객번호  이름  주소  마일리지) 특별고객(주민등록번호  이름  주소  등급  등록일자) 고객(고객번호   주민등록번호(AK)  이름  주소  연락처  등록일자  할인마일리지  특별고객등급) 대체 키 (Alternative Key) 고객(고객번호   주민등록번호  이름  주소  연락처  등록일자) 통합 	1
0000	논리적 설계 단계 심화 7 개체 통합 작업요청과 작업완료 개체 타입은 순환 관계로 통합할 수도 있고  업무에 따라서는 원래대로 분리할 수도 있습니다.  3) 기본 키나 도메인  속성이 비슷한 개체 타입의 통합 - 예: 작업요청과 작업완료 개체 타입을 통합해서 작업관리 개체 타입 생성 작업요청(작업요청번호  요청내용  요청일자  작업장소) 작업완료(작업완료번호  완료내용  완료일자  작업장소   담당자) 통합 작업관리(작업번호  내용  일자  장소  담당자  관련작업번호(FK)) 2개의 개체 타입 을 순환관계로 통합한 것임 [작업관리 개체의 순환관계]  1 N 작업관리 작업번호 내용 일자 장소 관리한다 담당자 	1
0000	논리적 설계 단계 심화 8 이력 데이터 모델링 2. 이력 데이터 모델링 (1) 이력 데이터(History Data)란?   - 하나의 업무 단위가 시간의 흐름에 따라 반복적으로 발생한 과거 및 현재 데이터를 의미한다.   (2)  이력 데이터 모델링 대상 ① 업무적인 활동 - 예: 주문  입고  발주  접수  예약 등 ② 이력과 간접적인 관계에 있는 대상들 - 예: 고객  상품  고객 등 ③ 최신 정보 - 예 : 최신 예약  최신 환율 등 	1
0000	논리적 설계 단계 심화 9 이력 데이터 모델링 (3) 이력 데이터 모델링의 장점 ① 과거 특정 시점의 데이터를 조회할 수 있다.  ② 변경 내역을 관리할 수 있다.  ③ 오류 발생 시 현재 정보를 가장 최근 이력 정보로 복구할 수 있다.  (4) 이력 데이터 모델링 대상 선정 시 고려사항 ① 시간이 경과함에 따라 데이터가 변할 수 있나?  ② 시간이 경과함에 따라 관계가 변할 수 있나?  ③ 과거 데이터를 조회할 필요가 있나?  ④ 변경 내역을 감사할 필요가 있나?  ⑤ 과거 버전을 보관할 필요가 있나?  이력 관리는 비용이 발생하므로 이력을 관 리할 필요가 없는 데이터까지 관리하는 것은 낭비이다.  	1
0000	논리적 설계 단계 심화 10 이력 데이터 모델링 (5) 이력 데이터 발생의 3가지 유형 1) 변경 이력 - 데이터가 변경될 때마다 변경 전후의 차이를 확인해야 하는 경우  약한 개체로 변경 이력을 저장 한다. 예) 주문 변경  계약 변경  예약 변경 등 - 예제:  온라인 쇼핑몰에서 고객이 주문한 다음 주문 정보를 변경하는 경우  이전 주문과 변경된 주문 정보를 관리할 필요가 있을 때 변경된 주문 이력 정보를 저장한다.    주문 주문번호 고객번호 접수일자 1 N 주문변경 변경 하다 주문수량 담당부서 담당자 변경일자 변경자 주문수량 변경사유 수수료 	1
0000	논리적 설계 단계 심화 11 이력 데이터 모델링 2) 발생 이력 - 데이터가 발생할 때마다 이력 정보를 남겨야 하는 경우  약한 개체로 발생 이력을 저장한다.  예) 요금청구  이자계산  급여계산 등 - 예제: 사원의 매월 급여 정보를 남겨야 하는 경우  매월 급여를 지급할 때마다 급여 데이터를 저장한다.  사원 사원번호 이름 입사일자 1 N 급여 수령 히다 담당업무 휴대폰 주소 급여일자 기본급 상여금 세금 의료보험료 국민연금 실수령액 	1
0000	논리적 설계 단계 심화 12 이력 데이터 모델링 3) 진행 이력 - 업무가 진행되는 상황을 남겨야 하는 경우 언제  누가  어떤 업무를 했는지   약한 개체로 진행 이력을 저장한다.  예) 접수 진행  예약 진행  공사 진행 등 - 반드시 현재 단계의 진행 정보도 기록한다.    - 예제: 다음과 같은 단계로 공사 업무가 진행되는 경우  각 단계별로 누가  언제 처리했는지   또 현재 어떤 단계인지를 기록한다.   [공사 단계: 공사 착수 -> 기반 공사 -> 골조 작업 -> 실내 작업 -> 외장 공사]  공사 공사번호 공사명 공사개요 1 N 공사진행 진행 하다 착공일자 완공일자 공사장소 진행상태코드 진행감독자명 진행상태시작일자 진행상태종료일자 	1
0000	논리적 설계 단계 심화 13 이력 데이터 모델링 (6) 이력 개체의 특징 ① 이력 개체는 하나의 개체에서 발생하는 이력을 관리하기 위해서 발생하는 개체로  과거의 특정 시점에 대한 정보를 제공하는 것을 목적으로 한다.  ② 이력 개체(약한 개체)의 기본 키는 부분 키에 소유 개체의 기본 키를 결합해서 지정하고  필요하면 날짜나 일련번호를 기본 키에 추가한다.  ③ 소유 개체의 기본 키는 이력 개체의 외래 키가 된다.  ④ 이력 개체에 필요한 대부분의 속성은 소유 개체에 존재한다.  	1
0000	논리적 설계 단계 심화 14 이력 데이터 모델링 (7) 이력 데이터 모델링의 형태 1) 시점 이력 - 데이터 변경이 발생한 시점만 관리한다.     예) 특정 통화의 환율이 변경되면 그 시점과 환율을 저장해서 환율이 어느 시점에 얼마로 변동되었는지 저장한다. - 가장 최근의 정보를 추출하기 위해서 MAX 함수를 사용해야 하는 번거로움이 있다.    예) 미국달러의 가장 최근 환율을 검색한다.  통화 통화ID 국가 1 N 환율변동이력 변동 하다 변동시각 환율 SELECT  환율 FROM     환율변동이력 WHERE   변동시각 = (SELECT  MAX(변동시각) FROM     환율변동이력 WHERE   통화ID = ‘USD’);   	1
0000	논리적 설계 단계 심화 15 이력 데이터 모델링 2) 선분 이력 - 데이터 변경이 발생한 시작 시점부터 종료 시점까지 전체 시간을 관리한다. 예) 각 통화의 특정 기간 동안 유효한 환율을 관리한다.  통화 통화ID 국가 1 N 환율변동이력 변동 하다 시작시간 종료시간 환율 예) 특정 기간(2012년 6월 1일부터 12월 31일까지) 동안의 미국달러의 환율을 검색한다.  SELECT  시작시간  종료시간  환율 FROM     환율변동이력 WHERE   시작시간 >=  ‘12/06/01’  AND       종료시각 <= ‘12/12/31’ AND       통화ID = ‘USD’ ;   	1
0000	논리적 설계 단계 심화 16 이력 데이터 모델링 (8) 이력 데이터 모델링 시 주의사항 - 최신 데이터를 조회할 수 있도록 변경 이력에 ‘최신 여부 속성’을 추가한다.  1) 최신 여부 속성이 없는 경우의 변경 이력 데이터 조회 - 예) 다음 주문변경 릴레이션에서 사업부코드 ‘100’인 사업부에서 가장 최근에 변경된 주문번호와 주문수량을 검색하는 SQL문 주문변경(주문번호  변경일자  변경자  주문수량  변경사유  수수료  사업부코드) SELECT  주문변경1.주문번호   주문변경1.주문수량 FROM     주문변경 주문변경1   (SELECT  주문번호   MAX(변경일자)  변경일자 FROM    주문변경 WHERE   사업자코드 = ‘100’ GROUP  BY  주문번호)  주문변경2 WHERE      주문변경1.주문번호 = 주문변경2.주문번호 AND           주문변경1.변경일자 = 주문변경2.변경일자;  	1
0000	논리적 설계 단계 심화 17 이력 데이터 모델링 2) 최신 여부 속성이 있는 경우의 변경 이력 데이터 조회 - 예) 다음 주문변경 릴레이션에서 사업부코드 ‘100’인 사업부에서 가장 최근에 변경된 주문번호와 주문수량을 검색하는 SQL문 주문변경(주문번호  변경일자  변경자  주문수량  변경사유  수수료  사업부코드  최신여부) SELECT  주문번호   주문수량 FROM     주문변경 WHERE   사업자코드 = ‘100’ AND       최신여부 = ‘Y;  	1
0000	논리적 설계 단계 심화 18 이력 데이터 모델링 (9) 이력 데이터 모델링 시 고려사항 ① 현재 상황뿐만 아니라 미래의 발생 가능한 상황도 고려한다.  예)   a) 현재: 사원이 현재 근무하고 있는 부서 정보만 관리한다. 사원 사원번호 이름 입사일자 N 1 부서 근무 하다 담당업무 휴대폰 주소 부서코드 부서명 전화번호 사무실 부서장 	1
0000	논리적 설계 단계 심화 19 이력 데이터 모델링 b) 미래: 사원의 발령 이력(근무한 적이 있는 모든 부서 포함)을 모두 관리한다.  ② 이력 관리를 위해 약한 개체의 추가 또는 기본 키의 변경 여부 ③ 데이터의 발생 형태 ④ 이력 데이터 모델링의 주기 ⑤ 이력 데이터 모델링의 수위 조절 (어떤 수준까지 이력 관리할 것인가) 사원 사원번호 이름 입사일자 N 1 부서 근무 하다 담당업무 휴대폰 주소 부서코드 부서명 전화번호 사무실 부서장 발령이력 현재근무여부 발령일 갖고 있다 1 N 부서코드 	1
0000	논리적 설계 단계 심화 20 코드 데이터 모델링 3. 코드 데이터 모델링 (1) 코드(Code)란?   - 업무에서 또는 정보시스템에서 쉽게 구분할 수 있도록 데이터들을 간단하게 구분해 놓은 단위이다. (2)  코드 구분 ① 코드에 한 개의 값(속성)이 반복적으로 나타나는 경우 예) 코드명이라는 한 개의 속성을 갖는 지불방법코드 - 현금 결재  선불카드 결재  …  계좌 이체 가운데 한 개의 값만 나타남 코드 구분 코드 구분명 코드 값 코드명(의미) CD001 지불방법코드 1 현금 결재 2 선불카드 결재 3 신용카드 결재 4 휴대폰 결재 5 계좌 이체 	1
0000	논리적 설계 단계 심화 21 코드 데이터 모델링 ② 코드에 여러 개의 값(속성)이 반복적으로 나타나는 경우 - 예) 부서명 외에 위치와 부서장이라는 3개의 속성을 갖는 부서 코드 코드 구분 코드 구분명 코드 값 속성(의미) 부서명 위치 부서장 CD002 부서코드 1 기획팀 서울 김철수 2 인사팀 서울 이영희 3 영업팀 서울 박문수 4 기술팀 대전 최영민 5 AS팀 천안 장민수 	1
0000	논리적 설계 단계 심화 22 코드 데이터 모델링 코드 값 모델링을 하지 않은 초기 모델은 새로운 종류의 코드를 추가하려면 새로운 개체를 생성해야 하므로 코드 추가가 쉽지 않다.  (3) 코드 데이터 모델링 사례 1) 한 개의 값(속성)이 반복적으로 나타나는 코드가 여러 개 존재하는 경우의 모델링 - 코드구분(소유 개체)과 상세코드(약한 개체)라는 2개의 통합코드 개체를 생성해서 코드 구분을 간소화한다.  - 예: 한 개의 값을 반복하는 코드가 3개(접수구분 코드  접수방법 코드  신청자구분 코드) 있는 경우의 모델링 ① 코드 데이터 모델링 전 초기 ER 모델 접수 N 접수 하다 접수번호 접수자명 접수방법 코드 접수일자 신청자명 접수구분 코드 심청자구분 코드 접수구분 코드 코드명 접수방법 코드 코드명 신청자구분 코드 코드명 구분 하다 신청자 구분하다 N N 1 1 1 [코드 테이블]  코드 개체명 코드 값 코드 코드명 접수구분 1 일반 2 긴급 3 특별 접수방법 1 방문접수 2 전화접수 3 인터넷접수 신청자구분 1 일반인 2 법인 	1
0000	논리적 설계 단계 심화 23 코드 데이터 모델링 반면에 코드 데이터 모델링을 통해서 세 종류의 코드 관련 개체를 코드구분과 세부코드라는 두 개의 개체로 표현하면  새로운 종류의 코드 를 추가할 때 새로운 개체를 생성하는 대신  새로운 개체 인스턴스를 추가하면 되기 때문에  새로운 코드 추가가 훨씬 용이합니다.  ② 코드 데이터 모델링 코드 구분 코드 코드명 CD001 1 일반 2 긴급 3 특별 CD002 1 방문접수 2 전화접수 3 인터넷접수 CD003 1 일반인 2 법인 접수구분 코드 코드명 접수방법 코드 코드명 신청자구분 코드 코드명 통합개체 생성 코드 구분 코드 구분명 CD001 접수구분 CD002 접수방법 CD003 신청자구분 [코드구분 테이블]  [상세코드 테이블]  코드구분 코드구분 코드구분명 상세코드 코드 코드명 세분 하다 N 1 	1
0000	논리적 설계 단계 심화 24 코드 데이터 모델링  코드 데이터 모델링 후 ER 모델 접수 접수번호 접수자명 접수방법 코드 접수일자 신청자명 접수구분 코드 신청자구분 코드 M N 코드구분 코드구분 코드구분명 상세코드 코드 코드명 세분 하다 N 1 구분 하다 	1
0000	논리적 설계 단계 심화 25 코드 데이터 모델링 2) 여러 개의 값(속성)이 반복적으로 나타나는 코드의 모델링 방법 - 별도의 통합코드 개체를 생성하지 않고 일반적인 개체와 동일하게 모델링 한다. - 예: 부서명과 위치  부서장이라는 속성을 갖는 부서코드를 일반적인 부서 개체 모델링 부서 접수 접수 하다 M 1 N 부서코드 부서명 위치 부서장 접수번호 접수자명 접수일자 신청자명 	1
0000	논리적 설계 단계 심화 26 코드 데이터 모델링 (4) 코드값 변환 시 주의사항 ① 코드를 코드 값으로 변환(예: 코드 ‘1’을 코드 값 ‘방문접수’로 변환)할 때 조인을 통해서 변환하 는 경우  SQL문이 복잡해지고 성능도 저하된다.  ② SQL문에서 DECODE를 사용해서 코드와 코드 값을 매핑하는 경우  코드가 변경되거나 추가될 때마다 SQL 문을 수정해야 한다.  ③ 응용 프로그램에서 코드 값을 변환하는 경우  코드가 변경될 때마다 응용 프로그램을 수정해서 다시 컴파일해야 한다.  ④ 코드 값을 변환하는 가장 효율적인 방법은 DBMS의 함수(FUNCTION)를 사용해서 변환하는 것 이다.  	1
0000	논리적 설계 단계 심화 27 Lesson.  데이터 무결성과 표준화 1. 데이터 무결성 2. 개체 무결성 3. 참조 무결성 4. 데이터 표준화 단계별 정규화와 역정규화 	1
0000	논리적 설계 단계 심화 28 개체 무결성 1. 데이터 무결성 (1) 데이터 무결성(Data Integrity)이란?  - DB에 저장된 데이터의 정확성과 일관성을 유지하기 위해서 데이터가 항상 만족해야 하는 제약조건을 의미한다.   (2) 데이터 무결성의 필요성 - 데이터들 간의 정확성  유효성  일관성  신뢰성을 위해서 무분별한 데이터 갱신으로부터 데이터를 보호할 수 있다.   데이터 무결성이 보장된 시스템 데이터의 신뢰성 유지 생산성 향상 데이터의 효율적 유지 유지보수 용이 	1
0000	논리적 설계 단계 심화 29 개체 무결성 (3) 데이터 무결성의 종류 구분 특징 개체 무결성 (Entity Integrity) 기본 키를 구성하는 속성은 반드시 값을 가져야 하고  유일성을 보장하는 최소한의 집합이어야 한다는 제약조건 참조 무결성 (Referential Integrity) 외래 키는 반드시 피참조 릴레이션의 기본 키 값이나 널 값을 가 져야 한다는 제약조건 도메인 무결성 (Domain Integrity) 속성의 데이터 타입  길이  디폴트 값  널(Null) 값 허용 여부  허 용되는 값의 범위 등에 대한 제약조건 	1
0000	논리적 설계 단계 심화 30 개체 무결성 개체 무결성은 기본 키를 정의하면 묵시적으로 정의되지만  기본 키가 잘못 정의되면 개체 무결성이 보장되지 않습니다. 따라서 기본 키를 제대로 정의하는 방법에 대해 정확히 학습하도록 하세요.  2. 개체 무결성 (1) 개체 무결성 규칙 ① 규칙 1 : 기본 키를 구성하는 속성은 널 값을 가져서는 안 된다. ② 규칙 2 : 기본 키는 개체를 유일하게 식별할 수 있어야 한다.  ③ 규칙 3 : 기본 키는 유일성을 보장하는 최소한의 집합이어야 한다.  (2) 기본 키 선정 사례 규칙 1 (Not NULL) 규칙 2 (유일성) 규칙 3 (최소성) 학번 O O O 주민등록번호 O O O {이름  생년월일} O X O {학번  이름} O O X {학번  전공코드} X O X 1학년은 전공이 결정되지 않아 전 공코드는 널 값을 갖는다.  이름과 생년월일 이 같은 사람이 여러 명 있을 수 있다.  이름 없이 학번만 으로 유일한 식별 이 가능하다.  후보키 	1
0000	논리적 설계 단계 심화 31 참조 무결성 (3)  기본 키 선정 시 고려사항 ① 기본 키는 개체 인스턴스(Instance)를 유일하게 식별할 수 있어야 한다. ② 기본 키는 가능한 변경되지 않아야 한다. ③ 데이터 보안이 요구되지 않아야 한다. - 주민등록번호는 개인 정보보호 관점에서 보안이 요구되므로 기본 키로 사용하지 않는 것이 좋다. ④ 기본 키는 반드시 최소성을 만족해야 한다.  - 복합 속성이 기본 키가 될 수 있지만  하나의 속성으로 유일성을 보장하는 속성이 있다면 단일 속성을 기본 키로 선정한다.  ⑤ 후보 키 가운데 보다 적은 저장공간을 차지하는 속성을 선택한다.  - 기본 키에 대한 인덱스도 자동 생성되므로 저장공간이 적은 속성을 선택하는 것이 좋다.  ⑥ 후보 키 가운데 업무 활용도가 높고  업무상 의미 있는 속성을 선택한다. - 여러 개체에서 사용되는 후보 키보다  개체의 특성을 나타내는 속성을 선택한다.   ⑦ 기존 업무에서 의미 있게 사용하던 후보 키가 있으면 그대로 유지한다.  - 동일한 업무에 새로운 기본 키를 설정하면 업무에 혼란을 초래할 수 있으므로 가능한 동일한 기본 키를 선정한다.  	1
0000	논리적 설계 단계 심화 32 참조 무결성 참조 무결성은 외래 키를 정의하면 묵시적으로 정의되지만  참조 무결성에는 DB(디비) 설계자가 고려해야 할 보다 세부적인 업무 규칙이 있는데  어떤 세부적인 규칙이 있는지 확인해 보세요.  3. 참조 무결성 (1) 참조 무결성이란?   - 외래 키(Foreign Key)는 반드시 피참조 릴레이션에 존재하고 있는 기본 키와 연결되거나 널 값을 가져야 한다는 제약조건이다.  (2) 참조 무결성의 업무 규칙 구분 적용 시점 세부 업무 규칙 입력 규칙 자식 인스턴스가 입력되거나 외래 키가 수정될 때 - 의존(Dependent)     - 지정(Customized) - 자동(Automatic)      - NULL - 기본(Default)          - 미지정 삭제 규칙 부모 인스턴스가 삭제될 때 - 제한(Restrict) - 연쇄(Cascade) 수정 규칙 부모 인스턴스의 관계에 대응 하는 속성이 수정될 때 - 제한(Restrict) - 지정(Customized) - 연쇄(Cascade) - NULL - 기본(Default)          - 미지정 	1
0000	논리적 설계 단계 심화 33 참조 무결성 (3) 입력 참조 무결성의 세부 업무 규칙 구분 세부 내용 의존 (Dependent)  자식 테이블에 데이터를 입력할 때 참조하고 있는 부모 테이블에 기본 키가 존재할 때만 데이터 입력이 가능하다. 자동 (Automatic)  자식 테이블에 데이터를 입력할 때 참조하고 있는 부모 테이블의 기본 키가 존재하지 않으면  기본 키를 생성하고 자식 테이블에 데이터를 입 력한다.  기본 (Default)  자식 테이블에 데이터를 입력할 때 참조하고 있는 부모 테이블의 기본 키의 값을 기본(디폴트) 값으로 바꾼 후 자식 테이블에 입력한다.  지정 (Customized) 사용자가 지정한 일정한 조건을 만족하는 경우에만 자식 테이블에 데이 터를 입력할 수 있다.  NULL 자식 테이블에 데이터를 입력할 때 참조하고 있는 부모 테이블의 기본 키가 없어도 입력할 수 있고  외래 키 값은 널이 된다.  미지정 자식 테이블에 데이터를 입력할 때 조건 없이 허용한다.  	1
0000	논리적 설계 단계 심화 34 참조 무결성 (4) 삭제 및 수정 참조 무결성의 세부 업무 규칙 구분 세부 내용 제한 (Restrict) 대응하는 자식 인스턴스가 없는 경우에만 부모 인스턴스의 삭제 및 수 정이 가능하다.  연쇄 (Cascade) 부모 인스턴스의 삭제 및 수정을 항상 허용하며  동시에 대응하는 자식 인스턴스도 모두 자동으로 삭제 및 수정한다.  기본 (Default)  부모 인스턴스의 삭제 및 수정을 항상 허용하며  동시에 대응하는 자식 인스턴스의 외래 키를 기본(디폴트) 값으로 수정한다.  지정 (Customized) 특정한 검증 조건을 만족하는 경우에만 부모 인스턴스의 삭제 및 수정 을 허용한다.  NULL 부모 인스턴스의 삭제 및 수정을 항상 허용하며  동시에 대응하는 자식 인스턴스의 외래 키를 널 값으로 수정한다.  미지정 부모 인스턴스의 삭제 및 수정을 조건 없이 허용한다.  	1
0000	논리적 설계 단계 심화 35 참조 무결성 (5) 참조 무결성 정의 사례 부모 개체 관계 자식 개체 입력 규칙 삭제 규칙 수정 규칙 유형 제약 프로젝트 1: 1 부분 참여 계약금 Dependent Restrict Cascade 프로젝트 1: N 부분 참여 보고서 Dependent Cascade Cascade . . .  	1
0000	논리적 설계 단계 심화 36 데이터 표준화 4. 데이터 표준화 (1) 데이터 표준화란?  - 시스템 별로 산재되어 있는 데이터의 명칭  정의  규칙  형식 등에 대한 원칙을 수립해서 전사적으로 적용하는 것을 의미한다.  (2) 데이터 표준화의 필요성 - 데이터가 기업의 전략적 의사소통의 핵심 요소이므로 데이터의 품질을 확보하기 위해서 데이터 표준화가 필수적이다.  전사적인 데이터 표준화 1) 정확한 데이터 사용 2) 원활한 의사소통 3) 올바른 의사결정 기업 경쟁력 확보 	1
0000	논리적 설계 단계 심화 37 데이터 표준화 (3) 데이터 비표준화의 문제점 - 현실적으로 데이터 표준화가 어려운 여러 가지 이유가 있는데  그로 인해 데이터를 표준화하지 않으면 추후 훨씬 더 심각한 문제를 유발할 수 있다.  데이터 표준화가 어려운 이유 데이터 비표준화의 문제점 1) 여러 정보시스템을 동시에 개발 2) 전사적인 데이터 관리에 대한 마인드 부족 3) 전사적인 데이터 관리 인력 부재 4) 전사적인 데이터 표준 관리 도구 부재 1) 데이터의 중복 및 불일치 발생 2) 데이터에 대한 의미 파악이 어려워 정보 제공의 적시성 결여 3) 데이터 통합의 어려움 4) 정보시스템 유지보수의 비효율성 	1
0000	논리적 설계 단계 심화 38 데이터 표준화 (4) 데이터 표준화 대상 ① 표준 단어 ② 표준 용어 ③ 표준 도메인 ④ 표준 코드 (5) 데이터 표준화의 기대효과 ① 명칭의 통일로 인한 원활한 의사소통 가능 ② 일관된 데이터 형식과 규칙의 적용으로 인한 데이터 품질 향상 ③ 필요한 데이터의 소재 파악에 소요되는 시간과 노력 감소 ④ 정보시스템이 상호 인터페이스 할 때 데이터 변환 및 정제 비용 감소 	1
0000	논리적 설계 단계 심화 39 데이터 표준화 메타 데이터(Meta data) - 데이 터에 대한 데이터 (6) 데이터 표준화 단계 - 메타데이터(Meta data)를 수집한 다음  단계별로 메타데이터를 표준화한다.  메타데이터 수집 정보시스템들의 데이터 요소 수집 정보 시스템 A 서비스코드 서비스유형코드 서비스구분 서비스이름 서비스일 정보 시스템 B 서비스유형 서비스명 정보 시스템 C 서비스유형코드 서비스명칭 서비스일자 유일한 요소 추출 서비스코드 서비스유형코드 서비스구분 서비스이름 서비스일 서비스명 서비스명칭 서비스일자 표준 단어 서비스 유형 코드 구분 이름 일자 명 명칭 일 표준 용어 서비스유형코드 서비스명 서비스일자 표준 도메인 서비스유형코드 명 일자 표준 코드 1: 신규 2: 하자 3: A/S 4: … : 비표준 단어 메타데이터 표준화 	1
0000	논리적 설계 단계 심화 40 데이터 표준화 (7) 데이터 표준화 지침 수립 - 데이터 표준화를 정의하기 전에 전사적으로 지켜야 하는 지침을 미리 정해야 한다.  1) 공통 지침 사례 ① 업무에서 사용되고 있는 관용화된 용어를 우선해서 사용한다.  ② 물리적 설계 단계에서 영문명으로 전환할 때 문법에 맞는 영어 단어를 사용한다.  ③ 한글명이나 영문명을 부여할 때 특수문자나 띄어쓰기는 사용하지 않는다.  ④ 하나의 한글명에 대해서 하나의 영문명만 사용한다. (동음이의어 사용 불가)  ⑤ 하나의 영문명에 대해서는 하나 이상의 한글명을 허용한다.  (이음동의어 허용)   	1
0000	논리적 설계 단계 심화 41 데이터 표준화 파스칼 명명 규칙 – 첫 번째 문자 와 그 뒤에 이어지는 단어들의 첫 문자를 모두 대문자로 표시 하는 방법 예) OfficePhone 3) 표준 도메인 지침 사례 ① 도메인은 우선 논리적인 데이터 형식인 문자  숫자  날짜 등으로 구분해서 정의한다.  ② 이후 논리적 데이터 형식을 가능한 최소의 물리적 데이터 타입을 사용해서 저장공간이 최소화되도록 정의한다. ③ 도메인이 범위에 따라 두 개 이상의 데이터 타입으로 구분되는 경우  ‘도메인명(데이터타입)’ 형태의 이름으로 도메인을 분리한다.  2) 표준 용어 지침 사례 ① 수식어를 활용해서 용어의 의미가 명확하도록 한다.  ② 용어의 길이가 너무 길지 않게 하고  너무 긴 경우 약어를 사용한다.  ③ 논리적 모델에서는 한글명  물리적 모델에서는 영문명을 사용한다.    ④ 영문명을 사용할 때는 파스칼 명명 규칙을 사용한다.    ⑤ 단일 식별자 속성인 경우에는 ‘ID’라는 접미어를 사용한다.  ⑥ 이력 개체인 경우에는 ‘이력’이라는 접미어를 사용한다.  ⑦ ‘이름’을 다른 단어와 조합될 때는 ‘명’이라는 접미어를 사용한다.  ⑧ 날짜만 의미할 때는 ‘일자’라는 접미어를  시간까지 의미할 때는 ‘일시’라는 접미어를 사용한다. 	1
0000	논리적 설계 단계 심화 42 데이터 표준화 4) 표준 코드 지침 사례 ① 코드는 가능한 최소의 숫자 데이터 형식을 사용해서 저장공간이 최소화되도록 한다.  ② 코드 속성은 의미를 분명히 하기 위해 구분  유형  상태  여부 등의 접미어를 사용한다.  ③ 코드 사용의 의미를 분명히 하기 위해 동일한 코드라도 수식어를 사용해서 코드 속성명을 다르게 정의할 수 있다.     ④ 도메인의 값의 범위가 명확한 경우   별도로 코드화해서 관리하지 않는다.  예)  ‘이원코드 도메인’의 경우  남녀  찬반 등에 대해 1  2라는 값만 가질 수 있으므로 별도로 코드를 정의하지 않는다.  ⑤ 코드는 전체 DB 설계에서 유일하게 정의되어야 한다.  	1
0000	논리적 설계 단계 심화 43 데이터 표준화 (8) 데이터 표준화 방법 1) 공통 지침 정의 방법 ① 현재 사용 중인 모든 용어를 수집하고  필요한 경우 추가 용어를 정의한다.   ② 수집 및 정의된 용어들을 기본 단어로 분할한다.       ③ 기본 단어들을 정제한다.  - 정제 대상: 중복 단어  동음이의어  이음동의어 등  ④ 데이터 표준화 지침을 참고해서 ‘표준 단어 사전’을 작성한다.  예) 대학 관련 표준 단어 정의 표준 단어 영문약어명 영문전체명 설명 대학교 UNIV University 2~4년제 대학교 주소 ADDR Address 집 주소 . . .  	1
0000	논리적 설계 단계 심화 44 데이터 표준화 2) 표준 용어 정의 방법 ① 업무에서 사용하는 용어를 선택해서 업무 용어를 정의하고  유사 용어는 표준 용어로 대체한다.   ② 표준 단어를 이용해서 표준 용어를 구성하고  표준 도메인과 표준 코드를 기준으로 데이터 타입과 길이를 결정해서 표준 용어를 정의한다.   ③ 데이터 표준화 지침을 참고해서 ‘표준 용어 사전’을 작성한다.  예) 대학 관련 표준 용어 정의 용어 영문명 데이터타입 길이 표준 도메인 표준 코드 대학 UNIV CHAR 3 코드 대학코드 등록일자 REG_DATE CHAR 8 일자 - . . . 	1
0000	논리적 설계 단계 심화 45 데이터 표준화 DB(디비)를 설계할 때 도메인을 정의하지 않는 경우가 많은데  그렇게 되면 같은 속성임에도 불구하고 데이터 타입이나 길이가 달라서 데 이터의 일관성 유지가 어렵게 되는 경우가 발생하게 됩니다. 따라서 DB 설계 단계에서 속성들의 데이터 타입과 크기를 반드시 도메인으로 정의해서 사용할 것을 권장합니다. 도메인을 정의하는 방법에 대해서는 뒤에서 좀더 자세히 소개하도록 하겠습니다.  3) 표준 도메인 정의 방법 ① 현재 사용 중인 용어에서 유사한 속성의 용어를 그룹핑한다.   ② 그룹핑된 유사 속성에 대해 표준 도메인을 정의한다.   ③ 데이터 표준화 지침을 참고해서 ‘표준 도메인 정의서’을 작성한다.  예)  대학 관련 표준 도메인 정의 분류 도메인명 설명 데이터타입 길이 코드 이원코드 남녀  유무 CHAR 1 코드 대학코드 대학구분 코드 CHAR 3 . . .  	1
0000	논리적 설계 단계 심화 46 데이터 표준화 4) 표준 코드 정의 방법 ① 현재 사용 중인 코드와 필요하다면 추가 코드를 정의한다.   ② 표준 도메인을 적용해서 표준 코드를 정의한다.   ③ 데이터 표준화 지침을 참고해서 ‘표준 코드 정의서’을 작성한다.  예)  대학코드에 대한 표준 코드 정의 그룹코드 그룹코드명 데이터타입 길이 코드값 코드설명 GC001 대학코드 CHAR 3 01 한기대 GC001 대학코드 CHAR 3 02 서울대 . . . 	1
0000	데이터베이스 데이터베이스 - Story Board - 15 회차 : 물리적 설계 단계 김 은 경 	1
0000	물리적 설계 단계 2 학습목표 동기유발 & 학습목표 학습내용 1. 물리적 모델링 학습목표 2. 트랜잭션 분석과 인덱스 설계 1. 릴레이션 스키마를 내부 스키마로 변환할 수 있다.  2. 성능 향상을 위해 물리적 구조를 변경하는 방법에 대해 설명 할 수 있다.  1. 트랜잭션 분석 자료의 활용에 대해 설명할 수 있다.  2. 인덱스를 설계하는 3단계 절차를 나열할 수 있다.  	1
0000	물리적 설계 단계 3 Lesson.   물리적 모델링 1. 물리적 모델링 개요 2. 내부 스키마 작성 방법 3. 성능 향상과 물리적 구조 변경 갱신 이상과 함수적 종속 	1
0000	물리적 설계 단계 4 물리적 모델링 개요 1. 물리적 모델링 개요 (1) 물리적 모델링이란?  1) 물리적 모델링의 주요 업무 ① 논리적 스키마(릴레이션 스키마)를 기초로  DBMS의 특성과 구현 환경 등을 고려해서 내부 스키마(물리적 데이터 구조)를 정의한다.  ② 속성 즉  테이블 칼럼의 데이터 타입과 크기  제약조건 등을 정의한다.  ③ 데이터 사용량의 예측을 통해서 역정규화 및 인덱스 설계 작업을 수행한다.  (역정규화는 논리적 모델링 단계에서 수행할 수 있음)  2) 물리적 모델링의 특징 ① 논리적 모델링의 결과물인 하나의 릴레이션이 물리적으로 하나 이상의 테이블이 될 수 있다.  ② 논리적 모델링을 기초로 시스템 환경(하드웨어  운영체제  디스크 용량  네트워크  DBMS 제품 등)을 고려해서  성능 향상을 목적으로 물리적 모델링을 수행한다.  ③ 시스템 환경이 변경되면 물리적 모델링도 변경된다.  ④ 성능을 고려해서 통계 테이블이 추가되거나  백업이나 복제 용도의 테이블이 추가될 수 있다. 	1
0000	물리적 설계 단계 5 물리적 모델링 개요 트랜잭션 처리도(Throughput)  - 단위 시간당 처리할 수 있는 평균 트랜잭션의 수 (2) 물리적 모델링 시 고려사항 1) 응답 시간(Response Time)  - DBMS가 트랜잭션을 처리해서 결과를 반환하는데 소요되는 시간인 응답 시간을 최소화하도록 해야 한다.  2) 저장 공간 - DB 파일이나 인덱스 등을 저장하는데 필요한 저장 공간을 최소화하도록 해야 한다.  3) 트랜잭션 처리도(Throughput)    - 단위 시간당 처리할 수 있는 평균 트랜잭션의 수를 나타내는 트랜잭션 처리도가 성능에 큰 영향을 주므로  트랜잭션 처리도가 향상되도록 해야 한다.  보충 학습 	1
0000	물리적 설계 단계 6 [보충 학습]  로깅(Logging) – 어떤 어플리케 이션이 실행될 때마다 어떤 부분이 실행되며 또 어떤 데이터를 가져 오는지를 시스템 내부 에 기록하는 것 [보충 학습] 시스템 성능에 영향을 미치는 요소들 1) DBMS의 선정 - 업무의 특성에 맞는(즉  개념적 모델의 특성을 가장 잘 표현할 수 있는 논리적 데이터 모델을 기반으로 하는)  DBMS 제품을 선정해야 한다. (일반적으로 업무의 특성보다는 가격이나 영업 전략에 따라 선정되는 경우가 많다.)  2) 하드웨어 자원 - DB를 적용할 업무 시스템의 규모(사용자 수  트랜잭션 양 등)에 적합한 하드웨어 자원(CPU  디스크  메모리 등)을 확보해야 한다.  3) 데이터 전송량 - 통신을 통한 데이터 전송량이 많을수록 시스템 성능이 나빠진다.  (통신량을 최소화할 수 있는 최적화된 프로그램 개발이 요구됨)   4) 로깅(Logging) - 트랜잭션 처리 양과 형태  위치 등을 고려한 로깅 간격 및 위치 결정에 따라 성능이 달라진다.  5) 기타 - 업무 프로그램의 설계 및 코딩  데이터 접근 방식 등에 따라 성능이 달라진다.   	1
0000	물리적 설계 단계 7 내부 스키마 생성 방법 2. 내부 스키마 작성 방법 (1) 내부 스키마란?  - 논리적 스키마(릴레이션 스키마)와 무결성 제약조건 정의를 기초로 생성한 저장 레코드 양식을 의미하며  릴레이션을 테이블로 표현하고  속성은 칼럼으로  관련성은 외부 키로 표현하며  데이터 타입과 크기  제약조건 등을 포함한다.  (2) 내부 스키마 작성 사례 : 학사 관리 DB를 위한 내부 스키마 작성 1) 학사 관리 DB의 릴레이션 스키마와 무결성 제약조건 정의 교수(교수번호  교수이름  전공  학과) 학생(학번  이름  주소  학년  교수번호(FK)) 교과목(교과목번호   교과목명  학점   교수번호(FK)) 수강하다(학번(FK)  교과목번호(FK)  성적)   No. 무결성 제약조건 제약 유형 관련 릴레이션 1 교수이름  전공  학과는 널 값을 가질 수 없다.  NOT NULL 교수 2 이름과 학년은 널 값을 가질 수 없다 NOT NULL 학생 3 교과목명  학점은 널 값을 가질 수 없다.  NOT NULL 교과목 4 교과목명은 유일한 값을 가져야 한다.  UNIQUE 교과목 	1
0000	물리적 설계 단계 8 내부 스키마 생성 방법 2) 내부 스키마 작성 ① 교수(교수번호  교수이름  전공  학과) ② 학생(학번  이름  주소  학년  교수번호(FK))   No. 속성 칼럼이름 데이터타입 크기 NULL 허용 키 1 교수번호 prof_id NUMBER 4 N PK 2 교수이름 name VARCHAR2 20 N 3 전공 major VARCHAR2 20 N 4 학과 dept_num NUMBER 3 N No. 속성 칼럼이름 데이터타입 크기 NULL 허용 키 1 학번 std_id VARCHAR2 8 N PK 2 이름 name VARCHAR2 20 N 3 주소 addr VARCHAR2 30 4 학년 grade VARCHAR2 1 N 5 교수번호 prof_id NUMBER 4 FK 	1
0000	물리적 설계 단계 9 내부 스키마 생성 방법 ③ 교과목(교과목번호   교과목명  학점   교수번호(FK)) ④ 수강하다(학번(FK)  교과목번호(FK)  성적)   No. 속성 칼럼이름 데이터타입 크기 NULL 허용 키 기타 1 교과목번호 sub_num VARCHAR2 6 N PK 2 교과목명 sub_name VARCHAR2 20 N UNIQUE 3 학점 credit NUMBER 1 N DEFAULT 값 = 3 4 교수번호 prof_id NUMBER 4 FK No. 속성 칼럼이름 데이터타입 크기 NULL 허용 키 기타 1 학번 std_id VARCHAR2 8 N PK  FK 2 교과목번호 sub_num VARCHAR2 6 N PK  FK 3 성적 score NUMBER 3 	1
0000	물리적 설계 단계 10 성능 향상과 물리적 구조 변경 3. 성능 향상과 물리적 구조 변경 (1) 물리적 구조 변경 방법 1) 테이블 재정의 ① 성능 향상을 위해 역정규화를 통해서 테이블 구조를 재정의할 수 있다.  - 사소한 성능 향상을 위해서 데이터 무결성이 저해되지 않아야 한다.  - 정규형 모델에 심각한 성능 저하를 유발하는 요건이 존재하는 경우에만 역정규화 한다.  ② 성능 향상을 위해 중복된 정보를 포함하는 테이블을 추가할 수 있다. ③ 성능 향상을 위해 테이블을 수직 또는 수평 분할할 수 있다.  2) 칼럼 중복 ① 조인이 빈번하게 발생하는 경우  조인 조건에 해당하는 속성을 중복시킨다.  - 자주 사용되는 검색 조건이 여러 테이블에 분산되어 있는 경우  검색 조건에 포함되는 칼럼을 다른 테이블에 복사한다. ② 접근 경로를 단축하기 위해 부모 테이블(주 개체)에 자식 테이블(종속 개체)의 특정 칼럼의 집계(통계) 값을 저장하는 칼럼을 추가한다.  ③ 접근 경로를 단축하기 위해 자식 테이블에 부모 테이블의 칼럼을 복사해서 중복시킨다. ④ 연산된 결과를 주로 사용하는 경우  연산된 값을 저장하는 칼럼을 추가한다.          	1
0000	물리적 설계 단계 11 성능 향상과 물리적 구조 변경 (2) 테이블 추가 1) 통계 테이블 추가 - 자주 사용되는 통계(집계) 데이터가 여러 테이블에 산재되어 있는 데이터를 기초로 생성되는 경우  별도의 통계 테이블을 생성해서 추가한다. - 기존의 응용 프로그램들이 통계 테이블을 활용할 수 있어야 한다.  - 추가한 통계 테이블을 기초로 생성된 통계 데이터를 포함하는 또 다른 통계 테이블이나 간단한 조인으로 생성할 수 있는 통계 테이블은 추가하지 않는다.   [통계 테이블의 생성 및 활용]  테이블 A 테이블 B 테이블 C  통계 테이블 응용 프로그램 	1
0000	물리적 설계 단계 12 성능 향상과 물리적 구조 변경 2) 부분 테이블 추가 - 대용량 테이블의 특정 부분만 주로 사용되는 경우  해당 부분만 복사해서 별도의 테이블을 생성할 수 있다.  - 예:  3) 이력 테이블 추가 - 하나의 업무 단위가 시간의 흐름에 따라 반복적으로 발생하거나 변경되는 이력 또는 진행 이력이 필요한 경우 이력 테이블을 추가한다.  접수번호 고객 번호 고객명 접수 일자 접수 방법 접수확인 일자 접수 확인자 납부 일자 납부 방법 . . .  . . . . . . 접수 접수번호 고객 번호 접수 일자 접수 방법 접수확인 일자 접수 확인자 . . . . . . 접수확인 	1
0000	물리적 설계 단계 13 성능 향상과 물리적 구조 변경 (3)  테이블 분할 1) 수직 분할 - 특정 칼럼을 분리해서 별도의 테이블로 관리함으로써 물리적인 I/O 양을 감소시켜서 검색 성능을 향상시킨다.  ① 검색 위주의 칼럼과 갱신 위주의 칼럼으로 구분되는 경우 예) 회원정보 가운데 접속 정보는 자주 갱신되고  나머지 정보는 주로 검색만 되므로 이들 칼럼을 수직 분할해서 2개의 테이블로 만든다.  	1
0000	물리적 설계 단계 14 성능 향상과 물리적 구조 변경 회원번호 회원명 주민등록 번호 ID PW 등급 사진 . . . 최종로그인 일시 최종로그아웃 일시 . . . . . . 회원 회원번호 회원명 주민등록 번호 ID PW 등급 사진 . . . . . . . . . 회원정보 회원접속정보 회원번호 최종로그인 일시 최종로그아웃 일시 . . . . . . 자주 갱신됨 주로 검색만 됨 	1
0000	물리적 설계 단계 15 성능 향상과 물리적 구조 변경 ② 특별히 빈번하게 검색되는 칼럼이 있는 경우 예) 회원이 로그인할 때마다 회원번호와 id  패스워드(pw)가 자주 검색되므로 이들 칼럼을 수직 분할해서 2개의 테이블로 만든다.  회원번호 회원명 주민등 록번호 ID PW 등급 사진 . . . . . . . . . 회원정보 특히 자주 검색됨 회원번호 회원명 주민등 록번호 등급 사진 . . . . . . . . . 회원정보 회원번호 ID PW . . . . . . 회원인증정보 	1
0000	물리적 설계 단계 16 성능 향상과 물리적 구조 변경 LOB(Large Object) - 대용량 데이터를 저장하고 관리하기 위 해서 오라클이 제공하는 데이터 타입으로  4GB까지 지원함 ③ 특정 칼럼의 크기가 매우 큰 경우 - 테이블이 매우 큰 문자열이나 이미지 같은 LOB(Large Object) 형태의 데이터를 포함하는 경우  성능이 저하될 가능성이 있으므로 분할한다.  - 특히 백업(Backup)이나 복원(Recovery)의 효율성을 위해 분할해서 관리한다.  예) 회원의 사진 이미지를 저장하는 사진 칼럼만 분리해서 별도로 회원사진 테이블에 저장해서 관리한다.  회원번호 회원명 주민등 록번호 등급 사진 . . . . . . . . . 회원정보 회원번호 회원명 주민등 록번호 등급 . . . . . . . . . 회원정보 회원번호 사진 . . . . . . 회원사진 매우 큰 이미지를 저장함 	1
0000	물리적 설계 단계 17 성능 향상과 물리적 구조 변경 ④ 특정 칼럼에 보안이 필요한 경우 - DBMS에서 제공하는 데이터 보안의 단위가 객체(Object) 단위이므로  테이블 내 특정 칼럼에 대한 보안을 제어하기 위해서 칼럼을 분리해서 별도의 테이블로 관리한다.  예) 회원 정보 가운데 회원의 등급에 대한 보안이 필요한 경우  등급 칼럼만 분리해서 별도의 회원등급 테이블을 만든다.  회원번호 회원명 주민등 록번호 등급 . . . . . . . . . 회원정보 특별히 보안이 요구됨 회원번호 회원명 주민등 록번호 . . . . . . . . . 회원정보 회원번호 등급 . . . . . . 회원등급 	1
0000	물리적 설계 단계 18 성능 향상과 물리적 구조 변경 파티셔닝(Partitioning) - 하나의 DB 객체(테이블  인덱 스 등)를 여러 개의 세그먼트 로 나누는 것 2) 수평 분할 - 테이블의 행을 기준으로 분할해서 별도의 테이블로 관리함으로써 물리적인 I/O 양을 감소시켜서 검색 성능을 향상시킨다.  ① 한 테이블에 데이터가 너무 많고  특정 레코드 그룹에만 자주 접근하는 경우 적용한다. ② 분할된 각 테이블은 다른 디스크에 위치시켜서 디스크의 효율성을 극대화한다.  ③ DBMS가 제공하는 테이블 파티셔닝(Partitioning) 기능을 이용한다.    예)  접수에 대한 처리가 기본 키(접수번호와 접수일자)의 구간(분기별)에 따라 큰 차이가 있는 경우   기본 키에 따라 수평 분할해서 별도의 테이블로 분리해서 관리한다.    접수번호 접수일자 접수담당자 확인일자 . . . . . . . . . 접수 접수번호 접수일자 접수담당자 확인일자 . . . . . . . . . 접수_1분기 접수번호 접수일자 접수담당자 확인일자 . . . . . . . . . 접수_2분기 접수번호 접수일자 접수담당자 확인일자 . . . . . . . . . 접수_3분기 접수번호 접수일자 접수담당자 확인일자 . . . . . . . . . 접수_4분기 분기별로 수평 분할 	1
0000	물리적 설계 단계 19 성능 향상과 물리적 구조 변경 (4) 칼럼 중복 1) 동일 칼럼 추가 - 검색 성능을 향상시키기 위해 자주 검색되는 칼럼을 중복시킨다. - 데이터 무결성을 보장하기 위해서  중복되는 칼럼은 변경이 거의 일어나지 않아야 한다. - 예:  학생이 소속된 학과이름을 자주 검색해야 하는 경우  학과 테이블과의 조인을 통해서 알 수 있지만 검색 효율을 위해서 학생 테이블에 ‘학과명’ 칼럼을 중복시킨다.  학과번호 학과명 전화 번호 사무실 . . . 학과장 (FK) . . . . . . 학과 학번 이름 주민등 록번호 . . . 학과번호 (FK) 학과명 . . . . . . 학생 동일 칼럼 중복 	1
0000	물리적 설계 단계 20 성능 향상과 물리적 구조 변경 2) 파생(Derived) 칼럼 추가 - 다른 칼럼 값들을 기초로 계산된 합계  평균  개수 등의 파생된 값이 많이 활용하는 경우  파생 칼럼을 추가하면 검색 성능이 향상된다.  - 데이터 무결성을 보장하기 위해서 파생된 값의 기초가 되는 원래 칼럼의 값이 변경되는 경우   파생된 값도 연쇄적으로 변경되도록 정의해야 한다.  - 예: 학생의 평점은 수강한 각 교과목의 성적을 기초로 계산할 수 있지만  검색 효율을 위해서 ‘평점’이라는 파생 칼럼을 추가한다.  학번 (FK) 교과목번호 (FK) 이수학기 성적 . . . . . . . . . 수강 파생 칼럼 추가 학번 이름 주민등 록번호 . . . 학과번호 (FK) 평점 . . . . . . 학생 	1
0000	물리적 설계 단계 21 성능 향상과 물리적 구조 변경 3) 기본 키의 일부에 해당하는 칼럼 추가 - 기본 키가 여러 가지 정보를 포함하고 있는 경우  그 일부가 자주 사용되면 분리해서 별도의 칼럼을 추가한다. - 예: 학번에 학과 정보가 포함되어 있지만  학과별로 처리할 일이 많은 경우 ‘학과번호’ 칼럼을 별도로 추가한다.      학번 이름 주민등 록번호 . . . 학과번호 (FK) 학과번호 . . . . . . 학생 학번 구성 2012 36 185  입학년도(4자리) 학과(2자리) 개인번호(3자리) 기본 키의 일부에 해당하는 칼럼 추가 	1
0000	물리적 설계 단계 22 Lesson.  트랜잭션 분석과 인덱스 설계 1. 트랜잭션 분석 2. 인덱스 설계 3. 인덱스 설계 절차 단계별 정규화와 역정규화 	1
0000	물리적 설계 단계 23 트랜잭션 분석 1. 트랜잭션 분석 (1) 트랜잭션(Transaction)이란?  - 하나 이상의 SQL문으로 구성된 하나의 논리적인 작업 단위이다.  - 하나의 트랜잭션은 하나 이상의 DML 명령문 또는 하나의 DDL이나 DCL 명령문으로 구성된다.  (2) 트랜잭션 분석 대상 - DB의 검색  추가  삭제  변경 작업이 발생하는 단위 프로세스를 중심으로 트랜잭션의 양과 빈도수 등을 분석한다.  	1
0000	물리적 설계 단계 24 트랜잭션 분석 (3) 트랜잭션 분석 자료의 활용 1) 인덱스 설계의 참조 자료 - 인덱스는 DB 성능에 큰 영향을 주므로  트랜잭션 분석을 통해서 과부하가 발생하는 칼럼을 파악해서 인덱스 생성 여부를 결정한다.  예)  상품 주문을 처리하는 업무는 다음과 같이 4개 테이블에 추가 또는 검색함 테이블 트랜잭션 고객 상품 주문 주문목록 상품 주문 처리 SELECT SELECT INSERT INSERT . . . 회원번호 회원명 주민등록 번호 ID PW 등급 사진 . . . 최종로그인 일시 최종로그아웃 일시 . . . . . . 	1
0000	물리적 설계 단계 25 트랜잭션 분석 2) DB 용량 산정의 기초 자료 - 테이블과 인덱스  테이블 당 트랜잭션 양과 보존 기간 등을 고려해서 DB가 저장될 디스크의 용량을 산정한다.  - 예: 직원  승진  급여 테이블의 용량 산정하기 개체명 테이블명 행 길이 초기 데이터 수 트랜잭션 발생 주기 평균 발생 수 보존 기간 테이블 용량 직원 emp 120B 1000명 년 150명 20년 200M 승진 promo 80B 20개 학기 20 10년 20M 급여 salary 200B 10 000개 월 1000개 10년 500M . . .  	1
0000	물리적 설계 단계 26 트랜잭션 분석 테이블 스페이스(Table Space) - 오라클 서버가 DB에 데이터를 저장하는 논리적인 저장 단위 3) 디스크 구성 전략의 근거 자료 - 트랜잭션이 과도하게 집중되는 테이블이 있으면 각각 다른 테이블 스페이스(Table Space)에 배치해서 디스크 I/O를 분산시킨다.  	1
0000	물리적 설계 단계 27 인덱스 설계 2. 인덱스 설계 (1) 인덱스(Index)란?  - 포인터를 사용해서 행(Row)의 검색을 촉진할 수 있는 DB 객체이다. - 인덱스가 DB 성능에 큰 영향을 주므로  트랜잭션의 양과 데이터 분포  사용 빈도 등을 고려해서 적절한 수의 인덱스를 설계해야 한다.  (2) 인덱스의 특징 ① 테이블 행에 대한 직접적이고 빠른 접근을 제공한다.  ② 인덱스는 행을 식별할 수 있도록 칼럼의 값과 행의 논리적인 주소(RowId)로 구성되며  별도의 저장공간에 저장된다.  ③ 인덱스는 DBMS에 의해서 자동으로 생성되거나  사용자에 의해 명시적으로 생성될 수 있다. ④ 인덱스를 생성하면 일반적으로 물리적인 디스크 I/O가 감소되지만  인덱스를 너무 많이 생성하면 오히려 DML 처리 효율을 저하시키게 된다.  ⑤ 인덱스는 DBMS에 의해서 자동으로 사용되고 유지된다. ⑥ 인덱스는 테이블과는 논리적  물리적으로 독립적이다.  ⑦ 기본 테이블에 영향을 주지 않고 생성하거나 제거할 수 있다.  ⑧ 기본 테이블을 제거하면  인덱스도 자동으로 제거된다.  	1
0000	물리적 설계 단계 28 인덱스 설계 전체 테이블 스캔(Full Table  Scan: FTS) – 테이블에 존재하 는 모든 행을 순서대로 읽는 것 (3) 인덱스 선정 시 고려사항 ① 데이터 양이 적은 테이블은 인덱스를 생성하는 것보다 전체 테이블 스캔(Full Table Scan: FTS)이 더 효율적이다.  ② 인덱스가 많으면 검색 속도는 향상되지만 갱신 처리 시에 오버헤드(Overhead)가 발생한다.  ③ 검색(SELECT문)과 나머지 DML(INSERT  DELETE  UPDATE)의 비용은 1 : 4 정도이므로 검색 효율만을 위해서 지나치게 많은 인덱스를 생성하는 것은 좋지 않다.  ④ 검색 대상이 넓은 경우  즉 전체 데이터 가운데 상당수의 데이터를 검색하는 경우  인덱스를 사용하는 것은 오히려 비효율적일 수 있다.  (4) 인덱스 선정 기준 ① 분포도가 좋은 칼럼은 인덱스를 단독으로 생성해서 활용도를 향상시킨다.  ② SQL문의 WHERE절  ORDER BY절  GROUP BY절에 자주 사용되는 칼럼에 인덱스를 생성한다.  ③ 기본 키에 대해서는 인덱스가 자동으로 생성되므로 별도로 생성할 필요가 없다.  ④ 자주 조합되어 사용되는 칼럼의 경우  결합 인덱스를 생성한다.  ⑤ 테이블 간의 조인 조건으로 자주 사용되는 인덱스를 생성한다.  ⑥ 실제로 사용될 접근을 기초로 인덱스를 선정한다.  (5) 인덱스로 부적합한 대상 ① 수정이 자주 발생되는 칼럼 ② 분포도가 좋지 않은 칼럼 (즉  데이터 종류가 많지 않은 칼럼)  ③ 검색되는 행이 전체 행의 대부분에 해당하는 경우 ④ 검색 조건으로 자주 사용되지 않는 칼럼 보충 학습 	1
0000	물리적 설계 단계 29 [보충 학습]  [보충 학습] 전체 테이블 스캔과 인덱스 사용 접근의 차이점 1) 전체 테이블 스캔 (Full Table Scan: FTS)  - 테이블에 존재하는 모든 행을 순차적으로 접근한다.  2) 인덱스 사용 접근 - 먼저 인덱스를 읽어서 인덱스의 논리적인 주소(Rowid) 값을 가져와서 테이블에 랜덤(Random) 하게 접근한다.  직원 테이블 번호 이름 업무 번호 이름 업무 직원 테이블 직원 인덱스 번호 이름 업무 번호 이름 업무 인덱스 값 RowId 	1
0000	물리적 설계 단계 30 인덱스 설계 절차 3. 인덱스 설계 절차 (1) 인덱스 설계의 3 단계 절차 ① 인덱스 대상 선정 ② 인덱스 최적화 ③ 인덱스 정의서 작성 (2) 인덱스 대상 선정 ① 먼저 대상 테이블을 선정한 다음  SQL문에서 조인 조건(WHERE절)으로 자주 사용되거나   ORDER BY절  GROUP BY절 등에서 자주 사용되는 칼럼을 선정한다. ② 자주 사용되는 칼럼 가운데 평균 분포도(Selectivity)가 10~15% 이내인 칼럼을 선정한다.  ③ 자주 조합되어 사용되는 칼럼의 경우  결합 인덱스를 생성한다.  보충 학습 분포도(%) =  1 / 칼럼 값의 종류 * 100 =  해당 칼럼 값을 갖는 행의 평균 수/ 테이블의 총 행의 수 * 100 	1
0000	물리적 설계 단계 31 [보충 학습]  [보충 학습] 분포도(Selectivity)  (1) 분포도란? - 어떤 칼럼 값을 기준으로 검색했을 때 전체 데이터 가운데 얼마 만큼의 데이터가 선택되는지에 나타내는 것으로  분포도(%) 값이 작을수록 분포도가 좋다고 한다. (2) 분포도 계산식 (3) 분포도 계산 및 분석 예제 1) 기준 칼럼 : 학번(기본 키)   학생 테이블의 총 행 수 : 1 000개  분포도 = 1 / 1000 * 100          (학번 칼럼 값의 종류는 1 000개)  = 1 / 1000 * 100 = 0.1%  ; 기본 키는 모든 데이터가 다른 값을 가지므로  하나의 기본 키 값에 대해 1 000개 데이터 가운데 어떤 데이터가 선택될 확률이 0.1%이므로 분포도가 아주 좋다고 한다.    분포도(%) =  1 / 칼럼 값의 종류 * 100 =  해당 칼럼 값을 갖는 행의 평균 수/ 테이블의 총 행의 수 * 100 	1
0000	물리적 설계 단계 32 [보충 학습]  2) 기준 칼럼 : 성별  학생 테이블의 총 행 수 : 1 000개  분포도 = 1 / 2 * 100           (성별 칼럼 값의 종류는 단 2개)        = 500 / 1000 * 100 = 50%  ; 성별 칼럼은 남  여 둘 가운데 하나의 값을 가지므로  한 값에 대해 어떤 데이터가 선택될 확률이 50%이므로 분포도가 좋지 않다고 한다.  3) 기준 칼럼 : 전공   학생 테이블의 총 행 수 : 1 000개  분포도 = 1 / 10 * 100           (전공 칼럼 값의 종류는 10개)        = 100 / 1000 * 100 = 10%  ; 전공 칼럼은 10개의 값 가운데 하나를 가지므로  하나의 전공 값에 대해 1 000개 데이터 가운데 어떤 데이터가 선택될 확률이 10%이므로 분포도가 좋은 편이며  전공으로 검색하는 일이 많은 경우 전공 칼럼에 인덱스를 생성하는 것이 효율적이다.    	1
0000	물리적 설계 단계 33 인덱스 설계 절차 VARCHAR2( )  - 오라클의 가변 길이 데이터 타입 (3) 인덱스 최적화 1) 인덱스의 효율성 검토 - 인덱스를 생성한 칼럼은 수정이 자주 발생하지 않아야 한다. - 평균 분포도가 10~15% 이내로 양호해도 분포가 일정하지 않으면 인덱스를 설정하지 않아야 한다. - 한 테이블에 인덱스 수가 5개를 초과하는 경우  입력이나 수정  삭제가 자주 발생하면 인덱스를 삭제해야 한다.  2) 인덱스의 데이터타입 검토 - 칼럼에 업무 처리에 적합한 도메인이 지정되었어도  적절한 인덱스 활용을 위해서 칼럼의 데이터 타입을 변경할 수 있다. 예) 칼럼의 데이터 타입이 DATE인 경우  실제로 시∙분∙초까지 처리하지 않고 날짜 단위로 처리 한다면  DATE 보다 VARCHAR2(8) 형식으로 변경한다.  - 데이터 길이가 변경되는 칼럼은 오라클의 VARCHAR2()같은 가변길이 데이터타입을 사용한다.  	1
0000	물리적 설계 단계 34 인덱스 설계 절차 3) 인덱스 정렬 및 결합 인덱스 검토 - 인덱스는 정렬 상태에 따라 순정렬(Ascending) 인덱스와 역정렬(Descending) 인덱스가 있으므로 특히 역정렬 인덱스가 필요한지 검토한다. - 여러 칼럼이 동시에 사용될 때는 결합 인덱스를 생성한다.  - 결합 인덱스의 경우 인덱스를 구성하는 칼럼의 순서가 성능에 큰 영향을 미치므로 앞쪽에 오는 칼럼이 검색 대상의 범위를 줄일 수 있는 칼럼이 오도록 설계해야 한다.  4) 클러스터링(Clustering) 검토 - 검색 성능을 향상시킬 필요가 있지만 인덱스를 사용할 수 없는 경우  클러스터링을 고려한다. - 클러스터링의 경우 인덱스와는 반대로 분포도가 넓은(나쁜) 것이 좋다.  - 클러스터링도 검색 성능은 향상되지만 나머지 DML의 성능이 저하되므로 신중히 결정한다.  - 대량의 데이터를 처리하는 트랜잭션이 많은 경우 클러스터링을 사용하지 않는 것이 좋다.  	1
0000	물리적 설계 단계 35 인덱스 설계 절차 (4) 인덱스 정의서 작성 - 인덱스에 대한 정보를 포함하는 일종의 인덱스 명세서를 작성한다. - 예: 학사 관리 DB의 인덱스 정의서 관련 학습 : 12~13번 슬라이드 의 학사 관리 DB의 내부 스키마 학사 관리 DB의 인덱스 정의서 개체 타입명 테이블명 인덱스명 컬럼명 데이터 타입 인덱스 유형 (UNIQUE 여부) 정렬 키 여부 교수 prof prof_id_idx prof_id NUMBER(4) Yes ASC PK prof_name_idx name VARCHAR2(20) No ASC 학생 student std_id_idx std_id VARCHAR2(8) Yes ASC PK std_name_idx name VARCHAR2(20) No ASC 교과목 subject sub_num_idx sub_num VARCHAR2(6) Yes ASC PK sub_name_idx sub_name VARCHAR2(20) No ASC . . .  	1
0000	데이터베이스 데이터베이스 - Story Board - 16 회차 : 물리적 설계 단계 심화 및 DB 구현 집필교수 : 김 은 경 교수설계 : 이 러 닝 작성일: 2012. 11. 12. 	1
0000	물리적 설계 단계 심화 및 DB 구현 2 Lesson.   뷰와 디스크 용량 설계 1. 뷰 설계 2. 오라클의 논리적 저장구조 3. 디스크 용량 설계 갱신 이상과 함수적 종속 	1
0000	물리적 설계 단계 심화 및 DB 구현 3 뷰 설계 DB 객체(Object) – 테이블   뷰  인덱스  시퀀스 등과 같이 서로 다른 정보를 포함하고 있는 데이터를 참조하기 위한 논리적 구조를 의미한다. 1. 뷰 설계 (1) 뷰(View)란?  - 하나 이상의 테이블에 포함된 데이터의 부분 집합으로 구성되는 논리적인 테이블 즉  가상의 테이블(Virtual Table)이다. - 저장공간은 없지만 테이블과 거의 유사하게 사용할 수 있는 하나의 독립된 DB 객체이다.  (2) 뷰의 특징 ① 뷰를 사용하면 복잡한 테이블 구조를 단순화시켜서 효율적인 검색이 가능하다.  ② 하나 이상의 테이블을 기초로 뷰를 생성할 수 있다.  ③ 테이블뿐만 아니라 다른 뷰를 기초로 생성할 수 있다.  ④ 뷰 자체는 데이터를 직접 포함하지 않지만  창문 역할을 하는 뷰를 통해서 데이터의 검색 및 수정이 가능하다.  ⑤ 열 별칭을 사용해서 생성된 뷰에 대해서는 열 별칭을 사용한 조작만 가능하다.  ⑥ 뷰는 기초가 되는 테이블의 인덱스를 사용하므로  인덱스 칼럼은 함부로 가공해서는 안 된다.  	1
0000	물리적 설계 단계 심화 및 DB 구현 4 뷰 설계 보안 관리 - 인증되지 않은 DB  접근을 방지하기 위해서 데이터 접근을 제한하고 모니터링하는 기능을 의미한다.  (3) 뷰 활용의 장점 - 테이블을 직접 사용하지 않고 뷰를 사용하면 다음과 같은 장점을 얻을 수 있다. ① 보안 관리 지원 - 사용자가 특정 테이블의 데이터 가운데 뷰로 정의된 특정 부분만 접근할 수 있도록 제한하여 보안 관리가 가능하다.  즉  조건에 따라 데이터에 접근하는 사용자 그룹을 분류해서  각각 동일한 테이블의 다른 뷰를 기초로 데이터를 조작하도록 제한할 수 있다.  ② 사용 편의성 제공 - 다중 테이블을 기초로 뷰를 생성하면 테이블 조인이 불필요하게 되므로  복잡한 질의를 단순한 질의로 변환할 수 있다.  ③ 데이터 독립성 제공 - 테이블이 변경되어도 뷰는 그대로 유지할 수 있으므로  임시 사용자와 응용 프로그램에 대한 데이터 독립성을 제공할 수 있다. 	1
0000	물리적 설계 단계 심화 및 DB 구현 5 뷰 설계 (4) 뷰의 종류 - 뷰는 크게 단순 뷰와 복합 뷰로 구분할 수 있다. 1) 단순 뷰(Single View) - 단 하나의 테이블만을 기초로 생성된 뷰이다.. - 표현식 등에 의해 데이터가 조작된 경우를 제외하면  뷰를 통한 모든 DML 연산의 수행이 가능하다. 2) 복합 뷰(Complex or Join View) - 다중 테이블을 기초로 생성된 뷰이다. - 데이터 그룹핑 또는 그룹 함수를 사용해서 뷰를 생성할 수 있다.   - 뷰를 통한 모든 DML이 항상 가능한 것은 아니다. 보충 학습 	1
0000	물리적 설계 단계 심화 및 DB 구현 6 [보충 학습] [보충 학습] 뷰 생성 (1) 뷰 생성 방법 - CREATE VIEW 명령문에 서브쿼리를 이용해서 생성하고  뷰가 생성된 후 뷰 이름과 뷰 정의는 데이터 사전의 USER_VIEWS 테이블에 저장된다. (2) CREATE  VIEW 명령의 형식 - 서브쿼리를 수행해서 가져온 열(Column)들만으로 뷰를 생성한다.  (3) 옵션 설명 - FORCE : 기본 테이블의 존재 여부와 무관하게 뷰를 생성한다.        - NOFORCE : 기본 테이블이 존재할 때만 뷰를 생성한다.  - 열별칭: 서브쿼리에 의해 선택된 열이나 표현식에 대한 별칭을 지정한다.  - 서브쿼리 : 뷰에 포함될 데이터를 검색하는 SELECT 문을 작성한다. - WITH CHECK OPTION : 뷰에 의해 접근 가능한 행만 삽입 또는 수정될 수 있음을 명시한다.  - WITH READ ONLY : 뷰에 대해서 SELECT 만 가능하고  다른 DML 연산은 불가능함을 명시한다.  CREATE  [FORCE | NOFORCE]  VIEW  뷰이름 [(열별칭1[   열별칭2   . . .]) ] AS  서브쿼리 [WITH CHECK OPTION [CONSTRAINT  제약이름]] [WITH READ ONLY]; 	1
0000	물리적 설계 단계 심화 및 DB 구현 7 뷰 설계 (5) 뷰 및 뷰 정의서 사례 1) 뷰 사례 - 사원 테이블을 기초로 생성된 사원급여_뷰와 사원평가_뷰 사원번호 부서 번호 이름 직책 입사일 호봉 교육참여 점수 상사평가 점수 동료평가 점수 주소 연락처 3214 100 김철수 팀장 1998/01/01 20 10 20 18 서울 010-2300-1232 2456 200 이영호 프로그래머 2010/03/01 8 20 18 19 천안 010-9932-3234 2456 300 이영호 설계자 2005/01/01 13 15 18 18 천안 010-9932-3234 4602 100 박민희 사원 2012/09/01 5 10 15 16 서울 010-3329-0032 3722 300 김철수 팀장 2000/03/01 18 12 19 20 천안 010-3398-2136 사원 테이블 사원번호 이름 입사일 호봉 3214 김철수 1998/01/01 20 2456 이영호 2010/03/01 8 2456 이영호 2005/01/01 13 4602 박민희 2012/09/01 5 3722 김철수 2000/03/01 18 사원급여_뷰 사원번호 부서 번호 이름 직책 입사일 교육참여 점수 상사평가 점수 동료평가 점수 3214 100 김철수 팀장 1998/01/01 10 20 18 2456 200 이영호 프로그래머 2010/03/01 20 18 19 2456 300 이영호 설계자 2005/01/01 15 18 18 4602 100 박민희 사원 2012/09/01 10 15 16 3722 300 김철수 팀장 2000/03/01 12 19 20 사원평가_뷰 CREATE   VIEW  사원급여_뷰 AS  SELECT  사원번호  이름  입사일  호봉 FROM  사원;  CREATE   VIEW  사원평가_뷰 AS  SELECT  사원번호  부서번호  이름  직책     교육참여점수  상사평가점수  동료평가점수 FROM  사원;  	1
0000	물리적 설계 단계 심화 및 DB 구현 8 뷰 설계 2) 뷰 정의서 사례 뷰명 용도 기초 테이블 칼럼 데이터 타입 사원급여_뷰 급여관리 시스템에서 사용 사원 사원번호 CHAR(4) 사원명 VARCHAR2(20) 입사일 CHAR(10) 호봉 NUMBER(2) 사원평가_뷰 인사고가 시스템에서 사용 사원 사원번호 CHAR(4) 부서번호 CHAR(3) 사원명 VARCHAR2(20) 입사일 CHAR(8) 직책 VARCHAR2(20) 교육참여점수 NUMBER(3) 상사평가점수 NUMBER(3) 동료평가점수 NUMBER(3) 	1
0000	물리적 설계 단계 심화 및 DB 구현 9 오라클의 논리적 저장 구조 2. 오라클의 논리적 저장 구조 (1) 논리적 저장 구조의 계층 관계 - 논리적 저장 구조의 최소 단위인 데이터 블록   데이터 블록의 집합인 익스텐트  하나 이상의 익스텐트로 구성된 세그먼트  하나 이상의 세그먼트가 모여서 테이블 스페이스를 구성하는 논리적 저장 구조를 갖고 있다.  [오라클의 논리적 저장 구조의 계층 관계]  테이블 스페이스 (Table Space) 데이터베이스 (Database) 세그먼트 (Segment) 익스텐트 (Extent) 데이터 블록 (Data Block) 	1
0000	물리적 설계 단계 심화 및 DB 구현 10 오라클의 논리적 저장 구조 롤백(Rollback) - 데이터의 일관 성 유지를 위해서 모든 미결정된 데이터 변경을 무시함으로써 트 랜잭션을 종료하는 것을 의미한 다. 즉  데이터 변경을 취소하여 변경 이전 상태로 복구하는 것을 의미한다.  1) 테이블 스페이스(Table Space) - 오라클 서버가 DB에 데이터를 저장하는 논리적인 저장 단위이다.   - DB는 하나 이상의 테이블 스페이스로 구성된다. - 각 테이블 스페이스는 하나 이상의 세그먼트로 구성된다. - 물리적으로 디스크에 저장된 하나 이상의 데이터 파일로 구성된다. 2) 세그먼트(Segment) - 특정한 구조의 데이터를 포함하기 위한 논리적 저장 단위이다.  - 각 세그먼트는 하나 이상의 익스텐트로 구성된다. - 세그먼트의 종류 : 포함하는 데이터의 구조에 따라 4가지 종류로 구분한다. a) 데이터 세그먼트 : 테이블의 실제 데이터를 저장하는 공간이다. b) 인덱스 세그먼트 : 인덱스를 저장하는 공간이다.  c) 롤백(Rollback) 세그먼트 : 롤백  즉 실행 취소를 위한 트랜잭션을 임시로 기록하는 저장 공간이다.   d) 임시(Temporary) 세그먼트 : 데이터 정렬 등을 위해서 사용하는 임시 저장 공간이다. 3) 익스텐트(Extent) - 하나의 의미를 갖는 정보인 오라클 객체(DB 객체)를 저장하기 위한 연속적인 데이터 블록의 집합이다.   - 데이터 저장을 위해서 연속적으로 할당된 자유 데이터 블록(Free Data Block)의 집합이다. - 오라클의 기억장소 할당의 기본 단위가 된다.    4) 데이터 블록(Data Block) - 오라클 블록 또는 페이지(Page)라 칭하는 오라클의 최소 저장 단위이다. - 오라클 데이터 블록의 크기는 2K 내지 4K의 크기를 갖는다.  	1
0000	물리적 설계 단계 심화 및 DB 구현 11 오라클의 논리적 저장 구조 (2) 물리적 저장 단위 - OS 차원에서의 물리적 저장 단위는 크게 데이터 파일과 OS 블록으로 구분할 수 있다.  1) 데이터 파일 - 실제 데이터를 포함하면서 디스크에 저장되는 파일을 의미한다.   - 각 데이터 파일을 별도의 디스크에 저장할 수 있다. 2) OS 블록 - 실제 입출력 단위인 물리적인 I/O 블록을 의미한다.     	1
0000	물리적 설계 단계 심화 및 DB 구현 12 오라클의 논리적 저장 구조 (3) 논리적 저장 단위와 물리적 저장 단위의 관계 - 테이블 스페이스는 물리적으로 하나 이상의 데이터 파일로 구성되며  데이터 블록은 하나 이상의 OS 블록으로 구성된다.   1) 테이블 스페이스와 데이터 파일의 관계 - 하나의 테이블 스페이스는 하나 이상의 데이터 파일로 구성된다. 2) 데이터 블록과 OS 블록의 관계 - 하나의 데이터 블록은 하나 이상의 OS 블록으로 구성된다.  테이블 스페이스 (Table Space) 데이터 파일 1 (Data File 1) 데이터 파일 2 (Data File 2) 데이터 파일 3 (Data File 3) 데이터 블록 (Data Block) OS 블록 1   (OS Block 1) OS 블록 2   (OS Block 2) 	1
0000	물리적 설계 단계 심화 및 DB 구현 13 오라클의 논리적 저장 구조 (4) 테이블 스페이스의 종류 1) 시스템(System) 테이블 스페이스 - 오라클 DB가 처음 생성될 때 자동으로 생성되는  오라클의 디폴트(Default) 테이블 스페이스 이다.   - 디폴트로 모든 사용자가 이 시스템 테이블 스페이스를 기본 테이블 스페이스 및 임시 테이블 스페이스로 사용하게 된다.  - 주로 시스템 관리에 필요한 정보를 보관한다. 즉  모든 데이터 사전(Data Dictionary)의 정보와 저장 프로시저(Stored Procedure)  패키지 (Package)  트리거(Trigger) 등의 정의를 저장한다. - 사용자 데이터도 포함할 수 있으나 바람직하지 않다.   2) 비시스템(Non-System) 테이블 스페이스 - 보다 안정적인 DB 관리를 위해서 사용하는  시스템 테이블 스페이스와 분리된 저장 공간이다.   - 종류 : a) 사용자 테이블 스페이스 (USERS) - 사용자의 데이터를 저장한다. b) 임시 테이블 스페이스 (TEMP) - 정렬 등을 위해서 사용되는 임시 데이터를 저장한다. c) 롤백 테이블 스페이스 (RBS) - 롤백을 위한 트랜잭션을 저장한다.  d) 응용 테이블 스페이스 (APP_DATA) - DB 응용 프로그램의 데이터를 저장한다.  	1
0000	물리적 설계 단계 심화 및 DB 구현 14 (용어 사전)  (용어 사전)  1) 데이터 사전(Data Dictionary) - DB의 논리적인 구조와 사용자에 대한 정보  무결성 제약 정보 등  실제 사용자 데이터가 아닌 DB에 대한 각종 정보를 담고 있는 테이블의 집합이다. 2) 저장 프로시저(Stored Procedure) – 데이터 사전에 저장된 PL/SQL 블록을 칭한다.  . PL/SQL - 절차적 프로그래밍을 할 수 있도록 어플리케이션 로직(Logic)을 추가하여 SQL을 확장한 오라클의 절차적 언어이다. 3) 패키지(Package) - 프로시저와 함수를 논리적인 그룹으로 묶어 놓은 것이다. 4) 함수(Function) - 프로시저와 비슷하지만 값을 반환할 수 있다.    5) 트리거(Trigger) - 특정한 테이블에 특정 이벤트가 발생하는 경우 실행되는 프로시저이다. 	1
0000	물리적 설계 단계 심화 및 DB 구현 15 오라클의 논리적 저장 구조 (5) 테이블 스페이스 생성 및 사용자에게 할당하는 방법 - DB 관리자나 권한을 가진 사용자 만이 테이블 스페이스를 생성하는 것이 가능하다.  1) 사용자 테이블 스페이스 생성 예 2) 임시 테이블 스페이스 생성 예 CREATE TABLESPACE  users DATAFILE  ‘c:/oracle/oradata/orcl/test01.dbf’  SIZE 10M DEFAULT STORAGE (INITIAL 2M NEXT  1M MINEXTENTS  1 MAXEXTENTS  121  PCTINCREASE  0); CREATE TEMPORARY TABLESPACE  temp TEMPFILE ‘c:/oracle/oradata/orcl/temp01.f’  BITMAP  ALLOCATION UNIFORM SIZE  16M;  	1
0000	물리적 설계 단계 심화 및 DB 구현 16 오라클의 논리적 저장 구조 3) 테이블 스페이스 삭제 예 4) 사용자를 생성할 때 테이블 스페이스를 지정하는 방법 - DB 사용자를 생성하려면 CREATE USER 시스템 권한이 있어야 한다. - 예:  ID가 koreatech이고  password가 sunflower인 새로운 사용자를 생성하는 명령문 DROP TABLESPACE users;  CREATE USER   koreatech IDENTIFIED BY  sunflower DEFAULT TABLESPACE  users TEMPORARY TABLESPACE  temp; 	1
0000	물리적 설계 단계 심화 및 DB 구현 17 디스크 용량 설계 익스텐트(Extent) - 데이터 저장 을 위해서 연속적으로 할당된 자유 데이터 블록(Free Data  Block)의 집합이다. 3. 디스크 용량 설계 (1) 디스크 용량 설계란?  - 물리적 DB 설계 단계에서 데이터가 저장되는 디스크 공간을 정의하는 작업을 의미한다.  (2) 디스크 용량 설계의 목적 ① 정확한 데이터량을 산정해서 디스크 사용 효율을 향상시킨다. ② 업무량이 집중되는 디스크를 분리해서 집중화된 I/O 부하를 분산시킨다.  ③ 동일한 자원에 여러 프로세스가 동시에 접근할 때 발생하는 디스크 I/O 경합을 최소화해서 데이터 접근의 성능을 향상시킨다.  ④ DB 객체를 위한 익스텐트(Extent)의 추가를 감소시킨다.  (3) 디스크 용량 산정 방법 - 각 테이블 별로 한 행의 길이와 초기 데이터 수 및 주기별로 데이터가 추가되는 건수  데이터 증가율 및 데이터 보존 기간  트랜잭션 양 등을 고려해서 각 테이블의 용량을 산정하고  인덱스 때문에 필요한 공간 등을 고려해서 DB가 저장될 디스크의 총 용량을 산정한다.  	1
0000	물리적 설계 단계 심화 및 DB 구현 18 디스크 용량 설계 (4) 테이블 용량 산정 방법 - 각 테이블 별로 한 행의 길이와 초기 데이터 수 및 주기별로 데이터가 발생(추가)하는 건수  데이터 증가율 및 데이터 보존 기간 등을 고려해서 각 테이블의 용량을 산정한다. 예) 테이블 용량 산정 표 개체명 테이블명 행 길이 초기 데이터 수 삽입 주기 평균 삽입 수 보존 기간 테이블 용량 직원 emp 120B 1000명 년 150명 10년 100M 부서 dept 80B 20개 년 1 10년 30M 부품 item 300B 1500개 학기 100개 10년 500M . . .  	1
0000	물리적 설계 단계 심화 및 DB 구현 19 Lesson.  분산 설계 1. 분산 설계 개요 2. 테이블 분산 방법 분산 설계 	1
0000	물리적 설계 단계 심화 및 DB 구현 20 분산 설계 개요 1. 분산 설계 개요 (1) 분산 DB(Distributed DB)란?  - 하나의 논리적인 DB를 물리적으로 여러 곳에 분산시킨 후  하나의 가상 시스템으로 사용할 수 있도록 만든 DB이다.   - DB를 연결하는 빠른 네트워크 환경을 이용해서 DB를 여러 지역에 위치시켜서 성능을 극대화시킨 DB이다.   (2) 분산 DB의 활용 방향 - 최근 업무가 매우 다양해지고 데이터 양이 기하급수적으로 증가하는 추세이므로   과거의 위치 중심 분산 보다는 업무의 특성을 반영해서 분산하는 것이 바람직하다.  대전 부산 서울 네트워크 [위치 중심의 분산 설계] [업무 중심의 분산 설계] 내부 운영 외부 운영 	1
0000	물리적 설계 단계 심화 및 DB 구현 21 분산 설계 개요 (3) 분산 DB의 장단점 1) 장점 ① 빠른 응답 속도와 통신 비용 절감 효과 ② 데이터 가용성 및 신뢰성 증가 ③ 시스템 규모의 적절한 조절 가능 ④ 지역 사용자의 요구 수용 원할 2) 단점 ① 설계 및 관리의 복잡성 및 비용 증가 ② 응용 프로그램 개발 및 운용 비용 증가 ③ 불규칙한 응답 속도 ④ 통제의 어려움 ⑤ 데이터 무결성에 대한 위협 요인 증가 	1
0000	물리적 설계 단계 심화 및 DB 구현 22 테이블 분산 방법 2. 테이블 분산 방법 (1) 테이블 단위 위치 분산 - 테이블 구조를 변경하거나 테이블을 중복해서 생성하지 않고 테이블의 위치만 다르게 분산시킨다. - 위치에 따라 이용하는 테이블이 다른 경우  테이블 별로 위치를 분산시킨다.  예) 자재 품목은 서울 본사가 관리하고  생산 제품은 울산 지사에서 관리하는 경우  두 테이블을 서울 본사와 울산 지사에 각각 분산 위치시킨다.  - 테이블의 위치를 파악할 수 있도록 문서화해야 한다.  예)  DB 자재품목 관리 서울 본사 DB 생산제품 관리 울산 지사 네트워크 테이블 위치 사원 부서 협력사 자재 품목 생산제품 서울 본사 O O O 울산 지사 O O . . .  	1
0000	물리적 설계 단계 심화 및 DB 구현 23 테이블 분산 방법 (2) 수평 분할 분산 - 한 테이블을 특정 칼럼의 값을 기준으로 행(Row)을 분리해서 분산시킨다. - 필요한 경우 다시 하나의 테이블로 통합해도 데이터 중복이 발생하지 않아야 한다.  - 한 테이블에 속하는 데이터라도 위치에 따라 접근하는 데이터 그룹이 특정 칼럼 값을 기준으로 확연하게 구분되는 경우   한 테이블을 수평 분할해서 분산시킨다.  예) 생산 제품 가운데 울산 지사에서는 ‘생산일자’ 칼럼 값이 2012년 6월 이전인 제품을 관리하고   부산 지사에서는 ‘생산일자’ 칼럼 값이 2012년 6월 이후인 제품을 관리하는 경우  생산일자 칼럼 값을 기준으로 수평 분할한다. “제품번호  제품명  생산일자  단가” 로 수정해 주세요!!  울산지사 부산지사 네트워크 	1
0000	물리적 설계 단계 심화 및 DB 구현 24 테이블 분산 방법 (3) 수직 분할 분산 - 한 테이블의 칼럼(Column)들을 분리해서 위치를 분산시킨다.  (단  기본 키 칼럼은 중복됨)  - 필요한 경우 다시 하나의 테이블로 통합해도 데이터 중복이 발생하지 않아야 한다.  - 분산된 테이블을 조인해야 처리되는 업무가 있는 경우에는 수직 분할하지 않아야 한다. - 한 테이블에 속하는 데이터라도 위치에 따라 접근하는 칼럼이 분명하게 구분되는 경우   한 테이블을 수직 분할해서 분산시킨다.  예) 생산 제품의 제품번호와 단가 칼럼 값은 서울 본사 업무에만 필요하고  각 제품의 생산일자와 재고량 칼럼 값은 울산 지사 업무에만 필요한 경우  수직 분할해서 테이블을 분산시킨다.  서울본사 울산지사 네트워크 “제품번호  단가  생산일자  재고량” 으로 수정해 주세요!!  수직 분할은 이론상으로는 가능하지만  실제로 수직 분할해서 테이블을 분산시 키는 경우는 매우 드물다.  	1
0000	물리적 설계 단계 심화 및 DB 구현 25 테이블 분산 방법 (4) 테이블 요약(Summarization) 분산 1) 분산 요약 - 여러 위치(지점)에 있는 데이터를 한 곳(본사)에서 통합해서 전체적인 요약 데이터를 생성하는 것이다. - 여러 위치의 테이블을 조인하는 오버헤드로 인해 업무에 장애가 발생할 수 있으므로 사용 시 유의해야 한다.  2) 통합 요약 - 각 위치 별로 산출한 요약 정보를 한 곳에 취합해서 통계 정보를 쉽게 제공하는 것이다.  - 여러 위치의 테이블을 조인할 필요가 없으며  주로 야간을 이용해서 데이터를 복사해서 요약 정보를 한 곳에 통합한다.  	1
0000	물리적 설계 단계 심화 및 DB 구현 26 Lesson.  DB 구현 및 테스트 단계 1. 구현 단계의 주요 업무 2. 테스트 단계의 주요 업무 3. DB 생성 및 초기 데이터 삽입 DB 구현 및 테스트 단계 	1
0000	물리적 설계 단계 심화 및 DB 구현 27 구현 단계의 주요 업무 1. 구현 단계의 주요 업무 - 구현 시에는 설계된 DB 구조를 선택한 DBMS의 DDL로 작성하고  트랜잭션 처리를 위한 응용 프로그램 작성 등의 업무 뿐만 아니라  추후 유지보수를 위한 문서화 작업도 주요 업무 가운데 하나이다.  설계된 DB 구조를 DDL로 작성 기존 DB를 새로운 DB로 변환 DB에 초기 데이터 적재(loading) 구현 단계 의 주요 업무 트랜잭션 처리용 응용 프로그램 작성 유지보수를 위한 문서화 작업 내부 스키마를 기초로 목표 DBMS의 DDL로 DB 스키마를 작성 하고 컴파일해서 공백(Empty) DB 파일을 생성한다.  기존 DB가 있는 경우 변환 루틴이나 유틸리티를 사용해서 기존 데이터 파일을 변환해서 초기 데이터를 입력한다.   INSERT 명령문을 활용해서 초기 데이터를 직접 삽입한다. DML 명령문을 사용해서 트랜잭션 처리용 응용 프로그램 코드 를 작성한다.  추후 유지보수를 위해 자세한 문서화 작업을 수행한다.  	1
0000	물리적 설계 단계 심화 및 DB 구현 28 테스트 단계의 주요 업무 2. 테스트 단계의 주요 업무 ① 생성된 DB 구조가 설계된 DB 구조와 일치하는 지 확인한다. ② 응용 프로그램과 DB의 연동이 원활한지 확인한다.   ③ 트랜잭션 유형별로 테스트 케이스를 선정하여 데이터 조작이 원활한 지 확인한다. 	1
0000	물리적 설계 단계 심화 및 DB 구현 29 DB 생성 및 초기 데이터 삽입 3. DB 생성 및 초기 데이터 삽입 (1) DB 생성 - CREATE TABLE 명령문을 사용해서 빈 테이블을 생성한다.  - 예: 다음 내부 스키마를 기초로 교수 테이블을 생성하시오.   DDL로 생성한 DB 스키마:    CREATE TABLE prof ( prof_id  NUMBER(4)     name  VARCHAR2(20)    major             VARCHAR2(20)  dept_num        NUMBER(3)   CONSTRAINT  prof_id_pk PRIMARY  KEY(prof_id)   CONSTRAINY  dept_num_fk  FOREIGN  KEY(dept_num)   REFERENCES  dept(dept_id); No. 속성 칼럼이름 데이터타입 크기 NULL 허용 키 1 교수번호 prof_id NUMBER 4 N PK 2 교수이름 name VARCHAR2 20 N 3 전공 major VARCHAR2 20 4 학과 dept_num NUMBER 3 N FK 교수(prof) 테이블 dept_num은 dept 테이블의 dept_id를 참조하는 외래 키임 을 정의함 	1
0000	물리적 설계 단계 심화 및 DB 구현 30 DB 생성 및 초기 데이터 삽입 (2) 초기 데이터 삽입 - INSERT 명령문을 사용해서 초기 데이터를 삽입한다.  - 예: 앞에서 생성한 prof 테이블에 초기 데이터를 삽입하시오.  INSERT INTO prof (1101  ‘김철수’  ‘컴퓨터’  112); INSERT INTO prof (1108  ‘이영미’  ‘전자’  113); INSERT INTO prof (1205  ‘박남수’  ‘컴퓨터’  112); INSERT INTO prof (1228  ‘최영우’  ‘전기’  115); INSERT INTO prof (1320  ‘장민이’  ‘기계’  117); . . .  	1
0000	물리적 설계 단계 심화 및 DB 구현 31 쉼터 쉼터 	1
0000	안녕하세요? 교수님 과제 탭에 3주차 개별과제가 등록되었다고 하셨는데  보이지가 않습니다	1
0000	3주차 ER 다이어그램 과제에 질문이 있습니다. 손으로 작성해도 되고 별도의 종이에 해도 된다고 써져있는데  수기가 아닌 파워포인트같은 프로그램을 이용해서 컴퓨터로 작성하는 건 안되나요??	1
0000	1번 문제 해설을 봐도 잘 이해가 안가서 질문드립니다. 기본키란 후보키 중에서 사용자가 지정한 하나의 후보키가 기본키라고 하는데 어떤 이유로(상품번호 구매id 구매일시)3가지가 기본키가 될 수 있는지 궁금합니다	1
0000	팀 프로젝트 주제를 주어진 시나리오에서 1개 이상  자발적 주제탐색으로 1개 이상 선정하는 건가요?? 아니면 시나리오에서만 2개를 선정해도 되는 건가요??	1
0000	이번 ER 다이어그램 과제 중에서 질문이 있습니다.  여행사가 현재 20대의 관광버스를 소유하고 있다는 것은  ER 다이어그램을 작성할 때 고려요소가 아닌가요?  저는 현재 20대라는 정보가 출발여부 등에 사용될 수 있다고 생각해서 현재 소유 버스 수를 속성으로 넣어야 하는 줄 알았습니다.  이러한 정보는 다이어그램에서 표현하지 않아도 되는 것인지 궁금합니다.	1
0000	저는 쇼핑몰 운영자가 상품별 재고를 검색한다가 상품관리업무에 들어간다고 생각하여 트랜잭션 요구분석의 상품관리에 넣어서 문제를 풀어봤습니다. 교수님의 답안에는 판매 관리업무에 들어간다고 되어있는데 왜 판매 관리 업무에 들어가는지 궁금합니다.	1
0000	저희가 제주도 게스트하우스 웹사이트 설계를 하는데 있어서 특산품 판매처 개체를 유지시켜야 하는지 없애도 되는지 헷갈립니다 회원개체가 있고 저희 휍사이트 특성상 일반회원  사장 회원  특산물 판매 회원이 분류가 되는데 추후 개념적 설계를 할때 특산품 판매처 개체가 없다면 판매회원과 특산품 개체사이에 판매하다라는 관계를 설계할 수 있다고 생각합니다. 여기서 의문점이 일반회원과 판매회원은 회원이라는 개체 안에 속해있는데 일반회원이 특산품을 구매하다라는 관계가 있을 수 있고 판매회원이 특산품을 판매하다라는 관계가 있을 수 있는데 이렇게 되면 나중에 개체식별 심화단계에서 서브개체 기준으로 통합을 해야하는지..... 감이 잘 안잡힙니다	1
0000	1.중고거래관리라는 업무영역에서 당근마켓과 같이 판매자가 판매상품을 올리고 회원들이 그 물건을 구매할 수 있도록 하려고 합니다. 이런 경우에 저희 생각으로는 거래에 대한 내용이 필요하지 않다고 생각되는데 이런 경우에도 거래에 대한 내용이 필요한가요??  2. 공동구매 할인율이 수량에 따라서 변경되도록 구체적으로 작성하려고 합니다. 이 경우에 데이터 요구분석과 트랜잭션 요구분석 모두에 작성해야하나요? 	1
0000	평가 기준 중 개념적 설계 항목에서 개체와 관계의 수가 15개 이상 이라는 내용이 있는데 개체와 관계의 수 각각이 15개 이상을 의미하는 것인지  아니면 개체와 관계 둘을 합친 수가 15개 이상을 의미하는 것인지 알고 싶습니다.	1
0000	대배설이 매주 수요일 3~4 / 6~7 교시로 편성이 되어있는데 모바일 프로그래밍 과목이 10주차에 수요일 1~4교시로 편성되어 있습니다.  어떻게 해야 하나요?	1
0000	1. 저희 주제가 문화재인데 ER다이어그램을 제작하던 중 문화재와 연결되어있는 다른 개체가 없는것을 파악하였습니다. 그래서 관련되다 혹은 포함하다  연관되다 등으로 관계를 식별하려고 하는데 이게 맞는건가요? 아니면 그냥 관계가 없어도 되는 것인가요?   2. 제약조건은 몇개 이상 되어야 하는지 궁금합니다!	1
0000	1  요구수집 및 분석과 개념적설계를 위해 했던 회의들의 회의록을 전부 기재하는 건가요?  2. 회의록은 따로 제출이 아니라 중간보고서.hwp 파일에 넣는건가요?	1
0000	2팀 여우다람쥐조입니다.  1. 트랜잭션요구분석에 작성시에 슈퍼개체와 서브개체가 있다면 이것을 각각 지정하는게 맞나요?  공통부분은 슈퍼개체를 주어로 하여 작성하고 개별적인 부분만 서브개체를 주어로 하여 작성하면되나요?  2. 등산용품구매관리에 대해서 상품을 중고상품과 새상품으로 나누고 새상품을 일반상품과 공동구매상품으로 나누려고합니다.  일반상품과 공동구매상품의 관계가 유사하고 속성이 비슷하다는 판단으로 이 둘을 새상품이라는 슈퍼개체로 묶어서 하려고 생각을 했습니다. 하지만 일반상품의 경우 슈퍼개체인 새상품과 구분할만한 속성이 없습니다. 이런 경우 어떻게 해야 하나요?  상품을 슈퍼개체로 하여  중고상품  일반상품  공동구매상품의 서브개체로 나누는 것으로 해야 하나요?  일반상품과 공동구매상품이 매우 유사해서 이렇게 나눠도 되는지 궁금합니다.	1
0000	안녕하십니까 교수님 2팀 여우다람쥐입니다. 팀프로젝트를 진행하던 도중 의문점이 생겨 질문을 드리게 됐습니다. 저희 조는 현재 등산과 관련된 아이디어로 프로젝트를 진행중인데  등산용품 관리 부분에서 상품을 슈퍼 개체로 놓고 중고상품  일반상품  공동구매상품을 서브 개체로 두었습니다. 그런데 업무영역 분할도에 이것을 표현하고 데이터 요구 분석 명세서를 작성하는 도중  상품이라는 슈퍼 개체의 정의를 어디에 해야할지 의문이 들었습니다. 저희 조에선 이를 해결하기 위해 데이터 요구분석 명세서에서 상품 관리 항목을 통합시키려고 했습니다. 만약 이렇게 했을 때  업무영역 분할도에서 서브 개체인 중고상품  일반상품  공동구매상품을 지워야하는지  그대로 써도 되는지를 여쭤보고 싶습니다.	1
0000	1) 개체식별단계에서 속성이 다중치 속성이라면 다중치 속성인 것을 표시해야하나요?    2) 약한 개체는 구별자가 꼭 있어야하나요?	1
0000	과제란에 팀프로젝트 중간발표 및 중간보고서 파일을 기한 내에 등록하고  11월 4일 발표시간(3 4교시)에 중간발표 자료 및 중간보고서의 출력물은 별도로 제출해야 합니다. 라고 되어있는데  11우러 4일에 별도로 제출한다는 것은 ppt와 중간보고서 hwp파일을 출력해서 제출해야 한다는 건가요?	1
0000	안녕하세요 교수님. 중간고사 시험과 관련하여 궁금한 것이 있어서 질문드립니다.  전에 SQL문 작성과 관련하여 따로 공부하라고 하셨는데  이번 중간고사 시험범위에 포함이 되는지 궁금합니다. 감사합니다.	1
0000	1) 이번 보고서 작성 시 릴레이션 정규화한 것을 중간보고서에 이어적는 것이 아니라 보고서 내용 1) 선정한 주제 : 어떤 목적(업무)을 위한 DB 구축인지 간단히 설명 2) 논리적 스키마 모델링 결과물(단순화된 최종 릴레이션 스키마  무결성 제약조건 정의  릴레이션별 정규화 내용)에 해당하는 부분만 작성하면 될까요?  2) 그러면 보고서 피드백에 적힌 부분은 최종보고서 제출할 때 수정해서 작성하면 될까요?	1
0000	입장권 릴레이션 정규화를 하다가 어려운 것이 있어서 질문드립니다.  입장권 구분은 성인  소인 이런식으로 되어있어서 구분에 따라 판매가격이 정해지게 됩니다.  그렇다면 구분을 알면 판매가격을 알 수 있으니 이행적 함수적 종속 관계가 성립하는 건가요?  만약 성립한다면 릴레이션 분리를 해야되는 건가요?	1
0000	교수님 이행적 함수종속관계분석에 대해서 좀 헷갈리는 부분이 있습니다. 예를 들어 회원(ID(PK) 이름 패스워드 휴대폰번호)와 같은 릴레이션 스키마가 있을 경우에 휴대폰번호를 알면 회원의 이름도 알 수 있으므로 이행적 함수적 종속이 될 수도 있다고 생각하는데  아니면 패스워드 휴대폰번호 같은 대체키 속성들은 이행적 함수적 종속 관계에서 제외시켜야 하나요?	1
0000	관계 릴레이션과 같은 경우  기본키 역할을 할 설계속성을 추가했는데  이 같은 경우에는 대체키에는 외래키의 조합이 되는 건가요?  예를 들어 구매하다(주문번호  회원번호(FK)  상품_id(FK)  구매일자  수량  배송일자)라는 릴레이션에서 주문번호를 {회원번호  상품_id} 대신에 사용하기 때문에 기본키인데  대체키로는 {회원번호  상품_id}가 되는 건가요?  *또 이것과는 별개의 질문인데  모든 릴레이션 정규화를 표로 작성하는 건가요?	1
0000	함수적 종속을 작성할 때 속성으로 외래키가 존재한다면 종속자에 외래키를 넣는 게 맞는지 빼는게 맞는 지 궁금합니다.	1
0000	교수님 저는 학교내에 동아리 이름이 같은 이름의 동아리가 존재할 수 없다고 생각했고 따라서 동아리 이름을 알면 지도교수를 알 수 있다고 생각하여 이행적 함수 종속관계가 있다고 생각하였습니다.  따라서 3정규화 제약조건을 만족하지 않는다고 생각하여 릴레이션 정규화를 하였는데 이 부분은 성립될 수 없는 건지 궁금합니다	1
0000	안녕하세요 교수님.  릴레이션 정규화 피드백에 대해서 궁금한게 있어서 질문드립니다.     1.동아리 게시글은 동아리의 약한 개체로 넣은거라서 기본키가 동아리 id와 게시글id의 조합으로 되는 것이 맞지않나요??  게시글 id가 동아리 id없이 구별자 역할을 할 수 있기 때문인가요??  2. 만약에 기본키가 동아리 id와 게시글id의 조합이 맞다면 기존에 작성했던 대로 릴레이션 분해가 되는 것이 맞나요?	1
0000	시연을 오라클이 아닌 mssql로 해도 상관없나요? 아니면 꼭 오라클 isql을 사용해야 하나요?	1
0000	isql 로그인을 어떻게 해야하는 건지 모르겠습니다. 제가 아이디를 따로 만들어야 하나요? 아니면 제가 입력해야하는 학생 아이디가 따로 이미 있는건가요?	1
0000	교수님 저희는 제주도 게스트하우스 DB 구축 주제로 하고 있습니다.  저번 릴레이션 정규화 피드백 해주신것중에서 쿠폰개체에 관련하여 궁금한점이 있습니다.  저희는 쿠폰종류에는 2가지 즉 특산품 쿠폰과 액티비티 쿠폰이 있고 데이터요구분석 명세서에서 특산품 쿠폰은 유효기간이 30일 액티비티 쿠폰은 유효기간이 60일로 정하였습니다.  그리고 회원과 쿠폰사이에 발급하다라는 릴레이션에서 발급일시 사용일자를 추가하였습니다.  교수님께서 피드백해주실 때 유효기간이 달라질 경우를 고려하라고 말씀하셨는데 저희가 설계한 내용대로 진행한다면 문제가 있을까요??	1
0000	교수님 회원 릴레이션의 최근 로인일시라는 속성을 회원이 로그인 한 일시에 맞게 매번 최신화를 해야 하는데   테이블을 생성을 어떤 식으로 접근해야하는지 잘 모르겠습니다..  (ID 최근로그인일시)처럼  따로 테이블을 분리시켜야 하는 방법이 적절한건가요?	1
0000	최종보고서에 8번에 삽입/삭제/변경 각 1개는 모든 테이블에 대해 각각 해야 하는 건가요?	1
0000	오라클에서 select * from tab을 하면 이름모를 테이블들이 많이 들어있는데 혹시 이것들을 다 지울 수 있는 방법이 있을까요?	1
0000	인덱스를 사용해야할 컬럼 중 열이 광범위한 값을 포함할때의 의미가 무엇인지 잘 이해가 가질 않아 질문드립니다. 해당 데이터 수가 아주 많은 경우로 해석하면 될까요?	1
0000	과제란에 스크립트파일을 제출하는 과제는 없던데 내지 않아도 되는 건가요?	1
0000	안녕하세요. 교수님  출석을 확인하였는데 7주차 7차시(10월 12일)이 결석으로 되어있어 문의드립니다! 해당 강의를 확인해보니 팀프로젝트 보고서 피드백의 실시간 강의의 녹화본인데  실시간 강의에 참가를 하여 따로 녹화된 강의는 수강하지 않았습니다. 이 경우에도 결석이 되는건가요? 아니면 출결점수에는 따로 영향이 없는건가요?	1
0000	실습주간에 봤던 중간고사 점수는 언제쯤 알 수 있나요??	1